# Lab: JWT Security Testing for Python Developers - Assessments

## Assessment Overview

| Level | Questions | Passing Score | Format |
|-------|-----------|---------------|--------|
| L1 | 10 questions | 80% (8/10) | Multiple choice |
| L2 | 10 questions | 80% (8/10) | Multiple choice + scenario |
| L3 | 8 questions + practical | 80% + practical pass | Scenario + code review |

---

## Level 1 Assessment: JWT Reconnaissance & Basic Exploitation

### Instructions
- 10 multiple choice questions
- 80% passing score required (8/10 correct)
- Time limit: 15 minutes

---

### Questions

**Q1. When analyzing a captured JWT, which part reveals the signing algorithm used?**

- A) The payload (second segment)
- B) The signature (third segment)
- C) The header (first segment) ✓
- D) The algorithm is not stored in the token

**Explanation:** The JWT header is the first Base64URL-encoded segment and contains the `alg` field (e.g., `HS256`, `RS256`). Decoding the header is the first step in JWT reconnaissance.

---

**Q2. An attacker captures a JWT and decodes the header to find `"alg": "HS256"`. Which attack should they attempt FIRST?**

- A) Algorithm confusion (RS256 to HS256)
- B) Brute-force the HMAC signing secret ✓
- C) Inject a JWK header
- D) Exploit kid path traversal

**Explanation:** When the algorithm is HS256 (symmetric), the most direct attack is brute-forcing the secret key. If the secret is weak (common word, short string), it can be cracked offline in seconds with a wordlist.

---

**Q3. Which Python code correctly constructs an `alg:none` forged JWT to escalate privileges?**

- A) `jwt.encode({"sub": "admin"}, None, algorithm="none")` ✓
- B) `jwt.encode({"sub": "admin"}, "secret", algorithm="HS256")`
- C) `jwt.encode({"sub": "admin"}, "", algorithm="")`
- D) `base64.encode(json.dumps({"sub": "admin"}))`

**Explanation:** Using `algorithm="none"` with `key=None` creates a JWT with no signature. If the server's algorithm allowlist includes `"none"`, this forged token is accepted without any secret.

---

**Q4. Why is JWT secret brute-forcing performed offline rather than online?**

- A) Online attacks are illegal
- B) JWT libraries require offline verification
- C) Offline attacks are slower but more reliable
- D) The token signature can be verified locally without contacting the server ✓

**Explanation:** An attacker who captures a single JWT can compute `HMAC(header.payload, candidate_secret)` locally and compare it to the token's signature. No server interaction is needed, so there are no rate limits, account lockouts, or detection mechanisms.

---

**Q5. Which of these is the MOST likely weak JWT secret that a brute-force attack would find?**

- A) `a9f2k$8xR!mP3qZw7`
- B) `secret` ✓
- C) `7a3b9c1d5e8f2a4b6c0d3e7f1a5b9c2d`
- D) `hE7$kL9!mN2@pQ4&`

**Explanation:** The string `"secret"` is the default value used by many JWT tutorials, frameworks, and jwt.io. It appears in virtually every wordlist and would be cracked in the first few attempts.

---

**Q6. An attacker obtains a JWT with `exp` set to a timestamp in the past. Which vulnerability does this test for?**

- A) Weak signing secret
- B) Missing audience validation
- C) Disabled expiry validation ✓
- D) Algorithm confusion

**Explanation:** If the server accepts a token with an expired `exp` claim, it means expiry validation is disabled (e.g., `verify_exp: False`). This allows captured tokens to be replayed indefinitely.

---

**Q7. What information can an attacker extract from a JWT payload WITHOUT knowing the signing secret?**

- A) Nothing — the payload is encrypted
- B) Only the algorithm type
- C) The user's identity, role, email, and all other claims ✓
- D) Only the token expiration time

**Explanation:** JWT payloads are Base64URL-encoded, NOT encrypted. Anyone can decode and read all claims (sub, role, email, etc.). The signature only ensures integrity, not confidentiality.

---

**Q8. What is the purpose of including `-d "password123"` in `hashcat -m 16500 token.txt -a 3`?**

- A) It specifies the output format
- B) It sets the JWT hash mode for brute-forcing
- C) It provides a dictionary/mask for the attack
- D) `-m 16500` is the JWT mode; `-a 3` means brute-force mask attack ✓

**Explanation:** In hashcat, mode 16500 targets JWT tokens. The `-a 3` flag selects mask (brute-force) attack mode. The actual wordlist/mask would follow the command. This is an industry-standard tool for offline JWT secret cracking.

---

**Q9. Before testing JWT vulnerabilities on any system, what MUST an attacker have?**

- A) Explicit written authorization from the system owner ✓
- B) A valid user account
- C) A copy of the application source code
- D) Administrative access to the server

**Explanation:** Testing for vulnerabilities without authorization is illegal in most jurisdictions. Penetration testers must have explicit written authorization (scope, rules of engagement) before testing any system.

---

**Q10. Given a token with `{"sub":"alice","role":"user","aud":"billing-api"}`, which attack exploits missing audience validation?**

- A) Submit this token to the admin API endpoint ✓
- B) Change the algorithm to none
- C) Brute-force the signing secret
- D) Inject an XXE payload

**Explanation:** If the admin API does not validate the `aud` claim, a token intended for `billing-api` will be accepted. This cross-service token reuse is a direct consequence of missing audience validation.

---

## Level 2 Assessment: Advanced JWT Exploitation

### Instructions
- 10 multiple choice and scenario-based questions
- 80% passing score required (8/10 correct)
- Time limit: 25 minutes

---

### Questions

**Q1. In an algorithm confusion attack, an attacker changes the JWT algorithm from RS256 to HS256. What do they use as the HMAC signing secret?**

- A) The server's RSA private key
- B) An empty string
- C) The server's RSA public key ✓
- D) A randomly generated secret

**Explanation:** When a server accepts both RS256 and HS256, an attacker can use the RSA public key (which is public!) as the HMAC secret. The server's `jwt.decode(token, public_key, algorithms=["RS256", "HS256"])` will verify the HS256 signature using the public key bytes.

---

**Q2. Where does an attacker typically obtain the RSA public key needed for an algorithm confusion attack?**

- A) From the server's error messages
- B) From the `/.well-known/jwks.json` endpoint or TLS certificate ✓
- C) By brute-forcing the private key
- D) From the JWT payload claims

**Explanation:** RSA public keys are intentionally public. They are exposed via JWKS endpoints, TLS certificates, SAML metadata, or API documentation. This is by design — the vulnerability lies in the server accepting both RS256 and HS256.

---

**Q3. An attacker sets the JWT `kid` header to `../../etc/hostname`. What type of attack is this?**

- A) SQL injection
- B) XML external entity injection
- C) Command injection
- D) Path traversal — the server reads the hostname file as the verification key ✓

**Explanation:** If the server constructs a file path from the `kid` value without sanitization (e.g., `open(f"/keys/{kid}")`), path traversal allows reading arbitrary files. The attacker then uses the file contents as the HMAC secret to sign a forged token.

---

**Q4. Which `kid` value would enable SQL injection to control the JWT verification secret?**

- A) `' UNION SELECT 'attacker-controlled-secret' -- ` ✓
- B) `key-001; DROP TABLE keys;--`
- C) `../../../etc/passwd`
- D) `<script>alert(1)</script>`

**Explanation:** If the server uses `kid` in a SQL query like `SELECT secret FROM keys WHERE kid = '{kid}'`, a UNION injection allows the attacker to return their own chosen secret value, which they then use to sign a forged token.

---

> **Scenario for Q5-Q6:** You are testing an API that serves protected resources at `GET /api/data`. The endpoint accepts JWTs via the `Authorization: Bearer <token>` header. You discover that the endpoint also accepts tokens from the `?token=` query parameter.

**Q5. What is the primary security risk of accepting JWTs via URL query parameters?**

- A) Query parameters are encrypted differently than headers
- B) Query parameters cannot contain Base64 characters
- C) URL tokens are automatically shorter and easier to brute-force
- D) Tokens in URLs leak via browser history, server logs, Referer headers, and proxy logs ✓

**Explanation:** URLs are logged extensively — in browser history, web server access logs, proxy logs, and HTTP Referer headers sent to third-party resources. A JWT in a URL is effectively exposed to every system that handles the request path.

---

**Q6. After discovering the URL token vulnerability, you also find that `POST /api/change-password` does not invalidate existing tokens. What attack chain does this enable?**

- A) Token capture from URL logs → password changed by user → captured token still works ✓
- B) Algorithm confusion followed by privilege escalation
- C) Session fixation via the password reset flow
- D) Brute-force attack on the new password

**Explanation:** If old tokens remain valid after password change, an attacker who captured a token from URL logs can use it indefinitely, even after the user changes their password. This combines token leakage with missing revocation.

---

> **Scenario for Q7-Q8:** You discover a JWKS endpoint at `/.well-known/jwks.json` that exposes an RSA public key. The protected endpoint at `GET /api/rs256/data` returns `{"error": "Invalid token"}` when you submit an unsigned token.

**Q7. You craft a token with `"alg": "HS256"` and sign it using the RSA public key PEM bytes. The server returns `200 OK`. What does this confirm?**

- A) The server only accepts HS256 tokens
- B) The JWKS endpoint is misconfigured
- C) The server accepts both RS256 and HS256, enabling algorithm confusion ✓
- D) The RSA private key has been compromised

**Explanation:** A successful response confirms the server's `algorithms` parameter includes both `RS256` and `HS256`. The server used the public key to verify the HS256 signature — the classic algorithm confusion vulnerability.

---

**Q8. What is the correct CVSS 3.1 severity for the algorithm confusion vulnerability you just confirmed?**

- A) Medium (4.0-6.9)
- B) High (7.0-8.9)
- C) Critical (9.0-10.0) ✓
- D) Low (0.1-3.9)

**Explanation:** Algorithm confusion enables complete authentication bypass — any user identity can be forged using the public key. CVSS: AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N = 9.1 (Critical). No privileges required, network-exploitable, complete confidentiality and integrity impact.

---

**Q9. You embed your own RSA public key in the JWT's `jwk` header and sign the token with your private key. The server accepts it. What vulnerability class does this exploit?**

- A) Algorithm confusion
- B) JWK header injection — the server trusts the key embedded in the token ✓
- C) kid path traversal
- D) Signature stripping

**Explanation:** When a server uses the `jwk` value from the token header as the verification key, an attacker provides their own key pair. They sign with their private key and embed the matching public key in the token — the server verifies successfully using the attacker's key.

---

**Q10. Rank the following JWT findings by severity (highest to lowest):**

1. Algorithm confusion (RS256 → HS256)
2. `alg:none` accepted
3. Weak HMAC secret ("password123")
4. Missing `aud` claim validation

- A) 2, 1, 3, 4 ✓
- B) 1, 2, 3, 4
- C) 3, 2, 1, 4
- D) 2, 3, 1, 4

**Explanation:** `alg:none` (complete bypass, zero effort) > algorithm confusion (bypass, requires public key) > weak secret (bypass, requires brute-force time) > missing `aud` (limited cross-service impact). All are critical/high, but ease of exploitation determines the ranking.

---

## Level 3 Assessment: Red Team JWT Operations

### Instructions
- 8 scenario-based questions + 1 practical exercise
- 80% on questions + passing practical required
- Time limit: 30 minutes (questions) + 45 minutes (practical)

---

### Questions

> **Scenario for Q1-Q2:** You are building an automated JWT security testing framework. The framework should test multiple attack vectors against target endpoints and produce a professional report.

**Q1. Which module architecture is MOST effective for a JWT pentest framework?**

- A) A single monolithic script that tests all vulnerabilities sequentially
- B) A web application that proxies and modifies JWT tokens
- C) Separate standalone scripts for each vulnerability
- D) A plugin-based architecture with separate attack modules, a token acquisition module, and a results aggregator ✓

**Explanation:** A plugin-based architecture allows adding new attack modules without modifying existing code, supports parallel execution, and separates concerns (acquisition → attack → reporting). This is the pattern used by professional tools like jwt_tool.

---

**Q2. Your framework's `weak_secret` module tests 100,000 passwords per second. How should you optimize it for larger wordlists?**

- A) Use GPU acceleration via hashcat integration
- B) Use Python's `multiprocessing` to distribute across CPU cores ✓
- C) Switch to an interpreted language for faster execution
- D) Reduce the wordlist to only the top 100 passwords

**Explanation:** Python's `multiprocessing` module distributes HMAC computations across CPU cores, achieving near-linear speedup. For extremely large wordlists (millions+), hashcat with GPU acceleration is the industry standard, but for a Python framework, multiprocessing is the practical choice.

---

> **Scenario for Q3-Q4:** Your organization wants to integrate JWT security testing into their CI/CD pipeline to catch vulnerabilities before deployment.

**Q3. Which Semgrep rule pattern would detect a vulnerable JWT algorithms list that includes "none"?**

- A) `pattern: jwt.decode($TOKEN, $KEY, algorithms=["none"])` — only catches exact match
- B) `pattern: jwt.decode($TOKEN)` — catches all JWT decode calls
- C) `pattern: jwt.decode($TOKEN, $KEY, algorithms=[..., "none", ...])` ✓
- D) `pattern: algorithms=["none"]` — too broad, matches non-JWT code

**Explanation:** Semgrep's `[..., "none", ...]` spread pattern matches any list containing `"none"` regardless of position or other elements. This catches `["HS256", "none"]`, `["none", "RS256"]`, and any other combination.

---

**Q4. At which CI/CD pipeline stage should JWT security tests run?**

- A) Only in production monitoring
- B) Only during annual security audits
- C) In pre-merge checks (pull request) and pre-deployment gates ✓
- D) Only after deployment to staging

**Explanation:** JWT security tests should run as early as possible — ideally as pre-merge PR checks so vulnerable code never reaches the main branch. A pre-deployment gate provides a second layer. Both are needed for defense in depth.

---

> **Scenario for Q5-Q6:** During a penetration test, you discover that the target application's JWT signing key has been compromised (leaked in a public GitHub repository). The key has been in use for 6 months.

**Q5. What is the MOST critical immediate action the security team should take?**

- A) Rotate the signing key and invalidate all existing tokens ✓
- B) Monitor for suspicious activity
- C) Notify affected users
- D) File a CVE

**Explanation:** Key rotation with immediate token invalidation stops the attack. Monitoring alone allows continued exploitation. User notification and CVE filing are important but secondary to stopping active abuse.

---

**Q6. In your penetration test report, how should you describe the blast radius of a compromised JWT signing key?**

- A) Limited to sessions created with the compromised key
- B) Only affects new sessions, not existing ones
- C) Limited to users who logged in during the compromise window
- D) Total authentication bypass — any user identity can be impersonated for the entire period the key was in use ✓

**Explanation:** A compromised signing key means the attacker can forge tokens for ANY user with ANY role at ANY time. Unlike a compromised password (one user), a key compromise affects the entire system's authentication trust model.

---

**Q7. A penetration test finding states: "JWT tokens are stored in localStorage." What evidence should accompany this finding?**

- A) A screenshot of the browser's Application tab showing the token in localStorage ✓
- B) The CVSS score calculation only
- C) A theoretical explanation of XSS risks
- D) The application's architecture diagram

**Explanation:** Professional findings require concrete evidence — screenshots, request/response captures, or PoC scripts. A screenshot of the token in localStorage proves the vulnerability exists and shows exactly what data is exposed.

---

**Q8. Which log pattern would indicate an active `alg:none` attack against a JWT-protected API?**

- A) Multiple failed login attempts from the same IP
- B) Successful API requests with tokens containing `"alg":"none"` in the decoded header ✓
- C) Increased traffic to the JWKS endpoint
- D) High CPU usage on the authentication server

**Explanation:** An `alg:none` attack produces tokens with no algorithm — if logged, the decoded header shows `"alg":"none"`. Successful requests with such tokens indicate both an active attack AND a vulnerable server. Failed requests indicate attack attempts against a properly configured server.

---

### Practical Exercise: Complete JWT Penetration Test

**Scenario:** You have been authorized to perform a security assessment of a web application's JWT implementation. The vulnerable application is running at `http://127.0.0.1:5000` (the `vulnerable-jwt-app.py` training target).

Your assessment scope includes all endpoints listed at `GET /`.

**Deliverables:**

1. **Reconnaissance report** documenting all JWT-related attack surface identified
2. **Exploit PoC scripts** for at least 5 distinct vulnerability classes
3. **Findings report** with severity ratings (CVSS 3.1), steps to reproduce, impact analysis, and remediation recommendations for each finding
4. **Executive summary** (3-5 sentences) suitable for non-technical stakeholders
5. **Remediation verification plan** describing how to confirm each fix is effective

**Evaluation Criteria:**

| Criterion | Pass Requirement |
|-----------|------------------|
| Reconnaissance | Identifies all 10 planted vulnerabilities across all endpoints |
| Exploit Quality | At least 5 working PoC scripts with clear output |
| Finding Severity | CVSS scores within 1 point of reference values |
| Remediation | Specific, actionable fix for each finding (not generic) |
| Report Quality | Professional format with evidence, reproducible steps |
| Executive Summary | Non-technical, accurate, conveys business impact |

---

## Answer Keys

### L1 Answers
1-C, 2-B, 3-A, 4-D, 5-B, 6-C, 7-C, 8-D, 9-A, 10-A

### L2 Answers
1-C, 2-B, 3-D, 4-A, 5-D, 6-A, 7-C, 8-C, 9-B, 10-A

### L3 Answers
1-D, 2-B, 3-C, 4-C, 5-A, 6-D, 7-A, 8-B
Practical: Rubric-based evaluation

---

**Document Version:** 1.0
**Framework:** HAIAMM v2.0
**Practice:** Education & Guidance (EG)
**Domain:** Software (Lab)
**Author:** Verifhai
